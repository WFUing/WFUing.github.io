<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>WFUing</title>
    <link>https://WFUing.github.io/</link>
    <description>Recent content on WFUing</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 12 Oct 2023 19:29:44 +0800</lastBuildDate><atom:link href="https://WFUing.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Telosys: a Code Generation Tool by Laurent Guerin</title>
      <link>https://WFUing.github.io/posts/tech/code-generation/telosys-code-generation-tool/</link>
      <pubDate>Thu, 12 Oct 2023 19:29:44 +0800</pubDate>
      
      <guid>https://WFUing.github.io/posts/tech/code-generation/telosys-code-generation-tool/</guid>
      <description>Resources url: https://www.telosys.org/ tutorial: https://tomassetti.me/telosys-code-generation-tool/ </description>
    </item>
    
    <item>
      <title>The Mythical Man Month Thoughts</title>
      <link>https://WFUing.github.io/posts/read/the-mythical-man-month-thoughts/</link>
      <pubDate>Thu, 12 Oct 2023 19:16:22 +0800</pubDate>
      
      <guid>https://WFUing.github.io/posts/read/the-mythical-man-month-thoughts/</guid>
      <description>一、书名和作者 书名：《人月神话》 作者：布鲁克斯(FrederickP.Brooks.Jr.) 二、书籍概览 主要论点和结构 《人月神话》是一本旨在深入探讨软件工程中的管理和工程问题的经典著作。本书强调了软件开发过程中的复杂性和挑战，尤其是在大规模项目中。书中还探讨了许多经典观点，如&amp;quot;人月神话&amp;quot;、&amp;ldquo;二八定律&amp;quot;和&amp;quot;沟通成本&amp;rdquo;，为软件行业的专业人员提供了宝贵的见解和管理原则，使他们能够更好地理解和应对软件项目的挑战。
目标读者和应用场景 该书的目标读者包括软件工程师、项目经理、团队领导和决策者，以及任何对软件开发过程感兴趣的人。对于软件开发工程师来说，这本书提供了宝贵的洞察，帮助他们更好地理解项目管理和团队协作的挑战；对于项目经理来说，本书提供了管理大型软件项目所需的关键原则和策略；领导小型或大型软件团队的人员可以从本书中获得关于如何优化团队协作、提高效率和管理项目的方法；即使不是专业人员，任何对软件开发过程感兴趣的人都可以从本书中获得对软件工程领域的深入了解，从而更好地理解和评估不同软件项目。总的来说，《人月神话》适用于各种软件项目，无论是大规模的企业级项目还是小规模的个人项目。
三、核心观点与主题 1. 人月神话
人月神话的产生 《人月神话》的核心观点之一是关于&amp;quot;人月神话&amp;quot;本身的产生。这一概念源自于普遍存在的一种误解，即认为增加项目开发的人员数量会自动缩短项目完成时间。作者布鲁克斯解释了这种误解的根源，即对软件工程的特殊性和复杂性的不理解。这种误解在早期的计算机领域中非常普遍，导致了一些项目的失败和项目时间的延长。
后果和启发 项目增加人员后出现的管理问题和沟通成本的急剧上升，最后导致了项目的失败，包括延期、成本超支和低质量交付等。这些后果为软件开发的实践带来了极大的挑战，但也激发了对更好方法的追求。软件工程领域需要更多的规划、需求管理和团队协作，以避免人员增加引发的问题。
实例或案例 一个鲜明的案例是IBM的OS/360项目，该项目是为了开发一种崭新的操作系统。初期，这个项目规模宏大，聚集了大量人员资源，充满了雄心壮志，然而，很快就陷入了严重的延期和质量问题的泥淖。在这个项目中，管理层采取了一种常见的措施，即试图通过增加项目开发的人员数量来加快进度。然而，结果却截然不同于期望。
2. 二八定律
二八定律的阐述 本书的第二个重要主题是&amp;quot;二八定律&amp;quot;，它强调了在软件开发中常见的现象，即80%的工作通常需要80%的时间，而剩下的20%工作同样需要80%的时间。这一定律揭示了工作任务的不均衡性，以及为什么某些部分的工作似乎总是比预期需要更多的时间。作者详细探讨了这一定律的背后原因，以及它在软件工程中的应用。
重要任务的优先性 项目中的关键任务和非关键任务应当被明智地区分开来。关键任务往往占据大部分时间和资源，因此它们的规划和执行至关重要。这个观点呼吁项目管理者和团队要明智地设置优先级，确保关键任务首先得到充分关注，以确保项目能够按计划顺利进行。
实例或案例 一个生动的例子是在软件开发项目中的功能开发和测试。根据二八定律，80%的开发工作可能会占用80%的时间，但剩下的20%的时间可能都被用于测试和调试。这种情况表明，关键任务（测试）常常被放在项目的后期，从而导致项目延期和问题的累积。通过理解这一现象，团队可以更好地规划项目，提前考虑到测试和质量保证，从而避免在后期因紧急问题而忙乱无序。这个案例强调了二八定律的实际应用，以提高项目的效率和成功率。
3. 沟通成本
沟通成本的重要性 这本书的第三个主题关注了&amp;quot;沟通成本&amp;quot;的概念。沟通在软件开发项目中是至关重要的，因为团队成员需要共同合作、协调工作和共享信息。然而，随着团队规模的增大，沟通的复杂性也随之增加。所以为了有效地合作，必须投入时间和精力来解决沟通问题。
沟通成本的增加 随着团队规模的增加，沟通成本的急剧上升。当团队规模庞大时，需要花更多的时间来协调、汇报和共享信息。这不仅仅是人员增加导致的问题，还包括了更多的管理层次、更多的会议和文档。这会消耗时间和资源，导致项目时间表的延迟。
实例或案例 在大型软件开发项目中，特别是在跨地理位置分布的全球团队中，沟通成本的急剧上升。团队成员分布在不同的时区，可能使用不同的语言和文化，这会增加沟通的困难。管理层必须花更多的时间来协调跨团队合作，编写文档以确保信息传递清晰，以及组织跨地域的会议。这些额外的沟通成本不仅会影响项目进度，还可能导致误解和沟通失败。通过理解沟通成本的重要性和增加，团队可以采取更有效的沟通策略，包括利用技术工具、清晰的沟通计划和团队培训，以减轻这一问题带来的负面影响。这个案例强调了如何通过降低沟通成本来提高项目的成功机会。
4. 团队工作
团队工作的重要性 软件开发项目往往需要多个团队成员之间的有效合作，包括程序员、测试人员、设计师和管理者，团队协作的不可或缺，才能保证项目成功完成。
团队协作所面临的挑战 随着团队规模的扩大，不同成员之间的协调和沟通变得更加困难。这可能导致沟通失误、工作分配的混乱和项目的延期。有效的团队协作不仅涉及技术层面，还需要关注人际关系和沟通技巧。
实例或案例 考虑一个涉及多个团队的复杂项目，每个团队负责不同的模块或组件。如果团队之间的协调和沟通不顺畅，可能会导致不同部分之间的不一致，甚至出现集成问题。
四、亮点与启发 最有影响的观点或实例 在《人月神话》中，最有影响的观点之一是关于&amp;quot;人月神话&amp;quot;本身。这一观点深刻地揭示了在软件开发项目中的一个普遍误解，即增加项目开发的人员数量会缩短项目时间。通过生动的IBM的OS/360项目的案例，作者清晰地展示了增加人员数量并不总是解决方案，反而可能导致更多的管理和沟通成本，从而延长项目时间表。这个观点对软件工程领域产生了深远的影响，提醒我们要谨慎处理人员规模的增长，强调了规划、管理和沟通的重要性。
另一个关键观点是&amp;quot;二八定律&amp;quot;，它解释了为什么80%的工作通常需要80%的时间，而剩下的20%同样需要80%的时间。这一定律强调了项目中关键任务的优先性和规划的必要性。通过理解这一观点，团队可以更好地分配资源和精力，确保项目关键任务的顺利执行，从而避免时间表的延迟和资源浪费。
对个人或专业发展的启示 它提醒我们要对软件工程项目的复杂性和挑战有充分的认识。软件开发不同于传统工程，它涉及到人、技术和管理的多层次交互。因此，我们需要谨慎规划、有效沟通和管理，以确保项目的成功。此外，书中的案例和观点强调了团队协作的不可或缺性。无论是在大型企业项目还是小型团队中，团队成员之间的合作和协调至关重要。这启示我们要发展良好的团队协作技能，倾听他人的意见，学会解决冲突，以实现共同的目标。通过《人月神话》，我们能够深入理解软件工程的本质，从中汲取宝贵的经验教训，不仅提高专业素养，还能应用于各种项目和团队，推动软件工程领域的不断进步。
五、批评与局限性 任何有争议、模糊或过时的信息 尽管《人月神话》包含了许多宝贵的观点和经验教训，但也存在一些有争议、模糊或过时的信息。首先，书中的一些案例和观点可能仅适用于特定的历史背景，因为软件工程领域在书写时已经发生了巨大的变化。例如，书中提到的硬件和软件环境可能与现代技术和工具有很大不同，因此某些观点可能已经过时。此外，一些观点可能在不同背景下产生争议。例如，在某些敏捷开发项目中，强调小团队、快速迭代和自组织可能与书中的一些建议相悖。因此，读者需要谨慎评估书中的观点，以确保其适用于其具体的项目和环境。
可能的不足或缺陷 一个潜在的不足是书中强调的某些问题可能过于简化了复杂的软件工程现实。例如，书中提到的&amp;quot;人月神话&amp;quot;观点虽然有其价值，但它可能过于一概而论。在实际项目中，项目规模、团队结构和技术要求各不相同，因此不同项目可能会有不同的最佳实践。这种简化可能导致读者忽视了项目的特定需求。此外，书中强调的一些建议和技巧可能需要更多的上下文和实际操作指南。读者可能需要额外的资源来理解如何具体应用这些原则。因此，书中的一些内容可能缺乏具体的实施细节，这可能对一些读者而言是不足之处。
六、实际应用和拓展 在实际工作 / 学习中如何应用这些概念 《人月神话》中的概念对实际工作和学习有重要意义。首先，对于软件工程领域的专业人士，书中的观点提供了宝贵的指导，如如何有效地管理项目、规划资源、协调团队和降低沟通成本。对于项目经理、团队领导和决策者，这些观点有助于更好地理解软件项目的特殊性和复杂性，从而提高项目的成功机会。
其次，这些概念也适用于其他领域，特别是项目管理领域。无论是在制造业、医疗保健、建筑业还是任何需要团队合作和资源管理的领域，书中的原则都具有通用性。学习如何应对复杂性、规划和协调资源以及降低沟通成本对于任何项目的成功都是至关重要的。
对未来研究或实践的建议 随着技术的不断发展，需要考虑新兴技术对软件工程和项目管理的影响。例如，人工智能、云计算和大数据等新技术如何改变项目的性质和需求。
其次，可以深入研究如何应对全球化和跨文化团队合作的挑战。随着全球化趋势的加强，团队成员可能分布在不同国家和文化中，如何有效协作和沟通将成为一个重要的研究领域。
七、总结与评价 对书籍的整体评价 《人月神话》是一本经典的软件工程管理著作，提供了深刻的洞察和宝贵的经验教训。它以清晰、易懂的语言讨论了软件开发中的复杂性和挑战，强调了管理和工程方面的重要性。这本书的长期影响力可见一斑，许多软件专业人士将其视为必读之作。
书籍的长处和短处 长处：
经典观点： 书中的观点，如&amp;quot;人月神话&amp;quot;和&amp;quot;二八定律&amp;quot;，具有深远的影响，为软件工程管理提供了宝贵的指导。 实际建议： 书中提供了许多实际的管理建议和案例，读者可以在实际项目中应用。 通俗易懂： 作者以平易近人的语言阐释了复杂的概念，使其对广大读者更容易理解。 跨学科性： 书中的原则和观点不仅适用于软件工程领域，还适用于其他项目管理领域。 短处：</description>
    </item>
    
    <item>
      <title>Leetcode</title>
      <link>https://WFUing.github.io/posts/tech/algorithm/leetcode/</link>
      <pubDate>Thu, 12 Oct 2023 17:05:17 +0800</pubDate>
      
      <guid>https://WFUing.github.io/posts/tech/algorithm/leetcode/</guid>
      <description>动态规划 【LeetCode 55】跳跃游戏 【LeetCode 72】编辑距离 【LeetCode 115】不同的子序列 【LeetCode 124】二叉树中的最大路径和 【LeetCode 174】地下城游戏 【LeetCode 188】买卖股票的最佳时机IV 【LeetCode 198】打家劫舍 【LeetCode 213】打家劫舍II 【LeetCode 233】数字1的个数 【LeetCode 300】最长递增子序列 【LeetCode 309】最佳买卖股票时机含冷冻期 【LeetCode 312】戳气球 【LeetCode 337】打家劫舍III 【LeetCode 354】俄罗斯套娃信封问题 【LeetCode 376】摆动序列 【LeetCode 390】消除游戏 【LeetCode 689】三个无重叠子数组的最大和 【LeetCode 714】买卖股票的最佳时机含手续费 【LeetCode 907】子数组的最小值之和 【LeetCode 943】最短超级串 【LeetCode 1031】两个非重叠子数组的最大和 【LeetCode 1039】多边形三角剖分的最低得分 【LeetCode 1186】删除一次得到子数组最大和 【LeetCode 系列】买卖股票的最佳时机 【LeetCode 面试题 08.11】硬币 贪心算法 【LeetCode 55】跳跃游戏 【LeetCode 121】买卖股票的最佳时机 【LeetCode 122】买卖股票的最佳时机II 【LeetCode 123】买卖股票的最佳时机III 【LeetCode 42】接雨水 【LeetCode 135】分发糖果 </description>
    </item>
    
    <item>
      <title>Code generation for Langium-based DSLs</title>
      <link>https://WFUing.github.io/posts/tech/code-generation/code-generation-for-langium-based-dsls/</link>
      <pubDate>Thu, 12 Oct 2023 14:43:44 +0800</pubDate>
      
      <guid>https://WFUing.github.io/posts/tech/code-generation/code-generation-for-langium-based-dsls/</guid>
      <description>DSL 和 DSL 工具的一个重要方面是代码生成。DSL 本身在形式化、指定和交流内容方面具有优势，因为它们具有特定领域的性质。但是，如果能从指定的内容中推导出实现代码，就能大大提高工作效率。
Resources blogs https://www.typefox.io/blog/code-generation-for-langium-based-dsls/ https://www.typefox.io/blog/code-generation-for-langium-based-dsls-2 https://www.typefox.io/blog/code-generation-for-langium-based-dsls-3/ github repo: https://github.com/TypeFox/langium-in-browser-codegen-example/tree/main https://github.com/eclipse-langium/langium/blob/main/examples/arithmetics 运行示例 本帖中的运行示例使用 Langium 的 Arithmetics 示例实现。Arithmetics 的 grammar 见 arithmetics.langium
代码生成器的输入示例如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 MODULE priceCalculator DEF materialPerUnit: 100; DEF laborPerUnit: 200; DEF costPerUnit: materialPerUnit + laborPerUnit; DEF expectedNoOfSales: 200; DEF costOfGoodsSold: expectedNoOfSales * costPerUnit; DEF generalExpensesAndSales: 10000; DEF desiredProfitPerUnit: 50; DEF netPrice: (costOfGoodsSold + generalExpensesAndSales) / expectedNoOfSales + desiredProfitPerUnit; DEF vat: 0.</description>
    </item>
    
    <item>
      <title>Template Engine</title>
      <link>https://WFUing.github.io/posts/tech/code-generation/template-engine/</link>
      <pubDate>Thu, 12 Oct 2023 14:43:44 +0800</pubDate>
      
      <guid>https://WFUing.github.io/posts/tech/code-generation/template-engine/</guid>
      <description>模板引擎 模板引擎（也称为模板处理器或模板解析器）是设计用于将模板与数据模型结合起来以生成结果文档的软件，编写模板所用的语言称为模板语言或模板语言。模板引擎通常作为 Web 模板系统或应用程序框架的一部分，也可以用作预处理器或过滤器。流行的模板引擎包括 Ejs、Jade、Pug、Mustache、HandlebarsJS、Jinja2 和 Blade。
模板引擎如何工作 上图说明了模板引擎的所有基本元素和处理流程。
使用模板引擎构建服务器端应用程序时，模板引擎会将模板文件中的变量替换为实际值，并将此值显示给客户端。这样，我们就能更轻松地快速构建应用程序。
使用 expressJS 和 ejs 模板引擎的示例 对于使用 NodeJS 运行时编写的服务器端应用程序，可以使用模板引擎。
以下步骤演示了模板引擎如何使用 expressJs 和 ejs 模板引擎工作。下面的示例在网页上渲染用户数据。
步骤 1：安装 express 和 ejs 模板引擎
安装 ejs 模板引擎和 express 框架，
1 npm install express ejs 步骤 2：设置视图引擎
1 2 3 4 5 6 7 8 const express = require(&amp;#34;express&amp;#34;) const app = express(); // Set the View Engine or Template Engine app.set(&amp;#39;view engine&amp;#39;, &amp;#39;ejs&amp;#39;); app.listen(3000) 在上面的代码中，我们创建了 express 应用程序。该应用程序通过 3000 端口监听。</description>
    </item>
    
    <item>
      <title>How to Build Github Blog With Hugo</title>
      <link>https://WFUing.github.io/posts/tech/git/github-blog/how-to-build-github-blog-with-hugo/</link>
      <pubDate>Thu, 12 Oct 2023 14:39:05 +0800</pubDate>
      
      <guid>https://WFUing.github.io/posts/tech/git/github-blog/how-to-build-github-blog-with-hugo/</guid>
      <description>今天花了一点时间搭建了自己的GitHub的博客，当然咯，试验阶段总会发生很多乱七八糟的问题，记录下处理问题过程中几个比较 nice 的 blog
Resources 系列文章，用hugo的PaperMod Theme 建站：https://www.sulvblog.cn/posts/blog/ Hugo + GitHub Action，搭建你的博客自动发布系统：https://www.pseudoyu.com/zh/2022/05/29/deploy_your_blog_using_hugo_and_github_action/ PaperMod主题优化：https://kdjlyy.cn/posts/site/hugo-papermod-optimization </description>
    </item>
    
    <item>
      <title>A Guide to Code Generation</title>
      <link>https://WFUing.github.io/posts/tech/code-generation/a-guide-to-code-generation/</link>
      <pubDate>Thu, 12 Oct 2023 11:40:20 +0800</pubDate>
      
      <guid>https://WFUing.github.io/posts/tech/code-generation/a-guide-to-code-generation/</guid>
      <description>为什么要用代码生成 productivity：使用代码生成，只需编写一次 generator ，就可以根据需要多次重复使用。向 generator 提供特定输入并调用它比手动编写代码要快得多，因此代码生成可以节省时间。 Simplification：通过代码生成，你可以从一些抽象的描述中生成代码。需要维护的部分变成了 generator 的输入部分，该部分通常是代码的描述，而不是代码本身，与整个生成的代码相比，该描述通常更容易分析和检查。 Portability：一旦你有了为某种语言或框架生成代码的程序，你就可以简单地更改 generator ，并以不同的语言或框架为目标。您还可以同时针对多个平台。 例如，使用解析器生成器，您可以获得 C#、Java 和 C++ 的 parser。 另一个例子：您可能会编写一个 UML 图表，然后使用代码生成器用 C# 创建一个骨架类，并用 SQL 代码为 MySQL 创建一个数据库。因此，相同的抽象描述可用于生成不同类型的工件。 Consistency：有了代码生成，你总能得到你所期望的代码。生成的代码是根据相同的原则设计的，命名规则等也是一致的。当然，除了生成器中的 bug 之外，代码总是能按照你所期望的方式运行，代码质量始终如一。如果用手工编写代码，不同的开发人员可能会使用不同的风格，即使是最重复的代码也会偶尔出现错误。 为什么不要用代码生成 Maintenance：当您使用代码生成工具时，您的代码就会依赖于它。代码生成工具必须得到维护。如果你创建了它，你就必须不断更新它；如果你只是使用现有的工具，你就必须希望有人继续维护它，或者你必须自己接手。因此，代码生成的优势并不是免费的。如果你没有或找不到合适的能力来维护代码生成器，风险就会更大。 Complexity：自动生成的代码往往比手工编写的代码更复杂。有时，这与将不同部分连接在一起所需的胶水代码有关，或者与生成器支持的用例多于您所需的用例有关。在第二种情况下，生成的代码可以做比你想要的更多的事情，但这并不一定是一种优势。生成代码的优化程度肯定也不如手工编写的代码。有时这种差异很小，并不明显，但如果您的应用程序需要尽可能地提高性能，那么生成的代码对您来说可能并不是最佳选择。 如何使用代码生成? 根据具体情况，代码生成既可以提高工作效率，也可以成为开发过程中的重要组成部分。许多现代集成开发环境就是一个有用的例子：只需点击一个按钮，就能创建一个骨架类来实现接口或类似功能。你完全可以自己编写这样的代码，只不过会浪费一些时间来完成琐碎的任务。
设计代码生成流水线的方法有很多种。基本上，我们需要定义两个要素：
Input：用于生成代码的信息来自何处。 Output：如何获得生成的代码。 您也可以在输入和输出之间设置转换步骤。这些步骤可以简化输出层，并使输入和输出更加独立。
Possible Inputs
A DSL：例如，我们可以使用 ANTLR 来描述一种语言的语法。由此，我们可以生成一个解析器。 code in other formats：数据库模式。根据数据库模式，我们可以生成 DAO。 wizards：它们允许向用户询问信息。 reverse engineering：可通过处理复杂的代码工件获得信息。 data sources：比如一个DB，一个csv文件或者一个电子表格。 Possible Outputs
template engine：大多数网络程序员都知道模板引擎，它用于在 HTML UI 中填充数据。 code building APIs：例如，Javaparser 可用于以编程方式创建 Java 文件。 Some Pipelines</description>
    </item>
    
    
    
    
    
  </channel>
</rss>
