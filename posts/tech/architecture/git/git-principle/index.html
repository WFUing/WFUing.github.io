<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="Waiting For You">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://WFUing.github.io//">
    <meta property="twitter:image" content="https://WFUing.github.io//" />
    

    
    <meta name="title" content="Git Principle" />
    <meta property="og:title" content="Git Principle" />
    <meta property="twitter:title" content="Git Principle" />
    

    
    <meta name="description" content="这是一个纯粹的博客......">
    <meta property="og:description" content="这是一个纯粹的博客......" />
    <meta property="twitter:description" content="这是一个纯粹的博客......" />
    

    
    <meta property="twitter:card" content="Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，而 Git 是把数据看作是对小型文件系统的一系列快照。" />
    
    

    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Git Principle | </title>

    <link rel="canonical" href="/posts/tech/architecture/git/git-principle/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link rel="stylesheet" href="/css/font-awesome.all.min.css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="/js/lazysizes.min.js"></script>

    
    

</head>






<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Waiting For You</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                    
                    
		    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/" title="">
                            
                        </a>
                        
                    </div>
                    <h1>Git Principle</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                    Waiting For You
                             
                            on 
                            Thursday, October 19, 2023
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h2 id="git-简介">Git 简介</h2>
<h3 id="git-是什么">Git 是什么</h3>
<p>Git 是一个开源的分布式版本控制系统。</p>
<p>Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，而 Git 是把数据看作是对小型文件系统的一系列快照。</p>
<h3 id="什么是版本控制">什么是版本控制</h3>
<p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<h4 id="集中化的版本控制系统">集中化的版本控制系统</h4>
<p>介绍分布式版本控制系统前，有必要先了解一下传统的集中式版本控制系统。</p>
<p><strong>集中化的版本控制系统</strong>，诸如 CVS，Subversion 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
<p>这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录。</p>
<center>
<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" style="max-width:50%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/central-vcs-server.png" />
    </div>
    <a href="./central-vcs-server.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<h4 id="分布式版本控制系统">分布式版本控制系统</h4>
<p><strong>分布式版本控制系统</strong>的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。</p>
<center>

<div class="box" style="max-width:60%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/local-to-center.png" />
    </div>
    <a href="./local-to-center.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<h3 id="为什么使用-git">为什么使用 Git</h3>
<p>Git 是分布式的。这是 Git 和其它非分布式的版本控制系统（例如 svn，cvs 等），最核心的区别。分布式带来以下好处：</p>
<ul>
<li><strong>工作时不需要联网</strong> - 首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</li>
<li><strong>更加安全</strong>
<ul>
<li>集中式版本控制系统，一旦中央服务器出了问题，所有人都无法工作。</li>
<li>分布式版本控制系统，每个人电脑中都有完整的版本库，所以某人的机器挂了，并不影响其它人。</li>
</ul>
</li>
</ul>
<h3 id="git-的工作原理">Git 的工作原理</h3>
<p>个人认为，对于 Git 这个版本工具，再不了解原理的情况下，直接去学习命令行，可能会一头雾水。所以，本文特意将原理放在命令使用章节之前讲解。</p>
<h4 id="版本库">版本库</h4>
<p>当你一个项目到本地或创建一个 git 项目，项目目录下会有一个隐藏的 <code>.git</code> 子目录。这个目录是 git 用来跟踪管理版本库的，如果不熟悉其工作机制，千万不要手动修改。</p>


<div class="box" style="max-width:80%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/git-local.png" />
    </div>
    <a href="./git-local.png" itemprop="contentUrl"></a>
  </figure>
</div>

<ul>
<li><code>hooks</code> 目录：包含客户端或服务端的钩子脚本（hook scripts）</li>
<li><code>info</code> 目录：包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 <code>.gitignore</code> 文件中的忽略模式（ignored patterns）。</li>
<li><code>objects</code> 目录：存储所有数据内容。</li>
<li><code>refs</code> 目录：存储指向数据（分支、远程仓库和标签等）的提交对象的指针</li>
<li><code>HEAD</code> 文件：指向目前被检出的分支。</li>
<li><code>index</code> 文件保存暂存区信息。</li>
<li><code>config</code> 文件：包含项目特有的配置选项。</li>
<li><code>description</code> 文件：<code>description</code> 文件仅供 GitWeb 程序使用，我们无需关心。</li>
</ul>
<h4 id="哈希值">哈希值</h4>
<p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能构筑在 Git 底层，是 Git 的关键组件。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 计算校验和的使用 SHA-1 哈希算法。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希值看起来是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">24b9da6552252987aa493b52f8696cd6d3b00373
</span></span></code></pre></td></tr></table>
</div>
</div><p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h4 id="文件状态">文件状态</h4>
<p>在 GIt 中，你的文件可能会处于三种状态之一：</p>
<ul>
<li><strong>已修改（modified）</strong> - 已修改表示修改了文件，但还没保存到数据库中。</li>
<li><strong>已暂存（staged）</strong> - 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li><strong>已提交（committed）</strong> - 已提交表示数据已经安全的保存在本地数据库中。</li>
</ul>
<h4 id="工作区域">工作区域</h4>
<p>与文件状态对应的，不同状态的文件在 Git 中处于不同的工作区域。</p>
<ul>
<li><strong>工作区（working）</strong> - 当你 <code>git clone</code> 一个项目到本地，相当于在本地克隆了项目的一个副本。工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li><strong>暂存区（staging）</strong> - 暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’&rsquo;，不过一般说法还是叫暂存区。</li>
<li><strong>本地仓库（local）</strong> - 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库。</li>
<li><strong>远程仓库（remote）</strong> - 以上几个工作区都是在本地。为了让别人可以看到你的修改，你需要将你的更新推送到远程仓库。同理，如果你想同步别人的修改，你需要从远程仓库拉取更新。</li>
</ul>
<center>

<div class="box" style="max-width:80%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/git-theory.png" />
    </div>
    <a href="./git-theory.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<h2 id="分支管理">分支管理</h2>
<h3 id="git-flow">Git Flow</h3>
<p>Git Flow 应该是目前流传最广的 Git 分支管理策略。Git Flow 围绕的核心点是版本发布（release），它适用于迭代版本较长的项目。</p>
<center>

<div class="box" style="max-width:80%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/git-flow.png" />
    </div>
    <a href="./git-flow.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<blockquote>
<p>详细内容，可以参考这篇文章：<a href="http://www.cnblogs.com/cnblogsfans/p/5075073.html">Git 在团队中的最佳实践&ndash;如何正确使用 Git Flow</a></p>
</blockquote>
<p>Git Flow 常用分支：</p>
<ul>
<li><strong><code>master</code></strong> - 主线分支</li>
<li><strong><code>develop</code></strong> - 开发分支</li>
<li><strong><code>feature</code></strong> - 特性分支</li>
<li><strong><code>release</code></strong> - 发布分支</li>
<li><strong><code>hotfix</code></strong> - 问题修复分支</li>
</ul>
<p>Git Flow 工作流程</p>
<h4 id="21-主干分支">2.1. 主干分支</h4>
<center>

<div class="box" style="max-width:50%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/master.png" />
    </div>
    <a href="./master.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<p>主干分支有两个，它们是伴随着项目生命周期长期存在的分支。</p>
<ul>
<li><code>master</code> - 这个分支对应发布到生产环境的代码。这个分支<strong>只允许从其他分支合入代码</strong>，不能在这个分支直接修改。所有在 master 分支上的 Commit 都应该打 Tag。</li>
<li><code>develop</code> - 这个分支包含所有要发布到下一个 release 的代码，这个分支<strong>主要是从其他分支合入代码</strong>，比如 feature 分支。</li>
</ul>
<h4 id="22-feature-分支">2.2. <code>feature</code> 分支</h4>
<p>这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回 develop 分支进入下一个 release。feature 分支开发结束后，必须合并回 develop 分支, 合并完分支后一般会删点这个 feature 分支，但是我们也可以保留。</p>
<center>

<div class="box" style="max-width:20%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/feature.png" />
    </div>
    <a href="./feature.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<h4 id="23-release-分支">2.3. <strong><code>release</code> 分支</strong></h4>
<p>release 分支基于 develop 分支创建，创建后，我们可以在这个 release 分支上进行测试，修复 Bug 等工作。同时，其它开发人员可以基于它开发新的 feature (记住：一旦创建了 release 分支之后不要从 develop 分支上合并新的改动到 release 分支)。</p>
<p>发布 release 分支时，合并 release 到 master 和 develop， 同时在 master 分支上打个 Tag 记住 release 版本号，然后可以删除 release 分支了。</p>
<h4 id="24-hotfix-分支">2.4. <code>hotfix</code> 分支</h4>
<p>当出现线上 bug 时，也意味着 master 存在 Bug。这时，我们需要基于 master 创建一个 hotfix 分支，在此分支上完成 bug 修复。修复后，我们应该将此分支合并回 master 和 develop 分支，同时在 master 上打一个 tag。所以，hotfix 的改动会进入下一个 release。</p>
<center>

<div class="box" style="max-width:50%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/hotfix.png" />
    </div>
    <a href="./hotfix.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<h4 id="25-如何应用-git-flow">2.5. 如何应用 Git Flow</h4>
<p>在实际开发中，如何具体落地 Git Flow 流程呢？</p>
<p>git 提供了 <code>git flow</code> 命令来手动管理，但是比较麻烦，所以还是建议使用 Git Flow 的 GUI 工具。比如：<a href="https://www.sourcetreeapp.com/">SourceTree</a>、<a href="https://marketplace.visualstudio.com/items?itemName=vs-publisher-57624.GitFlowforVisualStudio">VScode 的 GitFlow 插件</a>、Intellij 的 GitFlow 插件等。</p>
<blockquote>
<p>想了解更详细的 Git Flow 介绍，可以参考：</p>
<p><a href="http://nvie.com/posts/a-successful-git-branching-model/">A Successful Git Branching Model</a></p>
<p><a href="http://www.cnblogs.com/cnblogsfans/p/5075073.html">Git 在团队中的最佳实践&ndash;如何正确使用 Git Flow</a></p>
</blockquote>
<h3 id="github-flow">Github Flow</h3>
<p>对于简单且迭代频繁的项目来说，Git Flow 可能有些太复杂了。这时，可以考虑 Github Flow。</p>
<p>在 Github Flow 策略中，所有分支都是基于 master 创建。在 Feature 或 Bugfix 分支中完成工作后，将其合入 master，然后继续迭代。</p>
<center>

<div class="box" style="max-width:100%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/github-flow.png" />
    </div>
    <a href="./github-flow.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<blockquote>
<p>想了解更详细的 Github Flow 介绍，可以参考：<a href="http://scottchacon.com/2011/08/31/github-flow.html">GitHub Flow</a></p>
</blockquote>
<h2 id="git-commit-规范">Git Commit 规范</h2>
<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。</p>
<p>好的 Commit message 可以让人一眼就明白提交者修改了什么内容，有什么影响；而不好的 Commit message 写了和没写一样，甚至还可能误导别人。</p>
<p>先来看下图中不好的 Commit message 范例，从提交信息完全看不出来修改了什么。</p>
<center>

<div class="box" style="max-width:50%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/bad-commit.png" />
    </div>
    <a href="./bad-commit.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<p>再来一张较好的 Commit message 范例，每次提交的是什么内容，做了什么一目了然。</p>
<center>

<div class="box" style="max-width:100%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/good-commit.png" />
    </div>
    <a href="./good-commit.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<h3 id="commit-message-的作用">Commit message 的作用</h3>
<p>从前面，我们不难看出，完善的 Commit message 非常有利于项目维护。即时是个人维护的项目，时间久了，可能也会忘记当初自己改了什么。</p>
<p>Commit message 的作用还不仅仅是理解历史信息，它的主要作用如下：</p>
<p>（1）提供易于理解的历史信息，方便检索</p>
<p>（2）可以过滤某些 commit（比如文档改动），便于快速查找信息。</p>
<p>（3）可以直接从 commit 生成 Change log。</p>
<h3 id="commit-message-的规范">Commit message 的规范</h3>
<p>开源社区有很多 Commit message 的规范，个人推荐使用 <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular Git Commit 规范</a>，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p>
<p>它主要有以下组成部分：</p>
<ul>
<li>标题行：必填, 描述主要修改类型和内容</li>
<li>主题内容：描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li>
<li>页脚注释：放 Breaking Changes 或 Closed Issues</li>
</ul>
<p>常用的修改项</p>
<ul>
<li><code>type</code>：commit 的类型</li>
<li><code>feat</code>：新特性</li>
<li><code>fix</code>：修改问题</li>
<li><code>refactor</code>：代码重构</li>
<li><code>docs</code>：文档修改</li>
<li><code>style</code>：代码格式修改, 注意不是 css 修改</li>
<li><code>test</code>：测试用例修改</li>
<li><code>chore</code>：其他修改, 比如构建流程, 依赖管理.</li>
<li><code>scope</code>：commit 影响的范围, 比如：route, component, utils, build&hellip;</li>
<li><code>subject</code>：commit 的概述</li>
<li><code>body</code>：commit 具体修改内容, 可以分为多行</li>
<li><code>footer</code>：一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接</li>
</ul>
<h3 id="生成-change-log">生成 Change log</h3>
<p>如果你的所有 Commit 都符合 <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular Git Commit 规范</a>，那么发布新版本时，就可以用脚本自动生成 Change log。</p>
<p>生成的文档包括以下三个部分。</p>
<ul>
<li>New features</li>
<li>Bug fixes</li>
<li>Breaking changes.</li>
</ul>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>
<p><a href="https://github.com/ajoslin/conventional-changelog">conventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ npm install -g conventional-changelog
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> my-project
</span></span><span class="line"><span class="cl">$ conventional-changelog -p angular -i CHANGELOG.md -w
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面命令不会覆盖以前的 Change log，只会在<code>CHANGELOG.md</code>的头部加上自从上次发布以来的变动。</p>
<p>如果你想生成所有发布的 Change log，要改为运行下面的命令。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ conventional-changelog -p angular -i CHANGELOG.md -w -r <span class="m">0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了方便使用，可以将其写入<code>package.json</code>的<code>scripts</code>字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;scripts&#34;</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;changelog&#34;</span><span class="o">:</span> <span class="s2">&#34;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以后，直接运行下面的命令即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ npm run changelog
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="git-奇技淫巧">Git 奇技淫巧</h2>
<h3 id="生成-ssh-公钥">生成 SSH 公钥</h3>
<p>许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 <code>~/.ssh</code> 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nb">cd</span> ~/.ssh
</span></span><span class="line"><span class="cl">$ ls
</span></span><span class="line"><span class="cl">authorized_keys2  id_dsa       known_hosts
</span></span><span class="line"><span class="cl">config            id_dsa.pub
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们需要寻找一对以 <code>id_dsa</code> 或 <code>id_rsa</code> 命名的文件，其中一个带有 <code>.pub</code> 扩展名。 <code>.pub</code> 文件是你的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 <code>.ssh</code> 目录），你可以通过运行 <code>ssh-keygen</code> 程序来创建它们。在 Linux/Mac 系统中，<code>ssh-keygen</code> 随 SSH 软件包提供；在 Windows 上，该程序包含于 MSysGit 软件包中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ ssh-keygen
</span></span><span class="line"><span class="cl">Generating public/private rsa key pair.
</span></span><span class="line"><span class="cl">Enter file in which to save the key <span class="o">(</span>/home/schacon/.ssh/id_rsa<span class="o">)</span>:
</span></span><span class="line"><span class="cl">Created directory <span class="s1">&#39;/home/schacon/.ssh&#39;</span>.
</span></span><span class="line"><span class="cl">Enter passphrase <span class="o">(</span>empty <span class="k">for</span> no passphrase<span class="o">)</span>:
</span></span><span class="line"><span class="cl">Enter same passphrase again:
</span></span><span class="line"><span class="cl">Your identification has been saved in /home/schacon/.ssh/id_rsa.
</span></span><span class="line"><span class="cl">Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.
</span></span><span class="line"><span class="cl">The key fingerprint is:
</span></span><span class="line"><span class="cl">d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先 <code>ssh-keygen</code> 会确认密钥的存储位置（默认是 <code>.ssh/id_rsa</code>），然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。</p>
<p>现在，进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员（假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 <code>.pub</code> 文件内容，并将其通过邮件发送。 公钥看起来是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ cat ~/.ssh/id_rsa.pub
</span></span><span class="line"><span class="cl">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
</span></span><span class="line"><span class="cl">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
</span></span><span class="line"><span class="cl">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
</span></span><span class="line"><span class="cl">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
</span></span><span class="line"><span class="cl">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
</span></span><span class="line"><span class="cl">NrRFi9wrf+M7Q<span class="o">==</span> schacon@mylaptop.local
</span></span></code></pre></td></tr></table>
</div>
</div><p>在你的 Github 账户中，依次点击 <strong>Settings</strong> &gt; <strong>SSH and GPG keys</strong> &gt; <strong>New SSH key</strong></p>
<p>然后，将上面生成的公钥内容粘贴到 <code>Key</code> 编辑框并保存。至此大功告成。</p>
<p>后面，你在克隆你的 Github 项目时使用 SSH 方式即可。</p>
<p>如果觉得我的讲解还不够细致，可以参考：<a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/">adding-a-new-ssh-key-to-your-github-account</a></p>
<h3 id="使用-gitignore-忽略不必提交内容">使用 .gitignore 忽略不必提交内容</h3>
<p><code>.gitignore</code> 文件可能从字面含义也不难猜出：这个文件里配置的文件或目录，会自动被 git 所忽略，不纳入版本控制。</p>
<p>在日常开发中，我们的项目经常会产生一些临时文件，如编译 Java 产生的 <code>*.class</code> 文件，又或是 IDE 自动生成的隐藏目录（Intellij 的 <code>.idea</code> 目录、Eclipse 的 <code>.settings</code> 目录等）等等。这些文件或目录实在没必要纳入版本管理。在这种场景下，你就需要用到 <code>.gitignore</code> 配置来过滤这些文件或目录。</p>
<p><code>.gitignore</code> 配置的规则很简单，也没什么可说的，看几个例子，自然就明白了。</p>
<p>【示例】一份 Java 的 .gitignore</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># Compiled class file
</span></span><span class="line"><span class="cl">*.class
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Log file
</span></span><span class="line"><span class="cl">*.log
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># BlueJ files
</span></span><span class="line"><span class="cl">*.ctxt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Mobile Tools for Java (J2ME)
</span></span><span class="line"><span class="cl">.mtj.tmp/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Package Files #
</span></span><span class="line"><span class="cl">*.jar
</span></span><span class="line"><span class="cl">*.war
</span></span><span class="line"><span class="cl">*.nar
</span></span><span class="line"><span class="cl">*.ear
</span></span><span class="line"><span class="cl">*.zip
</span></span><span class="line"><span class="cl">*.tar.gz
</span></span><span class="line"><span class="cl">*.rar
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
</span></span><span class="line"><span class="cl">hs_err_pid*
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>【推荐】这里推荐一个 Github 的开源项目：<a href="https://github.com/github/gitignore">gitignore</a>，在这里，你可以找到很多常用的 .gitignore 模板，如：Java、Nodejs、C++ 的 <code>.gitignore</code> 模板等等。</p>
</blockquote>
<h3 id="使用-gitattributes-解决-lf-和-crlf-问题">使用 .gitattributes 解决 LF 和 CRLF 问题</h3>
<p>你有没有在和多人协同开发时遇到过以下烦恼？</p>
<p>开发者们分别使用不同的操作系统进行开发，有的人用 Windows，有的人用 Linux/MacOS。众所周知，不同操作系统默认的文件结尾行是不同的：在 Windows 上默认的是回车换行（Carriage Return Line Feed, CRLF），然而，在 Linux/MacOS 上则是换行（Line Feed, LF）。这就可能导致这种情况：明明文件内容一模一样，但是版本比对时仍然存在版本差异。</p>
<p>那么如何解决这个问题呢？Git 提供了 <code>.gitattributes</code> 配置文件，它允许使用者指定由 git 使用的文件和路径的属性。</p>
<p>在 Git 库中，一个普通文本文件的行尾默认是 <code>LF</code>。对于工作目录，除了 <code>text</code> 属性之外，还可以设置 <code>eol</code> 属性或 <code>core.eol</code> 配置变量。</p>
<p><code>.gitattributes</code> 文件中，可以用 text 属性指定某类文件或目录下的文件，控制它的行结束标准化。当一个文本文件被标准化时，它的行尾将在存储库中转换为 <code>LF</code>。要控制工作目录中使用的行结束风格，请使用单个文件的<code>eol</code>属性和所有文本文件的 <code>core.eol</code> 配置变量。</p>
<p>【示例】一份 .gitattributes 示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">* text=auto eol=lf
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">*.txt text
</span></span><span class="line"><span class="cl">*.java text
</span></span><span class="line"><span class="cl">*.scala text
</span></span><span class="line"><span class="cl">*.groovy text
</span></span><span class="line"><span class="cl">*.gradle text
</span></span><span class="line"><span class="cl">*.properties text
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># unix style
</span></span><span class="line"><span class="cl">*.sh text eol=lf
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># win style
</span></span><span class="line"><span class="cl">*.bat text eol=crlf
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># binary
</span></span><span class="line"><span class="cl">*.jar binary
</span></span><span class="line"><span class="cl">*.war binary
</span></span><span class="line"><span class="cl">*.zip binary
</span></span><span class="line"><span class="cl">*.tar binary
</span></span><span class="line"><span class="cl">*.tar.gz binary
</span></span><span class="line"><span class="cl">*.gz binary
</span></span><span class="line"><span class="cl">*.apk binary
</span></span><span class="line"><span class="cl">*.bin binary
</span></span><span class="line"><span class="cl">*.exe binary
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>【推荐】这里推荐一个 Github 的开源项目：<a href="https://github.com/alexkaratarakis/gitattributes">gitignore</a>，在这里，你可以找到很多常用的 .gitignore 模板，如：Java、Nodejs、C++ 的 <code>.gitignore</code> 模板等等。</p>
</blockquote>
<h3 id="同时提交代码到不同的远程仓库">同时提交代码到不同的远程仓库</h3>
<p>如果，你在不同的 Git 远程仓库中维护同一个项目，你可能会有这样的需求：能不能一次提交，同时 push 到多个远程仓库中呢？</p>
<p>这个可以有，解决方案如下：</p>
<p>比如，我有一个 blog 项目，同时维护在 Github 和 Gitee 上。</p>
<p>（1）首先，在 Github 和 Gitee 上配置本地的 ssh 公钥（如果是 Gitlab，也同样如此），这样中央仓库就能识别本地。</p>
<p>生成 SSH 公钥的方法，请参考上文的 “生成 SSH 公钥” 章节。</p>
<p>（2）进入 git 项目的隐藏目录 <code>.git</code>，打开 config 文件，参考下面配置进行编辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ini" data-lang="ini"><span class="line"><span class="cl"><span class="k">[core]</span>
</span></span><span class="line"><span class="cl">	<span class="na">repositoryformatversion</span> <span class="o">=</span> <span class="s">0
</span></span></span><span class="line"><span class="cl"><span class="s">	filemode = false
</span></span></span><span class="line"><span class="cl"><span class="s">	bare = false
</span></span></span><span class="line"><span class="cl"><span class="s">	logallrefupdates = true
</span></span></span><span class="line"><span class="cl"><span class="s">	symlinks = false
</span></span></span><span class="line"><span class="cl"><span class="s">	ignorecase = true</span>
</span></span><span class="line"><span class="cl"><span class="k">[remote &#34;origin&#34;]</span>
</span></span><span class="line"><span class="cl">	<span class="na">url</span> <span class="o">=</span> <span class="s">git@github.com:dunwu/blog.git
</span></span></span><span class="line"><span class="cl"><span class="s">	url = git@gitee.com:turnon/blog.git
</span></span></span><span class="line"><span class="cl"><span class="s">	fetch = +refs/heads/*:refs/remotes/origin/*</span>
</span></span><span class="line"><span class="cl"><span class="k">[branch &#34;master&#34;]</span>
</span></span><span class="line"><span class="cl">	<span class="na">remote</span> <span class="o">=</span> <span class="s">origin
</span></span></span><span class="line"><span class="cl"><span class="s">	merge = refs/heads/master</span>
</span></span><span class="line"><span class="cl"><span class="k">[user]</span>
</span></span><span class="line"><span class="cl">	<span class="na">name</span> <span class="o">=</span> <span class="s">dunwu
</span></span></span><span class="line"><span class="cl"><span class="s">	email = forbreak@163.com</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>重点在于 <code>remote &quot;origin&quot;</code>，同时配置了两个 url。配置后，一旦触发 push 远程仓库的动作，就会同时推送提交记录到配置的远程仓库。</p>
<h3 id="github-issue-和-gitlab-issue">Github Issue 和 Gitlab Issue</h3>
<p>开发软件，Bug 再所难免，出现问题不可怕，可怕的是放任不管；所以，优秀的软件项目，都应该管理好问题追踪。软件的使用者，在使用中，可能会遇到形形色色的问题，难以解决，需要向维护者寻求帮助。</p>
<p>问题追踪如此重要，所以各种代码托管平台都会提供 Issue 维护机制，如 Github Issue 和 Gitlab Issue。</p>
<p>如果一个项目的开源社区很活跃，在没有任何约束的前提下，提问肯定是五花八门的，让维护者难以招架。</p>
<p>其实，提问也是一门艺术，如果提问者的问题长篇大幅，言不达意，让别人难以理解，就很难得到有效帮助。关于如何高效的提问，推荐参考 <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way">提问的智慧</a> 这篇文章，作者整理的非常好。</p>
<p>作为开发者，你不能期望所有提问者都是训练有素的提问者。所以，使用规范化的 Issue 模板来引导提问者提问，可以大大减轻开发者的负担。</p>
<h4 id="github-issue-模板">Github Issue 模板</h4>
<p>如何在 Github Issue 平台上创建 Issue 模板呢？方法如下：</p>
<p>（1）在仓库根目录创建新目录 <code>.github</code></p>
<p>（2）在 <code>.github</code> 目录中添加 <code>ISSUE_TEMPLATE</code> 目录，在其中添加的 md 文件都会被 Github 自动识，并将其作为 issue 的默认模板。</p>
<p>示例，下面是携程 <a href="https://github.com/ctripcorp/apollo">apollo</a> 的一个 Issue 模板，要求提问者填充 bug 描述、复现步骤、期望、截图、日志等细节。</p>
<center>

<div class="box" style="max-width:100%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/xiecheng-issue.png" />
    </div>
    <a href="./xiecheng-issue.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<blockquote>
<p>更多模板：<a href="https://github.com/stevemao/github-issue-templates">Github issue_templates 模板</a></p>
</blockquote>
<h4 id="gitlab-issue-模板">Gitlab Issue 模板</h4>
<p>如何在 Gitlab Issue 平台上创建 Issue 模板呢？方法如下：</p>
<p>（1）在仓库根目录创建新目录 <code>.gitlab</code></p>
<p>（2）在 <code>.gitlab</code> 目录中添加 <code>issue_templates</code> 目录，在其中添加的 md 文件都会被 Gitlab 自动识，并将其作为 issue 的默认模板。</p>
<center>

<div class="box" style="max-width:100%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/gitlab-issue.png" />
    </div>
    <a href="./gitlab-issue.png" itemprop="contentUrl"></a>
  </figure>
</div>
</center>
<blockquote>
<p>更多模板：<a href="https://gitlab.com/gitlab-org/gitlab/-/tree/master/.gitlab/issue_templates">Gitlab 官方 issue_templates 模板</a></p>
</blockquote>
<h3 id="git-hook">Git Hook</h3>
<p>在执行提交代码（git commit），推送代码（git push）等行为时，我们可能希望做一些代码检查性工作，例如：代码 lint 检查、代码格式化等。当检查发现代码存在问题时，就拒绝代码提交，从而保证项目质量。</p>
<p>Git 提供了 Git Hook 机制，允许使用者在特定的重要动作发生时触发自定义脚本。有两类钩子：客户端钩子和服务器端钩子。客户端钩子由诸如提交和合并等操作所触发调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。钩子都被存储在 Git 项目目录下的 <code>.git/hooks</code> 子目录中。Git 在这个目录下放置了一些示例，这些示例的名字都是以 <code>.sample</code> 结尾，如果想启用它们，得先移除这个后缀。</p>
<p>常用的客户端钩子：</p>
<ul>
<li><code>pre-commit</code> 钩子：在提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 <code>git commit --no-verify</code> 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 <code>lint</code> 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</li>
<li><code>prepare-commit-msg</code> 钩子：在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验。 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。</li>
<li><code>commit-msg</code> 钩子：接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</li>
<li><code>post-commit</code> 钩子：在整个提交过程完成后运行。它不接收任何参数，但你可以很容易地通过运行 <code>git log -1 HEAD</code> 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情。</li>
<li><code>pre-push</code> 钩子：会在 <code>git push</code> 运行期间， 更新了远程引用但尚未传送对象时被调用。 它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。 你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。</li>
</ul>
<h4 id="javascript-应用-git-hook">Javascript 应用 Git Hook</h4>
<p>想在 JavaScript 应用中使用 Git Hook，推荐使用 <a href="https://github.com/typicode/husky">husky</a> ，可以很方便的编写钩子处理命令。</p>
<p>使用方法很简单，先安装 husky</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">npm i -D husky
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，在 package.json 中添加配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="s2">&#34;husky&#34;</span><span class="err">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;hooks&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;pre-commit&#34;</span><span class="p">:</span> <span class="s2">&#34;lint-staged&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="err">,</span>
</span></span><span class="line"><span class="cl"><span class="s2">&#34;lint-staged&#34;</span><span class="err">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;src/**/*.{js,vue}&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;eslint --fix&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;git add&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="err">,</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上配置的作用是，当提交代码前（ <code>pre-commit</code> ），先执行 <code>lint-staged</code>；</p>
<p><code>lint-staged</code> 中执行的动作是，对 src 目录的所有 js、vue 文件进行 eslint 检查，并尝试修复。如果修复后没有问题，就 git add 添加修改后的文件；如果修复失败，则拒绝提交代码。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><strong>官方资源</strong>
<ul>
<li><a href="https://git-scm.com/">Git 官网</a></li>
<li><a href="https://github.com/git/git">Git Github</a></li>
<li><a href="https://guides.github.com/">Github 官方教程</a></li>
</ul>
</li>
<li><strong>模板</strong>
<ul>
<li><a href="https://github.com/github/gitignore">gitignore 模板</a> - .gitignore 文件模板</li>
<li><a href="https://github.com/alexkaratarakis/gitattributes">gitattributes 模板</a> - .gitattributes 文件模板</li>
<li><a href="https://github.com/tiimgreen/github-cheat-sheet">github-cheat-sheet</a> - git 命令简略图表</li>
</ul>
</li>
<li><strong>Git 教程</strong>
<ul>
<li><a href="https://learngitbranching.js.org/">Learn Git branching</a> - 交互式教程</li>
<li><a href="https://git-scm.com/book/zh/v2">Git 官方推荐教程</a> - Scott Chacon 的 Git 书。
<ul>
<li><a href="https://github.com/k88hudson/git-flight-rules">git-flight-rules</a></li>
</ul>
</li>
<li><a href="https://github.com/521xueweihan/git-tips">git-tips</a></li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes">Git 中文教程</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的 Git 教程</a></li>
<li><a href="https://github.com/xirong/my-git">有关 git 的学习资源</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md">Git Cookbook</a></li>
<li><a href="https://github.com/521xueweihan/git-tips">Git 奇技淫巧</a></li>
<li><a href="https://github.com/aseaday/git-style-guide">Git 风格指南</a></li>
<li><a href="http://www.cnblogs.com/cnblogsfans/p/5075073.html">Git 在团队中的最佳实践&ndash;如何正确使用 Git Flow</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></li>
</ul>
</li>
<li><strong>Git 工具</strong>
<ul>
<li><a href="https://git-scm.com/downloads/guis">guis</a> - Git 官网展示的客户端工具列表。</li>
<li><a href="https://github.com/gogits/gogs">gogs</a> - 极易搭建的自助 Git 服务。</li>
<li><a href="https://github.com/nvie/gitflow">gitflow</a> - 应用 <a href="http://nvie.com/posts/a-successful-git-branching-model/">fit-flow</a> 模型的工具。</li>
<li><a href="http://firstaidgit.io/">firstaidgit.io</a> 一个可搜索的最常被问到的 Git 的问题</li>
<li><a href="https://github.com/unixorn/git-extra-commands">git-extra-commands</a> - 一堆有用的额外的 Git 脚本</li>
<li><a href="https://github.com/tj/git-extras">git-extras</a> - GIT 工具集 &ndash; repo summary, repl, changelog population, author commit percentages and more</li>
<li><a href="https://github.com/qw3rtman/git-fire">git-fire</a> - git-fire 是一个 Git 插件，用于帮助在紧急情况下添加所有当前文件, 做提交(committing), 和推(push)到一个新分支(阻止合并冲突)。</li>
<li><a href="https://github.com/git-tips/tips">git-tips</a> - Git 小提示</li>
<li><a href="https://github.com/Originate/git-town">git-town</a> - 通用，高级 Git 工作流支持！</li>
</ul>
</li>
<li><strong>GUI 客户端</strong>
<ul>
<li><a href="https://www.gitkraken.com/">GitKraken</a> - 豪华的 Git 客户端 Windows, Mac &amp; Linux</li>
<li><a href="https://git-cola.github.io/">git-cola</a> - 另外一个 Git 客户端 Windows &amp; OS X</li>
<li><a href="https://github.com/git-up/GitUp">GitUp</a> - 一个新的 Git 客户端，在处理 Git 的复杂性上有自己的特点</li>
<li><a href="https://rowanj.github.io/gitx/">gitx-dev</a> - 图形化的 Git 客户端 OS X</li>
<li><a href="https://www.sourcetreeapp.com/">Source Tree</a> - 免费的图形化 Git 客户端 Windows &amp; OS X</li>
<li><a href="http://www.git-tower.com/">Tower</a> - 图形化 Git 客户端 OS X(付费)</li>
</ul>
</li>
<li><strong>git cheat sheet</strong>
<ul>
<li><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf">github-git-cheat-sheet</a></li>
</ul>
</li>
</ul>


                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/posts/tech/architecture/git/git-tutorial/" data-toggle="tooltip" data-placement="top" title="Git Tutorial">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                </ul>
                

                



            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    
                    
                    
                    

		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; Waiting For You 2023
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>






<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body>
</html>
