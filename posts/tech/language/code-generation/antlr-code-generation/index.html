<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="Waiting For You">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://WFUing.github.io//">
    <meta property="twitter:image" content="https://WFUing.github.io//" />
    

    
    <meta name="title" content="Antlr Code Generation" />
    <meta property="og:title" content="Antlr Code Generation" />
    <meta property="twitter:title" content="Antlr Code Generation" />
    

    
    <meta name="description" content="这是一个纯粹的博客......">
    <meta property="og:description" content="这是一个纯粹的博客......" />
    <meta property="twitter:description" content="这是一个纯粹的博客......" />
    

    
    <meta property="twitter:card" content="ANTLR 是 **AN**other **T**ool for **L**anguage **R**ecognition 的缩写，是一个功能强大的解析器生成器框架，用于从语法文件中构建语言识别器、编译器和翻译器，语法文件中包含从源语言到目标语言的每个语句所要执行的操作。" />
    
    

    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Antlr Code Generation | </title>

    <link rel="canonical" href="/posts/tech/language/code-generation/antlr-code-generation/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link rel="stylesheet" href="/css/font-awesome.all.min.css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="/js/lazysizes.min.js"></script>

    
    

</head>






<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Waiting For You</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                    
                    
		    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/code-generation" title="code generation">
                            code generation
                        </a>
                        
                        <a class="tag" href="/tags/dsl" title="dsl">
                            dsl
                        </a>
                        
                        <a class="tag" href="/tags/antlr" title="antlr">
                            antlr
                        </a>
                        
                    </div>
                    <h1>Antlr Code Generation</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                    Waiting For You
                             
                            on 
                            Sunday, October 15, 2023
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h2 id="简介">简介</h2>
<p>ANTLR 是 <strong>AN</strong>other <strong>T</strong>ool for <strong>L</strong>anguage <strong>R</strong>ecognition 的缩写，是一个功能强大的解析器生成器框架，用于从语法文件中构建语言识别器、编译器和翻译器，语法文件中包含从源语言到目标语言的每个语句所要执行的操作。</p>
<p>使用编译器设计的概念来定义每种现代编程语言的写作风格。这是一套典型的步骤，首先是 Lexical, Syntactical 和 Semantic Analysis，确定语言的基本编写方式，以便识别。接下来是一系列非常有趣的步骤：中间代码生成、优化和目标代码生成。</p>
<p>目前的版本为 4.7，它提供了一种方便的、对开发人员友好的方式来定义自己的规则集（又称语法），它由一系列标记和操作组成，这些标记和操作定义了语句在源语言中的书写方式，从而可以正确识别和解析语句。更有趣的是，它还能让用户对代码进行操作，并将其生成目标代码，所有这一切都可以用您选择的语言来实现。</p>
<p>那么，谁在使用 ANTLR 呢？</p>
<ul>
<li>编程语言：Boo、Groovy、Mantra、Nemerle、XRuby 等。</li>
<li>其他工具、框架：Apache Spark、Hibernate、Intellij IDEA、Jazillian、JBoss Rules、Keynote(Apple)、WebLogic（Oracle）等。</li>
</ul>
<h2 id="the-basics">The Basics</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>考虑到上面 Python 的例子，这些编译器设计步骤从识别 Python 中编写的每条语句（源代码）的基本单元开始，并将其分解为 a stream of tokens，每个标记都被识别或映射为特定类型，也就是 Lexical Analysis。</p>
<center>
<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" style="max-width:55%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/lexical-analysis.webp" />
    </div>
    <a href="./lexical-analysis.webp" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>Lexical Analysis of the python function yielding a stream of tokens</h4>
      </figcaption>
  </figure>
</div>
</center>
<p>然后，根据这些标记出现的顺序来确定书面语句的上下文，并通过语义分析构建一棵树（或 <strong>A</strong>bstract <strong>S</strong>yntax <strong>T</strong>ree）来检查其正确性，同时提供使用现有树遍历方法之一进行遍历的能力。</p>
<center>

<div class="box" style="max-width:100%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/syntax-tree.webp" />
    </div>
    <a href="./syntax-tree.webp" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>Syntax tree after Semantic analysis</h4>
      </figcaption>
  </figure>
</div>
</center>
<h3 id="tldr-概念">TLDR 概念</h3>
<ul>
<li><strong>Lexer</strong> : converts a stream of characters to a stream of tokens.</li>
<li><strong>Parser</strong> : processes of tokens, possibly creating AST.</li>
<li><strong>Abstract Syntax Tree(AST)</strong>: an intermediate tree representation of the parsed input that is simpler to process than the stream of tokens.</li>
<li><strong>Tree Parser</strong>: It processes an AST.</li>
<li><strong>String Template</strong>: a library that supports using templates with placeholders for outputting text (something very specific to ANTLR).</li>
</ul>
<p>ANTLR 是一种 <strong>LL parser</strong>（Left-to-right, Leftmost derivation），是一种自顶向下的剖析器，适用于无上下文语言的子集。它从左到右解析输入，对句子进行 Leftmost derivation。它简化了许多步骤，使创建语言识别器和解析器变得更容易、更方便。</p>
<center>

<div class="box" style="max-width:60%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/paser-process.webp" />
    </div>
    <a href="./paser-process.webp" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>Syntax tree after Semantic analysis</h4>
      </figcaption>
  </figure>
</div>
</center>
<h3 id="example1">Example1</h3>
<p>下面是我为解析 python 函数而编写的解析器的一个快速示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">grammar PythonParserExample;
</span></span><span class="line"><span class="cl">tokens { INDENT, DEDENT, LINE_BREAK }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">statement
</span></span><span class="line"><span class="cl">    : (single_input)? EOF
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">single_input
</span></span><span class="line"><span class="cl">    : LINE_BREAK
</span></span><span class="line"><span class="cl">    | simple_stmt
</span></span><span class="line"><span class="cl">    | complex_stmt (LINE_BREAK)? EOF
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">complex_stmt: funcdef;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">simple_stmt
</span></span><span class="line"><span class="cl">    : small_stmt (SEMI_COLON small_stmt)* SEMI_COLON? (LINE_BREAK)? EOF
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">stmt
</span></span><span class="line"><span class="cl">    : simple_stmt
</span></span><span class="line"><span class="cl">    | complex_stmt
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">funcdef
</span></span><span class="line"><span class="cl">    : ASYNC? DEF name OPEN_PAREN typedargslist? CLOSE_PAREN (ARROW name)? COLON &#39;\n&#39;? funcbody
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">typedargslist
</span></span><span class="line"><span class="cl">    : (def_parameters COMMA)? (args (COMMA def_parameters)? ) COMMA?
</span></span><span class="line"><span class="cl">    | def_parameters COMMA?
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">funcbody
</span></span><span class="line"><span class="cl">    : simple_stmt
</span></span><span class="line"><span class="cl">    | LINE_BREAK INDENT stmt+ DEDENT
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">args
</span></span><span class="line"><span class="cl">     : STAR name
</span></span><span class="line"><span class="cl">     ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def_parameters
</span></span><span class="line"><span class="cl">    : def_parameter (COMMA def_parameter)*
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">small_stmt
</span></span><span class="line"><span class="cl">    : RETURN expression                                                                #return_stmt
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def_parameter
</span></span><span class="line"><span class="cl">    : name
</span></span><span class="line"><span class="cl">    | STAR
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">expression: 
</span></span><span class="line"><span class="cl">    name op=OPERATOR name
</span></span><span class="line"><span class="cl">    ;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">name: NAME;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">DEF : D E F;
</span></span><span class="line"><span class="cl">SEMI_COLON : &#39;;&#39;;
</span></span><span class="line"><span class="cl">STAR : &#39;*&#39;;
</span></span><span class="line"><span class="cl">OPERATOR : STAR|&#39;+&#39;|&#39;/&#39;|&#39;**&#39;|&#39;-&#39;;
</span></span><span class="line"><span class="cl">RETURN : R E T U R N;
</span></span><span class="line"><span class="cl">ASYNC : A S Y N C;
</span></span><span class="line"><span class="cl">COMMA : &#39;,&#39;;
</span></span><span class="line"><span class="cl">OPEN_PAREN : &#39;(&#39;;
</span></span><span class="line"><span class="cl">CLOSE_PAREN : &#39;)&#39;;
</span></span><span class="line"><span class="cl">ARROW : &#39;-&gt;&#39;;
</span></span><span class="line"><span class="cl">COLON : &#39;:&#39;;
</span></span><span class="line"><span class="cl">NAME               : ID_START ID_CONTINUE*;
</span></span><span class="line"><span class="cl">WS                 : [ \t]+            {HandleSpaces();}   -&gt; channel(HIDDEN);
</span></span></code></pre></td></tr></table>
</div>
</div><p>它的一个主要优点是，用户可以使用相同的 syntax 进行 lexing 和 parsing。然而，在语法层面上，这里的区别在于命名约定:</p>
<ul>
<li>以大写字母开头的规则是 lexer rules</li>
<li>其他的都是 parse rules</li>
</ul>
<center>

<div class="box" style="max-width:100%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/intellij-idea-plugin.webp" />
    </div>
    <a href="./intellij-idea-plugin.webp" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>ANTLR plugin (on Intellij IDEA) output for the above python function parsing</h4>
      </figcaption>
  </figure>
</div>
</center>
<p>一旦定义完毕，<a href="https://www.antlr.org/download/antlr-4.8-complete.jar">complete ANLTR jar</a> 文件就会提供一个选项，将其生成一组文件，并使用您喜欢的编程语言代码，也就是一个 parser。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">java -Xmx500M -cp &lt;path to ANTLR <span class="nb">complete</span> JAR&gt; org.antlr.v4.Tool -Dlanguage<span class="o">=</span>&lt;target_language&gt; PythonParserExample.g4
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于我使用 Python3 作为生成解析器的目标，ANTLR 的配置会生成 3 个 python 文件，这些文件可以作为代码翻译过程的一部分，用于将一种语言的源代码转换为另一种语言。</p>
<center>

<div class="box" style="max-width:40%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/output-files.webp" />
    </div>
    <a href="./output-files.webp" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>ANTLR plugin (on Intellij IDEA) output for the above python function parsing</h4>
      </figcaption>
  </figure>
</div>
</center>
<h2 id="setting-up-an-antlr-project">Setting up an ANTLR Project</h2>
<h3 id="antlr-plugin-for-vscode">ANTLR plugin for VSCode</h3>
<p>这里使用的设置将是在 VSCode 上创建的 Java-Maven 项目。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=mike-lischke.vscode-antlr4">ANTLR plugin for VSCode</a> 提供了各种选项（甚至比 Intellij 还多）来调试语法文件，并创建了美观的 parse trees，以便轻松调试用户输入语句的特定配置。</p>
<center>

<div class="box" style="max-width:100%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/vscode-plugin.gif" />
    </div>
    <a href="./vscode-plugin.gif" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>ANTLR plugin (on Intellij IDEA) output for the above python function parsing</h4>
      </figcaption>
  </figure>
</div>
</center>
<p>要生成这些可视化效果，需要使用 vscode 的 ANTLR 启动配置在调试模式下运行语法文件，并为语法指定输入文件。下面是 VS Code 上 ANTLR 的 launch.json 配置文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Debug ANTLR4 grammar&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;antlr-debug&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nt">&#34;request&#34;</span><span class="p">:</span> <span class="s2">&#34;launch&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nt">&#34;input&#34;</span><span class="p">:</span> <span class="s2">&#34;input.txt&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nt">&#34;grammar&#34;</span><span class="p">:</span> <span class="s2">&#34;BooleanExprParser.g4&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nt">&#34;startRule&#34;</span><span class="p">:</span> <span class="s2">&#34;parse&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nt">&#34;printParseTree&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="nt">&#34;visualParseTree&#34;</span><span class="p">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="grammar">Grammar</h3>
<p>让我们先为解析器创建一个基本语法或 BooleanExpr.g4 文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">grammar</span> <span class="nx">BooleanExpr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="nx">header</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">antlrsource</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意 parser file 是如何以 <code>grammar BooleanExpr;</code> 开始的。这可以通过将 Lexer tokens (大写字母表示) 和 parser tokens (所有其他标记) 保存在两个不同的文件中来分解：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">lexer</span> <span class="nx">grammar</span> <span class="nx">BooleanExprLexer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="nx">header</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">antlrsource</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">parser</span> <span class="nx">grammar</span> <span class="nx">BooleanExprParser</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="nx">header</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">antlrsource</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个用于 parser，另一个用于 lexer，这样更便于维护。接下来，我们先定义一个头文件和软件包名称，放在生成的解析器类的开头。这将允许我们指定一个包，以便在 Java 代码中导入。</p>
<p>从 Lexer 开始，我们将 IDENTIFIER 定义为 lexer rule，并提供与之匹配的描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">IDENTIFIER
</span></span><span class="line"><span class="cl">   :   [a-zA-Z_] [a-zA-Z_0-9]*
</span></span><span class="line"><span class="cl">   ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Lexer rules 总是以大写字母开头。这些规则是 parser 的基本构件，重点是构建 parser rules 的基础。对正则表达式稍有接触的人来说，这应该有点熟悉。</p>
<p>这里，<code>A-Z</code> 表示 <code>A</code> 和 <code>Z</code> 之间的字母，而 <code>a-z</code> 表示 <code>a</code> 和 <code>z</code> 之间的字母。同样，<code>0-9</code> 表示数字 <code>0</code> 和 <code>9</code> 之间的数字。由于规则可能包含也可能不包含这些字母的多次出现，因此可以用 (<code>*</code>/<code>+</code>) 运算符作为后缀，表示这些字母出现的频率。这里，<code>*</code> 表示可能完全不出现（0 次或更多次）。这意味着，我们的 <code>IDENTIFIER</code> 规则将匹配大写字母、小写字母（总是以大写/小写字母开头）和整数字符的任意组合，但不匹配空字符。</p>
<p>一般来说，所有空白都会被词法识别器标记化。因此，您必须在解析器规则中定义空格以及所有可能使用空格的地方。不过，由于我们的源布尔表达式在某些地方不需要对空格敏感，因此我们可以编写一条词法规则来处理这个问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">WS: [ \r\t\u000C\n]+ -&gt; skip;
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意留白标记的定义是如何编写的，以识别一个或多个空格、制表符和换行符，并让 ANTLR 跳过它们。箭头（-&gt;）运算符定义了遇到标记时要执行的操作（本例中为跳过操作）。接下来是为布尔表达式定义标记，其中包括多个运算符和操作数。这包括以下标记：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">AND: A N D;
</span></span><span class="line"><span class="cl">OR: O R;
</span></span><span class="line"><span class="cl">NOT: N O T;
</span></span><span class="line"><span class="cl">TRUE: &#39;True&#39;;
</span></span><span class="line"><span class="cl">FALSE: &#39;False&#39;;
</span></span><span class="line"><span class="cl">GT: G T {setText(&#34; &gt; &#34;);};
</span></span><span class="line"><span class="cl">GE: G E {setText(&#34; &gt;= &#34;);};
</span></span><span class="line"><span class="cl">LT: L T {setText(&#34; &lt; &#34;);};
</span></span><span class="line"><span class="cl">LE: L E {setText(&#34; &lt;= &#34;);};
</span></span><span class="line"><span class="cl">EQ: E Q {setText(&#34; == &#34;);};
</span></span><span class="line"><span class="cl">LPARENTHESIS: &#39;(&#39;;
</span></span><span class="line"><span class="cl">RPARENTHESIS: &#39;)&#39;;
</span></span><span class="line"><span class="cl">DECIMAL_NUMBER: &#39;-&#39;? [0-9]+ ( &#39;.&#39; [0-9]+)?;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="embedding-actions">Embedding Actions</h3>
<p>规则 GT、GE、LT、LE 和 EQ 包含代码块，允许它们在遇到各自的标记时执行某些动作。这样就可以在语法文件中定义某些动作，但需要注意的是，只能定义简单的小动作，而不能定义复杂的代码块。</p>
<blockquote>
<p>如果我们不希望产生构建解析树的开销，我们可以在解析过程中即时计算值或打印内容。另一方面，这意味着要在表达式语法中嵌入任意代码，这就比较困难；我们必须了解这些操作对解析器的影响，以及这些操作的位置。
<a href="https://media.pragprog.com/titles/tpantlr2/listener.pdf">The Definitive ANTLR 4 Reference</a></p>
</blockquote>
<p>请注意，每条规则都由用空格隔开的字母组成。这些被称为 fragments。它们的主要目的是减少每个标记的杂乱定义，这基本上需要处理对大小写敏感的用例。这样，用户就不必为识别同一个 token 而写下所有可能的文本组合。其定义如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fragment A : [aA]; // match either an &#39;a&#39; or &#39;A&#39;
</span></span><span class="line"><span class="cl">fragment B : [bB];
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">fragment Z : [zZ];
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然大多数字母数字令牌都可以通过使用片段来创建，但其他令牌则可以通过自定义正则表达式定义或使用引号括起来的纯字符串（如 LPARENTHESIS 和 DECIMAL_NUMBER）来创建。</p>
<p>而 parser rules（所有其他规则）则以小写字母开头。这些规则的主要目的是在 DSL 中定义布尔表达式的上下文，并帮助从生成的词法标记中构建解析树或抽象语法树。</p>
<h3 id="basic-building-blocks">Basic Building Blocks</h3>
<p>让我们开始定义规则。首先，我们定义根节点（或通常所说的解析节点），它本身只能指向一条规则（此处为 basicBooleanExpression）。首先是一个返回语句，其中包含它应该返回的变量（可选，但在我们的例子中是必需的）及其返回类型。</p>
<p>这条规则指向另一条名为 basicBooleanExpression 的规则，该规则后跟有 EOF（或文件结束）字符。不包含该字符实质上意味着您正试图解析整个输入内容，而只解析部分输入内容是可以接受的，这将避免任何语法错误。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">parse
</span></span><span class="line"><span class="cl">returns[String str]
</span></span><span class="line"><span class="cl">@init {$str=&#34;&#34;;}: 
</span></span><span class="line"><span class="cl">basicBooleanExpression {$str=$basicBooleanExpression.str;} EOF;
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 <code>EOF</code> character 的原因是，如果在解析 basicbooleanExpression 规则时出现语法错误，那么解析规则将尝试恢复语法错误并报告收集到的语法错误，然后继续解析，因为 <code>EOF</code> 是完成规则所必需的，而且解析器尚未到达 <code>EOF</code>。</p>
<p>由于我们已经定义了语法并将其分成了两个独立的文件，因此我们可以选择在解析器文件中将词法作为定义规则的词汇:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">options {
</span></span><span class="line"><span class="cl">tokenVocab = BooleanExprLexer;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>回到我们的解析器，</p>
<ul>
<li>第一条规则或 basicBooleanExpresion 规则定义了三个选项，在我们的 python 目标代码评估中应始终返回一个布尔值。第一种是后两种规则的组合，即两个布尔表达式与一个逻辑和/或运算符的组合；</li>
<li>第二种是另一种三元表达式，即使用比较器（如、小于或 LT）比较两个基本表达式彼此返回的某个值；</li>
<li>最后，第三种是单元表达式（只有一个布尔值，如 True 或 False）。</li>
</ul>
<p>这些规则由运算符 <code>|</code> 分隔。这意味着，basicBooleanExpression 在识别输入字符串时，可以根据从左到右的文本识别，递归地引用其子规则中的任一规则。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">basicBooleanExpression
</span></span><span class="line"><span class="cl">returns[String str]:
</span></span><span class="line"><span class="cl">left = basicBooleanExpression op = logicalOperator right = basicBooleanExpression   {$str=$left.str +&#34; &#34;+$op.text+&#34; &#34;+$right.str;} # logicalExpression
</span></span><span class="line"><span class="cl">| left = expression op = comparator right = expression {$str=&#34;(&#34;+$left.text +&#34; &#34;+$op.text+&#34; &#34;+$right.text+&#34;)&#34;;} # comparisonExpression
</span></span><span class="line"><span class="cl">| bool            {$str=$bool.str;}       # booleanExpression;
</span></span></code></pre></td></tr></table>
</div>
</div><p>basicBooleanExpression 中的每条规则都分配给一个变量名，如 left、right（表达式中的左右操作数）和 op（操作数的缩写），或者是一条单标记规则。$str 变量用于分配当前表达式解析的结果，并使用规则开头的 [String str] 返回值返回。</p>
<p><code>#</code> 用于标记每条规则，使其在目标语言解析器（在我们的例子中是 Java 解析器类）中有专门的监听器方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">lexer</span> <span class="nx">grammar</span> <span class="nx">BooleanExprLexer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="nx">header</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">antlrsource</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">AND</span><span class="p">:</span> <span class="nx">A</span> <span class="nx">N</span> <span class="nx">D</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">OR</span><span class="p">:</span> <span class="nx">O</span> <span class="nx">R</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">NOT</span><span class="p">:</span> <span class="nx">N</span> <span class="nx">O</span> <span class="nx">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">TRUE</span><span class="p">:</span> <span class="err">&#39;</span><span class="nx">True</span><span class="err">&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">FALSE</span><span class="p">:</span> <span class="err">&#39;</span><span class="nx">False</span><span class="err">&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">GT</span><span class="p">:</span> <span class="nx">G</span> <span class="nx">T</span> <span class="p">{</span><span class="nf">setText</span><span class="p">(</span><span class="s">&#34; &gt; &#34;</span><span class="p">);};</span>
</span></span><span class="line"><span class="cl"><span class="nx">GE</span><span class="p">:</span> <span class="nx">G</span> <span class="nx">E</span> <span class="p">{</span><span class="nf">setText</span><span class="p">(</span><span class="s">&#34; &gt;= &#34;</span><span class="p">);};</span>
</span></span><span class="line"><span class="cl"><span class="nx">LT</span><span class="p">:</span> <span class="nx">L</span> <span class="nx">T</span> <span class="p">{</span><span class="nf">setText</span><span class="p">(</span><span class="s">&#34; &lt; &#34;</span><span class="p">);};</span>
</span></span><span class="line"><span class="cl"><span class="nx">LE</span><span class="p">:</span> <span class="nx">L</span> <span class="nx">E</span> <span class="p">{</span><span class="nf">setText</span><span class="p">(</span><span class="s">&#34; &lt;= &#34;</span><span class="p">);};</span>
</span></span><span class="line"><span class="cl"><span class="nx">EQ</span><span class="p">:</span> <span class="nx">E</span> <span class="nx">Q</span> <span class="p">{</span><span class="nf">setText</span><span class="p">(</span><span class="s">&#34; == &#34;</span><span class="p">);};</span>
</span></span><span class="line"><span class="cl"><span class="nx">LPARENTHESIS</span><span class="p">:</span> <span class="sc">&#39;(&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">RPARENTHESIS</span><span class="p">:</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">DECIMAL_NUMBER</span><span class="p">:</span> <span class="sc">&#39;-&#39;</span><span class="err">?</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span> <span class="p">(</span> <span class="sc">&#39;.&#39;</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span><span class="p">)</span><span class="err">?</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">IDENTIFIER</span><span class="p">:</span> <span class="p">[</span><span class="nx">a</span><span class="o">-</span><span class="nx">zA</span><span class="o">-</span><span class="nx">Z_</span><span class="p">]</span> <span class="p">[</span><span class="nx">a</span><span class="o">-</span><span class="nx">zA</span><span class="o">-</span><span class="nx">Z_0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">WS</span><span class="p">:</span> <span class="p">[</span> <span class="err">\</span><span class="nx">r</span><span class="err">\</span><span class="nx">t</span><span class="err">\</span><span class="nx">u000C</span><span class="err">\</span><span class="nx">n</span><span class="p">]</span><span class="o">+</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">skip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">A</span> <span class="p">:</span> <span class="p">[</span><span class="nx">aA</span><span class="p">];</span> <span class="c1">// match either an &#39;a&#39; or &#39;A&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fragment</span> <span class="nx">B</span> <span class="p">:</span> <span class="p">[</span><span class="nx">bB</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">C</span> <span class="p">:</span> <span class="p">[</span><span class="nx">cC</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">D</span> <span class="p">:</span> <span class="p">[</span><span class="nx">dD</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">E</span> <span class="p">:</span> <span class="p">[</span><span class="nx">eE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">F</span> <span class="p">:</span> <span class="p">[</span><span class="nx">fF</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">G</span> <span class="p">:</span> <span class="p">[</span><span class="nx">gG</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">H</span> <span class="p">:</span> <span class="p">[</span><span class="nx">hH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">I</span> <span class="p">:</span> <span class="p">[</span><span class="nx">iI</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">J</span> <span class="p">:</span> <span class="p">[</span><span class="nx">jJ</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">K</span> <span class="p">:</span> <span class="p">[</span><span class="nx">kK</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">L</span> <span class="p">:</span> <span class="p">[</span><span class="nx">lL</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">M</span> <span class="p">:</span> <span class="p">[</span><span class="nx">mM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">N</span> <span class="p">:</span> <span class="p">[</span><span class="nx">nN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">O</span> <span class="p">:</span> <span class="p">[</span><span class="nx">oO</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">P</span> <span class="p">:</span> <span class="p">[</span><span class="nx">pP</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">Q</span> <span class="p">:</span> <span class="p">[</span><span class="nx">qQ</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">R</span> <span class="p">:</span> <span class="p">[</span><span class="nx">rR</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">S</span> <span class="p">:</span> <span class="p">[</span><span class="nx">sS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">T</span> <span class="p">:</span> <span class="p">[</span><span class="nx">tT</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">U</span> <span class="p">:</span> <span class="p">[</span><span class="nx">uU</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">V</span> <span class="p">:</span> <span class="p">[</span><span class="nx">vV</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">W</span> <span class="p">:</span> <span class="p">[</span><span class="nx">wW</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">X</span> <span class="p">:</span> <span class="p">[</span><span class="nx">xX</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">Y</span> <span class="p">:</span> <span class="p">[</span><span class="nx">yY</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nx">fragment</span> <span class="nx">Z</span> <span class="p">:</span> <span class="p">[</span><span class="nx">zZ</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>BooleanExprLexer.g4</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">parser</span> <span class="nx">grammar</span> <span class="nx">BooleanExprParser</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="nx">header</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">antlrsource</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">options</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tokenVocab</span> <span class="p">=</span> <span class="nx">BooleanExprLexer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">parse</span>
</span></span><span class="line"><span class="cl">	<span class="nx">returns</span><span class="p">[</span><span class="nx">String</span> <span class="nx">str</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="err">@</span><span class="nx">init</span> <span class="p">{</span><span class="err">$</span><span class="nx">str</span><span class="p">=</span><span class="s">&#34;&#34;</span><span class="p">;}:</span> <span class="nx">basicBooleanExpression</span> <span class="p">{</span><span class="err">$</span><span class="nx">str</span><span class="p">=</span><span class="err">$</span><span class="nx">basicBooleanExpression</span><span class="p">.</span><span class="nx">str</span><span class="p">;}</span> <span class="nx">EOF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">basicBooleanExpression</span>
</span></span><span class="line"><span class="cl">	<span class="nx">returns</span><span class="p">[</span><span class="nx">String</span> <span class="nx">str</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">	<span class="nx">left</span> <span class="p">=</span> <span class="nx">basicBooleanExpression</span> <span class="nx">op</span> <span class="p">=</span> <span class="nx">logicalOperator</span> <span class="nx">right</span> <span class="p">=</span> <span class="nx">basicBooleanExpression</span>	<span class="p">{</span><span class="err">$</span><span class="nx">str</span><span class="p">=</span><span class="err">$</span><span class="nx">left</span><span class="p">.</span><span class="nx">str</span> <span class="o">+</span><span class="s">&#34; &#34;</span><span class="o">+</span><span class="err">$</span><span class="nx">op</span><span class="p">.</span><span class="nx">text</span><span class="o">+</span><span class="s">&#34; &#34;</span><span class="o">+</span><span class="err">$</span><span class="nx">right</span><span class="p">.</span><span class="nx">str</span><span class="p">;}</span> <span class="err">#</span> <span class="nx">logicalExpression</span>
</span></span><span class="line"><span class="cl">	<span class="p">|</span> <span class="nx">left</span> <span class="p">=</span> <span class="nx">expression</span> <span class="nx">op</span> <span class="p">=</span> <span class="nx">comparator</span> <span class="nx">right</span> <span class="p">=</span> <span class="nx">expression</span> <span class="p">{</span><span class="err">$</span><span class="nx">str</span><span class="p">=</span><span class="s">&#34;(&#34;</span><span class="o">+</span><span class="err">$</span><span class="nx">left</span><span class="p">.</span><span class="nx">text</span> <span class="o">+</span><span class="s">&#34; &#34;</span><span class="o">+</span><span class="err">$</span><span class="nx">op</span><span class="p">.</span><span class="nx">text</span><span class="o">+</span><span class="s">&#34; &#34;</span><span class="o">+</span><span class="err">$</span><span class="nx">right</span><span class="p">.</span><span class="nx">text</span><span class="o">+</span><span class="s">&#34;)&#34;</span><span class="p">;}</span>	<span class="err">#</span> <span class="nx">comparisonExpression</span>
</span></span><span class="line"><span class="cl">	<span class="p">|</span> <span class="kt">bool</span>											<span class="p">{</span><span class="err">$</span><span class="nx">str</span><span class="p">=</span><span class="err">$</span><span class="kt">bool</span><span class="p">.</span><span class="nx">str</span><span class="p">;}</span>		<span class="err">#</span> <span class="nx">booleanExpression</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">expression</span>
</span></span><span class="line"><span class="cl">	<span class="nx">returns</span><span class="p">[</span><span class="nx">String</span> <span class="nx">str</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">	<span class="nx">LPARENTHESIS</span> <span class="nx">expression</span> <span class="nx">RPARENTHESIS</span>				<span class="err">#</span> <span class="nx">parenthesisExpression</span>
</span></span><span class="line"><span class="cl">	<span class="p">|</span> <span class="nx">NOT</span> <span class="nx">expression</span>									<span class="err">#</span> <span class="nx">notExpression</span>
</span></span><span class="line"><span class="cl">	<span class="p">|</span> <span class="kt">bool</span>												<span class="err">#</span> <span class="nx">unaryboolExpression</span>
</span></span><span class="line"><span class="cl">	<span class="p">|</span> <span class="nx">IDENTIFIER</span>										<span class="err">#</span> <span class="nx">identifierExpression</span>
</span></span><span class="line"><span class="cl">	<span class="p">|</span> <span class="nx">DECIMAL_NUMBER</span>									<span class="err">#</span> <span class="nx">decimalExpression</span>
</span></span><span class="line"><span class="cl">	<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">comparator</span>
</span></span><span class="line"><span class="cl">	<span class="nx">returns</span><span class="p">[</span><span class="nx">String</span> <span class="nx">str</span><span class="p">]:</span> <span class="nx">GT</span> <span class="p">|</span> <span class="nx">GE</span> <span class="p">|</span> <span class="nx">LT</span> <span class="p">|</span> <span class="nx">LE</span> <span class="p">|</span> <span class="nx">EQ</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">logicalOperator</span>
</span></span><span class="line"><span class="cl">	<span class="nx">returns</span><span class="p">[</span><span class="nx">String</span> <span class="nx">str</span><span class="p">]:</span> <span class="nx">AND</span> <span class="p">|</span> <span class="nx">OR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="nx">returns</span><span class="p">[</span><span class="nx">String</span> <span class="nx">str</span><span class="p">]:</span> <span class="nx">TRUE</span> <span class="p">|</span> <span class="nx">FALSE</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>BooleanExprParser.g4</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a gt b and c gt d
</span></span><span class="line"><span class="cl">a eq b
</span></span></code></pre></td></tr></table>
</div>
</div><p>input demo</p>
<h3 id="maven-configuration">Maven Configuration</h3>
<p>现在，让我们继续生成解析器文件。这次，我将使用 maven 配置和 VS Code 的 ANTLR 插件来生成这些文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;plugin&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;groupId&gt;</span>org.antlr<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;artifactId&gt;</span>antlr4-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;version&gt;</span>4.8-1<span class="nt">&lt;/version&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;executions&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;execution&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;id&gt;</span>antlr<span class="nt">&lt;/id&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;configuration&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;libDirectory&gt;</span>${basedir}/src/main/antlr<span class="nt">&lt;/libDirectory&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;sourceDirectory&gt;</span>${basedir}/src/main/antlr<span class="nt">&lt;/sourceDirectory&gt;&lt;outputDirectory&gt;</span>${basedir}/src/main/java/antlrsource<span class="nt">&lt;/outputDirectory&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;visitor&gt;</span>false<span class="nt">&lt;/visitor&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;listener&gt;</span>true<span class="nt">&lt;/listener&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="nt">&lt;/configuration&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="nt">&lt;goals&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;goal&gt;</span>antlr4<span class="nt">&lt;/goal&gt;</span>
</span></span><span class="line"><span class="cl">     <span class="nt">&lt;/goals&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/execution&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/executions&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/plugin&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个标签都定义了 ANTLR 在生成解析器类时应使用的目录或需要或不需要生成的文件。例如，监听器和访问者标签的定义都是为了根据它们的布尔值生成相应的 java classes/interfaces。</p>
<center>

<div class="box" style="max-width:40%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/target-language-file.webp" />
    </div>
    <a href="./target-language-file.webp" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>The set of target language parser files</h4>
      </figcaption>
  </figure>
</div>
</center>
<h3 id="traversal-patterns">Traversal Patterns</h3>
<p>让我们深入了解 Listener vs Visitor traversal patterns ，并探索 BooleanExprParserBaseListener class 的功能。</p>
<p>ANTLR4 提供了两种遍历语法树的方法：</p>
<ul>
<li>Listener(default)：listener pattern 是一种事件驱动方法，用于遍历每个解析器规则类型的语法树。为每个解析器规则提供一个包含进入和退出事件方法的接口。</li>
<li>Visitor：这使得用户也可以控制解析树的遍历。解析树中的节点（解析器规则）将使用提供的访问方法明确遍历或访问。</li>
</ul>
<p>根据使用环境的不同，<code>Listener</code> 和 <code>Visitor</code> 模式各有利弊。</p>
<p><strong>相同点</strong></p>
<ul>
<li>两种实现方式的规则语法规则完全相同。</li>
<li>两种实现方式的解析器输出也完全相同。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>由于 Listener pattern 依赖于用户来定义其遍历序列，因此它使用调用堆栈来管理这些遍历，这意味着大量输入可能会导致溢出，而在已分配堆上使用堆栈的监听器则不会出现这种问题。</li>
</ul>
<p>Listener pattern 和 Visitor pattern 的最大区别在于，监听器方法是由 ANTLR 提供的行走器对象独立调用的，而访问者方法必须通过显式访问调用来行走其子节点。如果忘记在节点的子节点上调用访问者方法，就意味着这些子树不会被访问。</p>
<p>跳回到我们生成的 Listener</p>
<center>

<div class="box" style="max-width:100%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/listener-implementation.webp" />
    </div>
    <a href="./listener-implementation.webp" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>Listener Implementation</h4>
      </figcaption>
  </figure>
</div>
</center>
<center>

<div class="box" style="max-width:90%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/listener-interface.webp" />
    </div>
    <a href="./listener-interface.webp" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>Listener Interface</h4>
      </figcaption>
  </figure>
</div>
</center>
<p>接口类的实现只针对某些语言，一般来说，implementing class/module 是在目标语言中定义的。请注意，interface 和 implementation 中都定义了根（或解析）节点监听器方法。所有方法都有相应的上下文对象，该对象由生成的解析器类提供。这样就可以在遍历解析树时对该规则的上下文进行操作。</p>
<p>让我们创建与解析器的第一次 interaction ，并生成一个简单表达式的输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//  Creates a lexer for the input string to generate the tokens </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">BooleanExprLexer</span><span class="w"> </span><span class="n">lexer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BooleanExprLexer</span><span class="p">(</span><span class="n">CharStreams</span><span class="p">.</span><span class="na">fromString</span><span class="p">(</span><span class="s">&#34;a eq b&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//  Stores the tokens generated by the lexer for the input string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">CommonTokenStream</span><span class="w"> </span><span class="n">tokens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CommonTokenStream</span><span class="p">(</span><span class="n">lexer</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/** 
</span></span></span><span class="line"><span class="cl"><span class="cm">    Creates a parser for generation of an Abstract Syntax tree from
</span></span></span><span class="line"><span class="cl"><span class="cm">    the stream of tokens to identify context 
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">BooleanExprParser</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BooleanExprParser</span><span class="p">(</span><span class="n">tokens</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/** 
</span></span></span><span class="line"><span class="cl"><span class="cm">    Creates a parse tree for generating the output string and
</span></span></span><span class="line"><span class="cl"><span class="cm">    manipulation of the parser and lexer tokens in the parse tree.
</span></span></span><span class="line"><span class="cl"><span class="cm">    The tree is create considering the parse rule in the grammar
</span></span></span><span class="line"><span class="cl"><span class="cm">    as the root node. This tree will be used later for listener.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ParseTree</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parse</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/** 
</span></span></span><span class="line"><span class="cl"><span class="cm">    Convert the root node&#39;s output to it&#39;s rule context and use
</span></span></span><span class="line"><span class="cl"><span class="cm">    its attribute for printing the parser&#39;s output string.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ParseContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ParseContext</span><span class="p">)</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="na">str</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于我们已经在语法文件中添加了将基本运算符转换为 python 对应运算符的操作，因此解析器的输出表达式已经是解析形式。例如，一个简单的比较表达式，如 <code>a eq b</code>，将转换为 python 表达式 <code>a == b</code> 。</p>
<p>现在，我们已经转换了表达式，可以使用监听器文件中的某些更改将其转换为函数，并使用 template 将该表达式替换为 placeholder function text，用于多个类似表达式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="o">&lt;</span><span class="n">function_name</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">list_of_parameters</span><span class="o">&gt;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>parsed expression 可以很容易地替换成上面的表达式。不用担心替换部分，我们稍后会讲到。现在，为了从每个表达式中提取参数列表，我们将添加一个列表，以便在每次触发标识符类型（解析器规则）的输入事件监听器方法时捕获每个标识符名称。</p>
<p>让我们定义一个字符串列表作为实例变量，在无参数构造函数中对其进行初始化，定义其 getter 方法，并添加一个方法来清除该列表，以便每次表达式解析和替换完成后都能清除该列表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">BooleanExprParserBaseListener</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">BooleanExprParserListener</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">identifiersList</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">BooleanExprParserBaseListener</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">identifiersList</span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">...</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>让我们把上下文 getText 方法中的标识符名称添加到我们为 identifierExpression 每次触发输入事件时创建的列表中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">clearIdentifiers</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">identifiersList</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">getIdentifiersList</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">identifiersList</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Override</span><span class="w"> </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">enterIdentifierExpression</span><span class="p">(</span><span class="n">BooleanExprParser</span><span class="p">.</span><span class="na">IdentifierExpressionContext</span><span class="w"> </span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="n">identifiersList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="na">getText</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>最后，我们需要在树上遍历，以触发这些事件，从而收集表达式的所有参数。ANTLR 为此提供了 ParseTreeWalker 类。顾名思义，该类允许在走过解析树时同时使用监听器和访问者实现类。让我们使用监听器来遍历上面定义的解析树：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">BooleanExprParserBaseListener</span><span class="w"> </span><span class="n">booleanExprBaseListener</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BooleanExprParserBaseListener</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ParseTreeWalker</span><span class="w"> </span><span class="n">walker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ParseTreeWalker</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">walker</span><span class="p">.</span><span class="na">walk</span><span class="p">(</span><span class="n">booleanExprBaseListener</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">identifiers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">booleanExprBaseListener</span><span class="p">.</span><span class="na">getIdentifiersList</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">booleanExprBaseListener</span><span class="p">.</span><span class="na">clearIdentifiers</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，这里的 walk 方法使用 listener 来监听在解析树上行走时触发的事件。接下来，我们使用 getter 方法获取解析表达式时获取的所有标识符名称列表。</p>
<h3 id="generate-code">Generate Code</h3>
<center>

<div class="box" style="max-width:35%">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/process.webp" />
    </div>
    <a href="./process.webp" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>A gist of what the process looks like so far</h4>
      </figcaption>
  </figure>
</div>
</center>
<p>将使用上一部分 generated expression 或 the output of intermediate code generation，并将其替换为模板组文件(templating engine 使用的东西)，这样我们就可以将渲染的函数串写入 python 文件。</p>
<p>templating engine 将以我们的目标语言（即 Python）生成实际可用的代码，从而实现代码生成的目标。</p>
<p>提到 templating engine ，你首先想到的就是 web frameworks。几乎所有的现代 web frameworks 都有一个共同的目标，那就是使用模板引擎生成动态的、业务就绪的网页。每个模板引擎的最终目标都是将获取的输出结果替换为模板文件，以便即时显示给最终用户。</p>
<p><a href="https://airtable.com/appKhTrTnhdxy4nsI/shrSXv4w4Lk8Qz20B/tblTb3BvfsOdcqC0M">templating engines compared side-by-side</a></p>
<h4 id="stringtemplate">StringTemplate</h4>
<p>我将使用一个名为 <a href="https://www.stringtemplate.org/">StringTemplate</a> 的类似模板引擎。它被广泛用于网页模板化，但也支持用于创建目标语言代码文件的基本模板操作。</p>
<ul>
<li><code>&lt;attribute&gt;</code> 如果存在，则求值为属性的字符串值，否则为空字符串。
<ul>
<li>例如，在使用 Java 中的 StringTemplate 对象时，<code>&lt;expression&gt;</code> 将以 key expression 表示。因此，如果用户在 expression 键上输入任何值，它就会在模板中被称为 expression 属性。</li>
</ul>
</li>
<li>对于模板内的自定义或用户定义对象，请使用 <code>&lt;attribute.property&gt;</code> ，将属性作为属性查找，然后使用 <code>getProperty()</code> 或 <code>isProperty()</code> 或 <code>hasProperty()</code> 等访问器方法。</li>
<li><code>&lt;attribute:t1(argument-list)：... :tN(argument-list)&gt;</code> 迭代同一个模板替换的对象列表。从左到右依次应用多个模板。在多值属性上应用模板的结果是另一个多值属性。整个表达式的求值结果是所有模板元素的连接结果</li>
<li><code>&lt;! comment !&gt;</code> StringTemplate 会忽略已定义的注释。</li>
<li>模板定义看起来就像带有未键入参数的函数定义：
<ul>
<li><code>templateName(arg1, arg2, ..., argN) ::= &quot;single-line template&quot;</code></li>
<li><code>templateName(arg1, arg2, ..., argN) ::= &lt;&lt;multi-line template&gt;&gt;</code></li>
<li><code>templateName(arg1, arg2, ..., argN) ::= &lt;%multi-line template that ignores indentation and newlines%&gt;</code></li>
</ul>
</li>
</ul>
<p>下面我们来看看 Python <code>StringTemplateExample.stg</code> 文件的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&lt;! StringTemplateExample.stg !&gt;
</span></span><span class="line"><span class="cl">templateExample(functions) ::= &lt;&lt;
</span></span><span class="line"><span class="cl">&lt;functions :{function |
</span></span><span class="line"><span class="cl">def &lt;function.function_name&gt;(&lt;function.params_list&gt;)
</span></span><span class="line"><span class="cl">return &lt;function.expression&gt;
</span></span><span class="line"><span class="cl">}&gt;
</span></span><span class="line"><span class="cl">&gt;&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，为了保持缩进和两行间隙，我使用了上面基础示例中的第二种模板类型，因为这需要遵循 Python PEP8 的规则，即在 Python 方法之间有两行间隙。下面我们来看看该模板在 Java 中的用法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lines</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="na">lines</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">Collectors</span><span class="p">.</span><span class="na">toList</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">functionName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;generated_function_%1$s&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span><span class="w"> </span><span class="n">functions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="n">Map</span><span class="w"> </span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">function</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">lines</span><span class="p">.</span><span class="na">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">BooleanExprLexer</span><span class="w"> </span><span class="n">lexer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BooleanExprLexer</span><span class="p">(</span><span class="n">CharStreams</span><span class="p">.</span><span class="na">fromString</span><span class="p">(</span><span class="n">lines</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">i</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">CommonTokenStream</span><span class="w"> </span><span class="n">tokens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CommonTokenStream</span><span class="p">(</span><span class="n">lexer</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">BooleanExprParser</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BooleanExprParser</span><span class="p">(</span><span class="n">tokens</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">ParseTree</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="na">parse</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">ParseContext</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ParseContext</span><span class="p">)</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="na">str</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">BooleanExprParserBaseListener</span><span class="w"> </span><span class="n">booleanExprBaseListener</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BooleanExprParserBaseListener</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">ParseTreeWalker</span><span class="w"> </span><span class="n">walker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ParseTreeWalker</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">walker</span><span class="p">.</span><span class="na">walk</span><span class="p">(</span><span class="n">booleanExprBaseListener</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">identifiers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">booleanExprBaseListener</span><span class="p">.</span><span class="na">getIdentifiersList</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">function</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;function_name&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="p">.</span><span class="na">format</span><span class="p">(</span><span class="n">functionName</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">function</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;expression&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="na">str</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">function</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;params_list&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">identifiers</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">Collectors</span><span class="p">.</span><span class="na">joining</span><span class="p">(</span><span class="s">&#34;, &#34;</span><span class="p">)));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">functions</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">function</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">booleanExprBaseListener</span><span class="p">.</span><span class="na">clearIdentifiers</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">stringTemplateExample</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;functions&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">functions</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">stringTemplateExample</span><span class="p">.</span><span class="na">render</span><span class="p">());</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>INPUT</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a gt b and c gt d
</span></span><span class="line"><span class="cl">a eq b
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Output</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">generated_function_0</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span>  <span class="o">&gt;</span>  <span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c</span>  <span class="o">&gt;</span>  <span class="n">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">generated_function_1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span>  <span class="o">==</span>  <span class="n">b</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="resources">Resources</h2>
<ul>
<li>repo : <a href="https://github.com/WFUing/BooleanParser">https://github.com/WFUing/BooleanParser</a></li>
<li><a href="https://medium.com/analytics-vidhya/antlr-and-code-generation-a71ead442005">https://medium.com/analytics-vidhya/antlr-and-code-generation-a71ead442005</a></li>
<li><a href="https://medium.com/analytics-vidhya/python-from-expressions-the-antlr-series-part-1-3d7696c3a01c">https://medium.com/analytics-vidhya/python-from-expressions-the-antlr-series-part-1-3d7696c3a01c</a></li>
<li><a href="https://medium.com/analytics-vidhya/python-from-expressions-the-antlr-series-part-2-5436ef00bcf">https://medium.com/analytics-vidhya/python-from-expressions-the-antlr-series-part-2-5436ef00bcf</a></li>
<li><a href="https://medium.com/analytics-vidhya/python-from-expressions-the-antlr-series-part-3-7ac541a1d08c">https://medium.com/analytics-vidhya/python-from-expressions-the-antlr-series-part-3-7ac541a1d08c</a></li>
</ul>


                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/posts/tech/language/code-generation/asyncapi-code-generator/" data-toggle="tooltip" data-placement="top" title="A Modeling Editor and Code Generator for message-driven architectures with AsyncAPI">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                </ul>
                

                



            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    
                    
                    
                    

		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; Waiting For You 2023
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>






<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body>
</html>
