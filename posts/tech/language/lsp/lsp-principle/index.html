<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Language Server Protocol 的工作原理 | Waiting For You</title>
<meta name="keywords" content="lsp">
<meta name="description" content="Language Server Protocol （语言服务器协议，简称 LSP）是微软于 2016 年提出的一套统一的通讯协议方案。该方案定义了一套编辑器或 IDE 与语言服务器之间使用的协议，该语言服务器提供自动完成、转到定义、查找所有引用等语言功能。">
<meta name="author" content="WFUing">
<link rel="canonical" href="https://WFUing.github.io/posts/tech/language/lsp/lsp-principle/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4826a65311a560dd509e51c68a8ba0b686724e899e3dd2073a0aabed6d1af607.css" integrity="sha256-SCamUxGlYN1QnlHGiougtoZyTomePdIHOgqr7W0a9gc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://WFUing.github.io/img/logo.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://WFUing.github.io/img/logo.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://WFUing.github.io/img/logo.gif">
<link rel="apple-touch-icon" href="https://WFUing.github.io/logo.gif">
<link rel="mask-icon" href="https://WFUing.github.io/logo.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            },
            "HTML-CSS": {
                availableFonts: ["Arial", "TeX"],
                preferredFont: "TeX",
                webFont: "TeX"
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>

<meta property="og:title" content="Language Server Protocol 的工作原理" />
<meta property="og:description" content="Language Server Protocol （语言服务器协议，简称 LSP）是微软于 2016 年提出的一套统一的通讯协议方案。该方案定义了一套编辑器或 IDE 与语言服务器之间使用的协议，该语言服务器提供自动完成、转到定义、查找所有引用等语言功能。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://WFUing.github.io/posts/tech/language/lsp/lsp-principle/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-10T13:21:20+08:00" />
<meta property="article:modified_time" content="2023-12-10T13:21:20+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Language Server Protocol 的工作原理"/>
<meta name="twitter:description" content="Language Server Protocol （语言服务器协议，简称 LSP）是微软于 2016 年提出的一套统一的通讯协议方案。该方案定义了一套编辑器或 IDE 与语言服务器之间使用的协议，该语言服务器提供自动完成、转到定义、查找所有引用等语言功能。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://WFUing.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Technology",
      "item": "https://WFUing.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Language",
      "item": "https://WFUing.github.io/posts/tech/language/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Language Server Protocol",
      "item": "https://WFUing.github.io/posts/tech/language/lsp/"
    }, 
    {
      "@type": "ListItem",
      "position":  5 ,
      "name": "Language Server Protocol 的工作原理",
      "item": "https://WFUing.github.io/posts/tech/language/lsp/lsp-principle/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Language Server Protocol 的工作原理",
  "name": "Language Server Protocol 的工作原理",
  "description": "Language Server Protocol （语言服务器协议，简称 LSP）是微软于 2016 年提出的一套统一的通讯协议方案。该方案定义了一套编辑器或 IDE 与语言服务器之间使用的协议，该语言服务器提供自动完成、转到定义、查找所有引用等语言功能。",
  "keywords": [
    "lsp"
  ],
  "articleBody": "Language Server Protocol （语言服务器协议，简称 LSP）是微软于 2016 年提出的一套统一的通讯协议方案。该方案定义了一套编辑器或 IDE 与语言服务器之间使用的协议，该语言服务器提供自动完成、转到定义、查找所有引用等语言功能。\n同学们可能对语言服务器（Language Server）不是很了解。举个例子，我们在使用在线编程工具的时候，是不是也有代码提示、代码错误诊断等功能？其实背后是跑着一个对应这门语言的 language server 进程实例（也有开发者工具本身和 Language Server 耦合在一起的，比如 Eclipse），这个 Language Server 实例负责分析你当前打开的代码文件。\n市面上的 编辑器 / IDE，本质上提供给用户的代码编辑（如打开文件、编辑文集、查找引用、打开工作区等）以及编辑器的响应行为（如补全提示、代码诊断等）其实都大同小异，可能在个别功能上实现不一样，但是逃不开上述内容。或者说，上述这些功能都可以抽象为一系列的「行为事件」。\n微软提出 LSP 的目的是，之前各个编辑器（VSCode, Vim, Atom, Sublime…）各自为战，编辑器内部实现的特性和协议都不同。每换一个编辑器，就有可能要给该编辑器中支持的每门语言写一个对应的 Language Server，也就是说假设有 $n$ 门语言，$m$ 个编辑器，那全部编辑器适配所有语言的开发成本和复杂度为 $n * m$。\n能不能在中间层做一个抽象，让语言的「静态分析服务」和「编辑器 / IDE」分离开来？这样上述情景下开发成本和复杂度就可以降低为线性的 $n + m$。\n例如，每个编辑器（客户端）都在用户产生某些通用的行为时（比如点击跳转到定义）负责生成标准中的行为事件，然后以 JSON-RPC 的形式去调用 Language Server 的接口方法。Language Server 相对应地，也必须实现全部 LSP 规范（或者至少实现其中关键部分）定义的接口。\n这么做的好处在于，对于某门编程语言，一个编辑器工具不需要再去关心怎么去做代码分析，而是只需要关注如何在界面上发起或响应 LSP 规定的 RPC 事件。而在语言服务器这边也是同理，只需要关注协议本身的事件并响应 \u0026 发起事件即可。\n这种中间层分离的思想非常常见，例如编译器就分为前端和后端，前端生产中间语言 IR，后端负责把中间语言再翻译为 CPU 特定的指令集。典型的代表如 JVM 字节码、 LLVM IR 等\n另外，由于编辑器和 Language Server 是两个进程，所以如果 Language Server 挂了，编辑器进程本身也还会存在，用户不用担心还没修改好的代码因此丢失的问题。\n有没有缺点？肯定有，那就是市面上所有的 编辑器 和 Language Server 的 maintainer 都需要花时间和精力去兼容这个协议，并且这个协议本身也会随着自身版本更新而要求服务端 / 客户端响应新的协议行为。但是总体来说，利大于弊。\nLSP 的运作机制 LSP 是一个「双工协议」。不只是开发者工具（客户端）会主动向 Language Server （服务端）通信，服务端也可能主动向开发者工具发起 RPC 请求（比如代码诊断事件 textDocument/Diagnostics ，只能从服务端向客户端主动发送）。在 LSP 规范定义文档 中，每个 RPC 事件会标注可能的发起方以及是否需要对方做出响应。\n例子\n例如一个客户端发起，且要求服务端返回的请求事件（小标题的括号中有一个从左至右然后转弯的箭头）： 例如一个服务端发起，且要求客户端返回的请求事件（小标题的括号中有一个从右至左然后转弯的箭头）： 也有单方面发送，不需要响应的（分别为工具向服务端单方面发送 / 服务端向工具单方面发送）： 我们以 Goto Type Definition Request 为例，具象化地理解一下整个流程。这个 RPC 请求的发起可能是来自 VSCode 中用户右键菜单中点击 跳转到类型定义 （Goto Type Definition） 这个事件：\nVSCode 会向 Language Server 进程以 IPC 形式发送如下信息（仅举例，实际参数结构比较复杂）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"jsonrpc\": \"2.0\", \"id\": 24, \"method\": \"textDocument/typeDefinition\", \"params\": { \"textDocument\": { \"uri\": \"file:///User/bytedance/java-hello/src/main/java/Main.java\" }, \"position\": { \"line\": 3, \"character\": 13 }, // ...其他参数 }, } 然后 Language Server 拿到这条指令，会执行如下动作：\n调用的方法是 textDocument/typeDefinition，也就是分析一个符号的类型定义信息。 根据参数，指令的来源文件是 Main.java 第 3 行第 13 个字符 —— 分析后可知是 foo 这个符号。 Server 寻找 foo 的符号对应的类型 Foo 所在位置。找到之后，同样通过 IPC 返回结果 JSON-RPC： 1 2 3 4 5 6 7 8 9 10 11 12 { \"jsonrpc\": \"2.0\", // Request 中的 id 为 24，因此 Server 端对应的 Response id 也必须为 24 \"id\": 24, \"result\": { \"uri\": \"file:///User/bytedance/java-hello/src/main/java/Main.java\", \"range\": { \"start\": { \"line\": 7, \"character\": 25 }, \"end\": { \"line\": 7, \"character\": 28 } } }, } 只有客户端根据返回值中的参数，让当前用户的编辑光标跳转到指定位置。\nLSP 的生命周期 上一节中的例子只是 Language Server 和开发者工具之间通信的其中一个特例场景。在编辑代码的整个过程中，Language Server / 开发者工具双方会持续不断地通过各式各样的请求体通信。\n为了规范，Language Server Protocol 中的交互一般需要遵循如下生命周期。\n用户在打开一个项目或者代码文件后，开发者工具就需要视情况启动一个 Language Server 子进程并建立通信。在 Language Server 开始接收消息后，一般从客户端发出初始化请求开始。\n1. 初始化 (Initialize) 由于 Language Server 启动后，并不知道当前编辑器的状态。因此，所有符合 LSP 规范的开发者工具在和符合 LSP 规范的 Language Server 建立连接后，第一个 RPC 请求永远是 initialize 指令。initialize 指令的结构体比较复杂，主要是告知 Language Server 当前的工作区在哪里、客户端提供的能力（capacities）有哪些等等。\nServer 根据编辑器工具请求体内的配置信息初始化完成后，会响应 InitializeResult 结构体作为结果，同时告知客户端当前 Server 具有哪些能力。\n由于不同编辑器的功能实现不一，因此 LSP 中大部分的服务端/客户端能力都是可选的：比如有的客户端不提供 codeLens 功能，有的服务端不提供代码补全功能等。双方是否具备这些能力都会在初始化阶段互相告知，以避免后续产生某些无效的功能请求。\n按照 LSP 规范，客户端对 textDocument/didOpen、textDocument/didChange 和 textDocument/didClose 通知的支持是强制性的，客户端不能选择不支持它们。\n2. 打开文件 (textDocument/didOpen) 然后，每当开发者工具侧的用户在打开（或者在 Language Server 初始化前已经打开）了某个文件，开发者工具会向 Language Server 发出 textDocument/didOpen 通知，告知 Language Server 某个文件被打开。\n「文档打开通知」从客户端发送到服务器，以表示新打开的文本文档。文档的内容现在由客户端管理，语言服务器不得尝试使用文档的 Uri 读取文档的内容。 从这个意义上说，「打开」意味着它由客户端「管理」。 这并不一定表示其内容会显示在编辑器中。在没有相应的「关闭通知」之前发送的情况下，客户端不能多次发送打开通知 —— 也就是说，打开和关闭通知必须一一匹配，并且特定 textDocument 的最大打开计数为 1。 请注意，服务器满足请求的能力，与文本文档是打开还是关闭无关。\n举个例子，我们通过 VSCode 打开 /workspace 下的 main.go 文件：\n1 2 3 4 5 6 7 8 9 package main import ( \"fmt\" ) func main() { fmt.Println(\"Hello World go!\") } 会发送的 textDocument/didOpen 通知结构体为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \"jsonrpc\": \"2.0\", \"method\": \"textDocument/didOpen\", \"params\": { \"textDocument\": { \"uri\": \"file:///workspace/main.go\", \"languageId\": \"go\", \"version\": 2, // 这里的文件内容为 Language Server 中虚拟文件的内容初始状态 \"text\": \"package main\\n\\nimport (\\n\\t\"fmt\"\\n)\\n\\nfunc main() {\\n fmt.Println(\"Hello World go!\")\\n}\" } } } 整体流程图如下：\n我们注意到，Language Server 在得知文件被打开后，会试图维护一个\"虚拟\"的文件结构体，而不会去读取文件系统中对应文件的实际内容。后续的保存文件等操作是交由开发者工具直接写入文件系统完成的，Language Server 不负责同步文件内容。\n之后用户的编辑行为，都会通过事件通知的形式告知 Language Server。而 Language Server 则是根据编辑行为，维护和调整上述虚拟文件对象的数据结构，进而做出响应。\n当然，大家也不要产生误解，Language Server 仍有可能访问文件系统。\n3. 编辑文件 (textDocument/didChange) 编辑文件总是发生在打开事件之后。\n根据 LSP 规范，Language Server 允许的编辑操作的更新方式有三种：不更新、全量更新、增量更新。但大部分 Language Server 一般采用增量更新模式，即发送编辑产生的 “diff” 而非更新后的整体内容。举例来说，我们在代码中新增一行 “a”：\n1 2 3 4 5 6 7 8 9 package main import ( \"fmt\" ) func main() { fmt.Println(\"Hello World go!\") + a } 客户端会产生如下的 JSON-RPC 请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"jsonrpc\":\"2.0\", \"method\":\"textDocument/didChange\", \"params\": { \"textDocument\": { \"uri\": \"file:///workspace/main.go\", \"version\": 37 // 这个版本号用于确认 change 的先后顺序 }, \"contentChanges\": [{ \"range\": { \"start\": { \"line\":8, \"character\":4 }, \"end\": { \"line\": 8, \"character\": 4 } }, \"rangeLength\": 0, \"text\": \"a\" }] } } 然后，服务端根据当前 change 的内容，更新内部的数据结构，决定是否产生某些 “行为”（比如代码诊断等）。\n4. 关闭文件 (textDocument/didClose) 按照规范内容，关闭的文件一般对应着一个已经由客户端打开的文件对象。这里不再赘述。\n当文档在客户端关闭时，文档关闭通知从客户端发送到服务器。 文档的主文件现在存在于文档的 URI 指向的位置（例如，如果文档的 URI 是文件 URI，则主文件现在存在于磁盘上）。 与打开通知一样，关闭通知是关于管理文档内容的。 收到关闭通知并不意味着该文档之前曾在编辑器中打开过。 关闭通知需要发送先前的打开通知。 请注意，服务器满足请求的能力与文本文档是打开还是关闭无关。\n关于 LSP 的常见问题 1. 语言服务器不会访问文件系统中的文件么？ 不，Language Server 还是有可能读取文件系统中未被编辑器打开的文件。\n协议中仅仅规定，textDocument/didOpen 仅是不允许 Language Server 去打开 “客户端已经打开的” 对应 URI 文件的内容，但允许 Language Server 读取工作区和已打开文件上下文中其他「未打开的文件」。\n例如，import 其他库的时候的代码补全功能，Language Server 就需要访问文件系统以获取索引信息。\n2. 代码诊断是怎么实现的？ 一般是通过建立抽象语法树，做语法分析检查语法错误。\n一些插件或者代码诊断工具，如 ESLint，可以在语法规范的 AST 中的节点中遍历访问，找出更多的 Lint 警告/错误。\n3. 代码补全是怎么实现的？ 根据 LSP 中的规定，代码补全由客户端根据事件发起请求，遵循如下触发类型：\n用户输入某个标识符（大部分情况下编辑器会自动执行这个事件）或敲击 Ctrl/Cmd + Space 用户正在输入某个关键字符（比如 “.\"） 补全列表不完整，需要重新触发一次 之后，服务端会根据当前 输入光标的所在位置 以及 文件的上下文信息 来判断如何做代码补全。这一块背后的原理相对比较复杂，后续可以单独列一篇文章讲述。\nResources 官方： https://microsoft.github.io/language-server-protocol/ 非官方博客： https://juejin.cn/post/7051453384645148680 ",
  "wordCount" : "609",
  "inLanguage": "zh",
  "datePublished": "2023-12-10T13:21:20+08:00",
  "dateModified": "2023-12-10T13:21:20+08:00",
  "author":{
    "@type": "Person",
    "name": "WFUing"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://WFUing.github.io/posts/tech/language/lsp/lsp-principle/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Waiting For You",
    "logo": {
      "@type": "ImageObject",
      "url": "https://WFUing.github.io/img/logo.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://WFUing.github.io/" accesskey="h" title="Waiting For You (Alt + H)">Waiting For You</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://WFUing.github.io/search" title="🔍 (Alt &#43; /)" accesskey=/>
                    <span>🔍</span>
                </a>
            </li>
            <li>
                <a href="https://WFUing.github.io/" title="HOME">
                    <span>HOME</span>
                </a>
            </li>
            <li>
                <a href="https://WFUing.github.io/posts" title="BLOGS">
                    <span>BLOGS</span>
                </a>
            </li>
            <li>
                <a href="https://WFUing.github.io/archives" title="ARCHIVE">
                    <span>ARCHIVE</span>
                </a>
            </li>
            <li>
                <a href="https://WFUing.github.io/tags" title="TAGS">
                    <span>TAGS</span>
                </a>
            </li>
            <li>
                <a href="https://WFUing.github.io/about" title="🙋🏻‍♂️">
                    <span>🙋🏻‍♂️</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://WFUing.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/posts/tech/">Technology</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/posts/tech/language/">Language</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/posts/tech/language/lsp/">Language Server Protocol</a></div>
    <h1 class="post-title">
      Language Server Protocol 的工作原理
    </h1>
    <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-12-10
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>609字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>3分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>WFUing
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://WFUing.github.io/tags/lsp/" style="color: var(--secondary)!important;">lsp</a>
            </span>
        </span>
    </span>
</span>
        &nbsp;|&nbsp;标签: &nbsp;
        <ul class="post-tags-meta">
            <a href="https://WFUing.github.io/tags/lsp/">lsp</a>
        </ul>

        
        
        
        
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_page_pv">
            &nbsp;| 访问: <span id="busuanzi_value_page_pv"></span>
        </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#lsp-%e7%9a%84%e8%bf%90%e4%bd%9c%e6%9c%ba%e5%88%b6" aria-label="LSP 的运作机制">LSP 的运作机制</a></li>
                    <li>
                        <a href="#lsp-%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" aria-label="LSP 的生命周期">LSP 的生命周期</a><ul>
                            
                    <li>
                        <a href="#1-%e5%88%9d%e5%a7%8b%e5%8c%96-initialize" aria-label="1. 初始化 (Initialize)">1. 初始化 (Initialize)</a></li>
                    <li>
                        <a href="#2-%e6%89%93%e5%bc%80%e6%96%87%e4%bb%b6-textdocumentdidopen" aria-label="2. 打开文件 (textDocument/didOpen)">2. 打开文件 (textDocument/didOpen)</a></li>
                    <li>
                        <a href="#3-%e7%bc%96%e8%be%91%e6%96%87%e4%bb%b6-textdocumentdidchange" aria-label="3. 编辑文件 (textDocument/didChange)">3. 编辑文件 (textDocument/didChange)</a></li>
                    <li>
                        <a href="#4-%e5%85%b3%e9%97%ad%e6%96%87%e4%bb%b6-textdocumentdidclose" aria-label="4. 关闭文件 (textDocument/didClose)">4. 关闭文件 (textDocument/didClose)</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%85%b3%e4%ba%8e-lsp-%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" aria-label="关于 LSP 的常见问题">关于 LSP 的常见问题</a><ul>
                            
                    <li>
                        <a href="#1-%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%8d%e4%bc%9a%e8%ae%bf%e9%97%ae%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e6%96%87%e4%bb%b6%e4%b9%88" aria-label="1. 语言服务器不会访问文件系统中的文件么？">1. 语言服务器不会访问文件系统中的文件么？</a></li>
                    <li>
                        <a href="#2-%e4%bb%a3%e7%a0%81%e8%af%8a%e6%96%ad%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="2. 代码诊断是怎么实现的？">2. 代码诊断是怎么实现的？</a></li>
                    <li>
                        <a href="#3-%e4%bb%a3%e7%a0%81%e8%a1%a5%e5%85%a8%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="3. 代码补全是怎么实现的？">3. 代码补全是怎么实现的？</a></li></ul>
                    </li>
                    <li>
                        <a href="#resources" aria-label="Resources">Resources</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>Language Server Protocol （语言服务器协议，简称 LSP）是微软于 2016 年提出的一套统一的通讯协议方案。该方案定义了一套编辑器或 IDE 与语言服务器之间使用的协议，该语言服务器提供自动完成、转到定义、查找所有引用等语言功能。</p>
<p>同学们可能对语言服务器（Language Server）不是很了解。举个例子，我们在使用在线编程工具的时候，是不是也有代码提示、代码错误诊断等功能？其实背后是跑着一个对应这门语言的 language server 进程实例（也有开发者工具本身和 Language Server 耦合在一起的，比如 Eclipse），这个 Language Server 实例负责分析你当前打开的代码文件。</p>
<p>市面上的 编辑器 / IDE，本质上提供给用户的代码编辑（如打开文件、编辑文集、查找引用、打开工作区等）以及编辑器的响应行为（如补全提示、代码诊断等）其实都大同小异，可能在个别功能上实现不一样，但是逃不开上述内容。或者说，上述这些功能都可以抽象为一系列的「行为事件」。</p>
<p>微软提出 LSP 的目的是，之前各个编辑器（VSCode, Vim, Atom, Sublime&hellip;）各自为战，编辑器内部实现的特性和协议都不同。每换一个编辑器，就有可能要给该编辑器中支持的每门语言写一个对应的 Language Server，也就是说假设有 $n$ 门语言，$m$ 个编辑器，那全部编辑器适配所有语言的开发成本和复杂度为 $n * m$。</p>
<p>能不能在中间层做一个抽象，让语言的「静态分析服务」和「编辑器 / IDE」分离开来？这样上述情景下开发成本和复杂度就可以降低为线性的 $n + m$。</p>
<center><figure>
    <img loading="lazy" src="./withlsp.png" width="80%"/> 
</figure>
</center>
<p>例如，每个编辑器（客户端）都在用户产生某些通用的行为时（比如点击跳转到定义）负责生成标准中的行为事件，然后以 JSON-RPC 的形式去调用 Language Server 的接口方法。Language Server 相对应地，也必须实现全部 LSP 规范（或者至少实现其中关键部分）定义的接口。</p>
<p>这么做的好处在于，对于某门编程语言，一个编辑器工具不需要再去关心怎么去做代码分析，而是只需要关注如何在界面上发起或响应 LSP 规定的 RPC 事件。而在语言服务器这边也是同理，只需要关注协议本身的事件并响应 &amp; 发起事件即可。</p>
<blockquote>
<p>这种中间层分离的思想非常常见，例如编译器就分为前端和后端，前端生产中间语言 IR，后端负责把中间语言再翻译为 CPU 特定的指令集。典型的代表如 JVM 字节码、 LLVM IR 等</p>
</blockquote>
<p>另外，由于编辑器和 Language Server 是两个进程，所以如果 Language Server 挂了，编辑器进程本身也还会存在，用户不用担心还没修改好的代码因此丢失的问题。</p>
<blockquote>
<p>有没有缺点？肯定有，那就是市面上所有的 编辑器 和 Language Server 的 maintainer 都需要花时间和精力去兼容这个协议，并且这个协议本身也会随着自身版本更新而要求服务端 / 客户端响应新的协议行为。但是总体来说，利大于弊。</p>
</blockquote>
<h2 id="lsp-的运作机制">LSP 的运作机制<a hidden class="anchor" aria-hidden="true" href="#lsp-的运作机制">#</a></h2>
<p>LSP 是一个「双工协议」。不只是开发者工具（客户端）会主动向 Language Server （服务端）通信，服务端也可能主动向开发者工具发起 RPC 请求（比如代码诊断事件 <code>textDocument/Diagnostics</code> ，只能从服务端向客户端主动发送）。在 <a href="https://microsoft.github.io/language-server-protocol/">LSP 规范定义文档</a> 中，每个 RPC 事件会标注可能的发起方以及是否需要对方做出响应。</p>
<p><strong>例子</strong></p>
<ol>
<li>例如一个客户端发起，且要求服务端返回的请求事件（小标题的括号中有一个从左至右然后转弯的箭头）：</li>
</ol>
<center><figure>
    <img loading="lazy" src="./back.png" width="100%"/> 
</figure>
</center>
<ol start="2">
<li>例如一个服务端发起，且要求客户端返回的请求事件（小标题的括号中有一个从右至左然后转弯的箭头）：</li>
</ol>
<center><figure>
    <img loading="lazy" src="./send.png" width="100%"/> 
</figure>
</center>
<ol start="3">
<li>也有单方面发送，不需要响应的（分别为工具向服务端单方面发送 / 服务端向工具单方面发送）：</li>
</ol>
<center><figure>
    <img loading="lazy" src="./to.png" width="100%"/> 
</figure>
</center>
<center><figure>
    <img loading="lazy" src="./from.png" width="100%"/> 
</figure>
</center>
<p>我们以 Goto Type Definition Request 为例，具象化地理解一下整个流程。这个 RPC 请求的发起可能是来自 VSCode 中用户右键菜单中点击 <em>跳转到类型定义 （Goto Type Definition）</em> 这个事件：</p>
<center><figure>
    <img loading="lazy" src="./totype.png" width="100%"/> 
</figure>
</center>
<p>VSCode 会向 Language Server 进程以 IPC 形式发送如下信息（仅举例，实际参数结构比较复杂）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;jsonrpc&#34;</span><span class="p">:</span> <span class="s2">&#34;2.0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;method&#34;</span><span class="p">:</span> <span class="s2">&#34;textDocument/typeDefinition&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;params&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;textDocument&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;uri&#34;</span><span class="p">:</span> <span class="s2">&#34;file:///User/bytedance/java-hello/src/main/java/Main.java&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;position&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;line&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;character&#34;</span><span class="p">:</span> <span class="mi">13</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...其他参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后 Language Server 拿到这条指令，会执行如下动作：</p>
<ol>
<li>调用的方法是 textDocument/typeDefinition，也就是分析一个符号的类型定义信息。</li>
<li>根据参数，指令的来源文件是 Main.java 第 3 行第 13 个字符 —— 分析后可知是 foo 这个符号。</li>
<li>Server 寻找 foo 的符号对应的类型 Foo 所在位置。找到之后，同样通过 IPC 返回结果 JSON-RPC：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;jsonrpc&#34;</span><span class="p">:</span> <span class="s2">&#34;2.0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Request 中的 id 为 24，因此 Server 端对应的 Response id 也必须为 24
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;result&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;uri&#34;</span><span class="p">:</span> <span class="s2">&#34;file:///User/bytedance/java-hello/src/main/java/Main.java&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;range&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;start&#34;</span><span class="p">:</span> <span class="p">{</span> <span class="nt">&#34;line&#34;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="nt">&#34;character&#34;</span><span class="p">:</span> <span class="mi">25</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;end&#34;</span><span class="p">:</span> <span class="p">{</span> <span class="nt">&#34;line&#34;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="nt">&#34;character&#34;</span><span class="p">:</span> <span class="mi">28</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>只有客户端根据返回值中的参数，让当前用户的编辑光标跳转到指定位置。</p>
<h2 id="lsp-的生命周期">LSP 的生命周期<a hidden class="anchor" aria-hidden="true" href="#lsp-的生命周期">#</a></h2>
<p>上一节中的例子只是 Language Server 和开发者工具之间通信的其中一个特例场景。在编辑代码的整个过程中，Language Server / 开发者工具双方会持续不断地通过各式各样的请求体通信。</p>
<p>为了规范，Language Server Protocol 中的交互一般需要遵循如下生命周期。</p>
<center><figure>
    <img loading="lazy" src="./process.png" width="100%"/> 
</figure>
</center>
<p>用户在打开一个项目或者代码文件后，开发者工具就需要视情况启动一个 Language Server 子进程并建立通信。在 Language Server 开始接收消息后，一般从客户端发出初始化请求开始。</p>
<h3 id="1-初始化-initialize">1. 初始化 (Initialize)<a hidden class="anchor" aria-hidden="true" href="#1-初始化-initialize">#</a></h3>
<p>由于 Language Server 启动后，并不知道当前编辑器的状态。因此，所有符合 LSP 规范的开发者工具在和符合 LSP 规范的 Language Server 建立连接后，第一个 RPC 请求永远是 <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initialize">initialize</a> 指令。initialize 指令的结构体比较复杂，主要是告知 Language Server 当前的工作区在哪里、客户端提供的能力（capacities）有哪些等等。</p>
<center><figure>
    <img loading="lazy" src="./initialize.png" width="100%"/> 
</figure>
</center>
<p>Server 根据编辑器工具请求体内的配置信息初始化完成后，会响应 InitializeResult 结构体作为结果，同时告知客户端当前 Server 具有哪些能力。</p>
<blockquote>
<p>由于不同编辑器的功能实现不一，因此 LSP 中大部分的服务端/客户端能力都是可选的：比如有的客户端不提供 codeLens 功能，有的服务端不提供代码补全功能等。双方是否具备这些能力都会在初始化阶段互相告知，以避免后续产生某些无效的功能请求。</p>
<p>按照 LSP 规范，客户端对 textDocument/didOpen、textDocument/didChange 和 textDocument/didClose 通知的支持是强制性的，客户端不能选择不支持它们。</p>
</blockquote>
<h3 id="2-打开文件-textdocumentdidopen">2. 打开文件 (textDocument/didOpen)<a hidden class="anchor" aria-hidden="true" href="#2-打开文件-textdocumentdidopen">#</a></h3>
<p>然后，每当开发者工具侧的用户在打开（或者在 Language Server 初始化前已经打开）了某个文件，开发者工具会向 Language Server 发出 textDocument/didOpen 通知，告知 Language Server 某个文件被打开。</p>
<p>「文档打开通知」从客户端发送到服务器，以表示新打开的文本文档。文档的内容现在由客户端管理，语言服务器不得尝试使用文档的 Uri 读取文档的内容。 从这个意义上说，「打开」意味着它由客户端「管理」。 这并不一定表示其内容会显示在编辑器中。在没有相应的「关闭通知」之前发送的情况下，客户端不能多次发送打开通知 —— 也就是说，打开和关闭通知必须一一匹配，并且特定 textDocument 的最大打开计数为 1。 请注意，服务器满足请求的能力，与文本文档是打开还是关闭无关。</p>
<p>举个例子，我们通过 VSCode 打开 /workspace 下的 main.go 文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World go!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>会发送的 textDocument/didOpen 通知结构体为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;jsonrpc&#34;</span><span class="p">:</span> <span class="s2">&#34;2.0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;method&#34;</span><span class="p">:</span> <span class="s2">&#34;textDocument/didOpen&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;params&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;textDocument&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;uri&#34;</span><span class="p">:</span> <span class="s2">&#34;file:///workspace/main.go&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;languageId&#34;</span><span class="p">:</span> <span class="s2">&#34;go&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 这里的文件内容为 Language Server 中虚拟文件的内容初始状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nt">&#34;text&#34;</span><span class="p">:</span> <span class="s2">&#34;package main\n\nimport (\n\t&#34;</span><span class="err">fmt</span><span class="s2">&#34;\n)\n\nfunc main() {\n    fmt.Println(&#34;</span><span class="err">Hello</span> <span class="err">World</span> <span class="err">go!</span><span class="s2">&#34;)\n}&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>整体流程图如下：</p>
<center><figure>
    <img loading="lazy" src="./process-png.png" width="100%"/> 
</figure>
</center>
<p>我们注意到，Language Server 在得知文件被打开后，会试图维护一个&quot;虚拟&quot;的文件结构体，而不会去读取文件系统中对应文件的实际内容。后续的保存文件等操作是交由开发者工具直接写入文件系统完成的，Language Server 不负责同步文件内容。</p>
<p>之后用户的编辑行为，都会通过事件通知的形式告知 Language Server。而 Language Server 则是根据编辑行为，维护和调整上述虚拟文件对象的数据结构，进而做出响应。</p>
<p>当然，大家也不要产生误解，Language Server 仍有可能访问文件系统。</p>
<h3 id="3-编辑文件-textdocumentdidchange">3. 编辑文件 (textDocument/didChange)<a hidden class="anchor" aria-hidden="true" href="#3-编辑文件-textdocumentdidchange">#</a></h3>
<p>编辑文件总是发生在打开事件之后。</p>
<p>根据 LSP 规范，Language Server 允许的编辑操作的更新方式有三种：不更新、全量更新、增量更新。但大部分 Language Server 一般采用增量更新模式，即发送编辑产生的 &ldquo;diff&rdquo; 而非更新后的整体内容。举例来说，我们在代码中新增一行 &ldquo;a&rdquo;：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World go!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">+</span>   <span class="nx">a</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>客户端会产生如下的 JSON-RPC 请求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;jsonrpc&#34;</span><span class="p">:</span><span class="s2">&#34;2.0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;method&#34;</span><span class="p">:</span><span class="s2">&#34;textDocument/didChange&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;params&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;textDocument&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;uri&#34;</span><span class="p">:</span> <span class="s2">&#34;file:///workspace/main.go&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="mi">37</span>  <span class="c1">// 这个版本号用于确认 change 的先后顺序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;contentChanges&#34;</span><span class="p">:</span> <span class="p">[{</span> 
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;range&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&#34;start&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nt">&#34;line&#34;</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="nt">&#34;character&#34;</span><span class="p">:</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl">                <span class="p">},</span>
</span></span><span class="line"><span class="cl">                <span class="nt">&#34;end&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="nt">&#34;line&#34;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="nt">&#34;character&#34;</span><span class="p">:</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;rangeLength&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nt">&#34;text&#34;</span><span class="p">:</span> <span class="s2">&#34;a&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，服务端根据当前 change 的内容，更新内部的数据结构，决定是否产生某些 &ldquo;行为&rdquo;（比如代码诊断等）。</p>
<h3 id="4-关闭文件-textdocumentdidclose">4. 关闭文件 (textDocument/didClose)<a hidden class="anchor" aria-hidden="true" href="#4-关闭文件-textdocumentdidclose">#</a></h3>
<p>按照规范内容，关闭的文件一般对应着一个已经由客户端打开的文件对象。这里不再赘述。</p>
<p>当文档在客户端关闭时，文档关闭通知从客户端发送到服务器。 文档的主文件现在存在于文档的 URI 指向的位置（例如，如果文档的 URI 是文件 URI，则主文件现在存在于磁盘上）。 与打开通知一样，关闭通知是关于管理文档内容的。 收到关闭通知并不意味着该文档之前曾在编辑器中打开过。 关闭通知需要发送先前的打开通知。 请注意，服务器满足请求的能力与文本文档是打开还是关闭无关。</p>
<h2 id="关于-lsp-的常见问题">关于 LSP 的常见问题<a hidden class="anchor" aria-hidden="true" href="#关于-lsp-的常见问题">#</a></h2>
<h3 id="1-语言服务器不会访问文件系统中的文件么">1. 语言服务器不会访问文件系统中的文件么？<a hidden class="anchor" aria-hidden="true" href="#1-语言服务器不会访问文件系统中的文件么">#</a></h3>
<p>不，Language Server 还是有可能读取文件系统中未被编辑器打开的文件。</p>
<p>协议中仅仅规定，textDocument/didOpen 仅是不允许 Language Server 去打开 &ldquo;客户端已经打开的&rdquo; 对应 URI 文件的内容，但允许 Language Server 读取工作区和已打开文件上下文中其他「未打开的文件」。</p>
<p>例如，import 其他库的时候的代码补全功能，Language Server 就需要访问文件系统以获取索引信息。</p>
<center><figure>
    <img loading="lazy" src="./demo1.png" width="80%"/> 
</figure>
</center>
<h3 id="2-代码诊断是怎么实现的">2. 代码诊断是怎么实现的？<a hidden class="anchor" aria-hidden="true" href="#2-代码诊断是怎么实现的">#</a></h3>
<p>一般是通过建立抽象语法树，做语法分析检查语法错误。</p>
<p>一些插件或者代码诊断工具，如 ESLint，可以在语法规范的 AST 中的节点中遍历访问，找出更多的 Lint 警告/错误。</p>
<h3 id="3-代码补全是怎么实现的">3. 代码补全是怎么实现的？<a hidden class="anchor" aria-hidden="true" href="#3-代码补全是怎么实现的">#</a></h3>
<p>根据 LSP 中的规定，代码补全由客户端根据事件发起请求，遵循如下触发类型：</p>
<ol>
<li>用户输入某个标识符（大部分情况下编辑器会自动执行这个事件）或敲击 Ctrl/Cmd + Space</li>
<li>用户正在输入某个关键字符（比如 &ldquo;.&quot;）</li>
<li>补全列表不完整，需要重新触发一次</li>
</ol>
<p>之后，服务端会根据当前 输入光标的所在位置 以及 文件的上下文信息 来判断如何做代码补全。这一块背后的原理相对比较复杂，后续可以单独列一篇文章讲述。</p>
<h2 id="resources">Resources<a hidden class="anchor" aria-hidden="true" href="#resources">#</a></h2>
<ul>
<li>官方：
<ul>
<li><a href="https://microsoft.github.io/language-server-protocol/">https://microsoft.github.io/language-server-protocol/</a></li>
</ul>
</li>
<li>非官方博客：
<ul>
<li><a href="https://juejin.cn/post/7051453384645148680">https://juejin.cn/post/7051453384645148680</a></li>
</ul>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://WFUing.github.io/tags/lsp/">lsp</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://WFUing.github.io/posts/tech/algorithm/data-warehouse-mining/overview/">
    <span class="title">下一页 »</span>
    <br>
    <span>数据仓库与知识发现概览</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Language Server Protocol 的工作原理 on twitter"
        href="https://twitter.com/intent/tweet/?text=Language%20Server%20Protocol%20%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&amp;url=https%3a%2f%2fWFUing.github.io%2fposts%2ftech%2flanguage%2flsp%2flsp-principle%2f&amp;hashtags=lsp">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Language Server Protocol 的工作原理 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fWFUing.github.io%2fposts%2ftech%2flanguage%2flsp%2flsp-principle%2f&amp;title=Language%20Server%20Protocol%20%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&amp;summary=Language%20Server%20Protocol%20%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&amp;source=https%3a%2f%2fWFUing.github.io%2fposts%2ftech%2flanguage%2flsp%2flsp-principle%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Language Server Protocol 的工作原理 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fWFUing.github.io%2fposts%2ftech%2flanguage%2flsp%2flsp-principle%2f&title=Language%20Server%20Protocol%20%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Language Server Protocol 的工作原理 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fWFUing.github.io%2fposts%2ftech%2flanguage%2flsp%2flsp-principle%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Language Server Protocol 的工作原理 on whatsapp"
        href="https://api.whatsapp.com/send?text=Language%20Server%20Protocol%20%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%20-%20https%3a%2f%2fWFUing.github.io%2fposts%2ftech%2flanguage%2flsp%2flsp-principle%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Language Server Protocol 的工作原理 on telegram"
        href="https://telegram.me/share/url?text=Language%20Server%20Protocol%20%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&amp;url=https%3a%2f%2fWFUing.github.io%2fposts%2ftech%2flanguage%2flsp%2flsp-principle%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Language Server Protocol 的工作原理 on ycombinator"
        href="https://news.ycombinator.com/submitlink?t=Language%20Server%20Protocol%20%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&u=https%3a%2f%2fWFUing.github.io%2fposts%2ftech%2flanguage%2flsp%2flsp-principle%2f">
        <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
            xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
            <path
                d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
        </svg>
    </a>
</div>

  </footer>
<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>
    <div id="tcomment"></div>
    <script src="https://cdn.staticfile.org/twikoo/1.4.11/twikoo.all.min.js"></script>
    <script>
        twikoo.init({
            envId: "https://twikoo-api-three-gamma.vercel.app/",  
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou',  
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        });
    </script>
</div>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://WFUing.github.io/">Waiting For You</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
