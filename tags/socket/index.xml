<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Socket on WFUing&#39;s Blog</title>
    <link>https://WFUing.github.io/tags/socket/</link>
    <description>Recent content in Socket on WFUing&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© 2024 WFUing</copyright>
    <lastBuildDate>Thu, 14 Mar 2024 13:19:27 +0800</lastBuildDate><atom:link href="https://WFUing.github.io/tags/socket/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Socket 编程</title>
      <link>https://WFUing.github.io/posts/reviews/network/socket/</link>
      <pubDate>Thu, 14 Mar 2024 13:19:27 +0800</pubDate>
      
      <guid>https://WFUing.github.io/posts/reviews/network/socket/</guid>
      <description>针对 TCP 应该如何 Socket 编程？ # 服务端和客户端初始化 socket，得到文件描述符； 服务端调用 bind，将 socket 绑定在指定的 IP 地址和端口; 服务端调用 listen，进行监听； 服务端调用 accept，等待客户端连接； 客户端调用 connect，向服务端的地址和端口发起连接请求； 服务端 accept 返回用于传输的 socket 的文件描述符； 客户端调用 write 写入数据；服务端调用 read 读取数据； 客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。 这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</description>
      <media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://WFUing.github.io/posts/reviews/network/socket/featured.png" />
    </item>
    
  </channel>
</rss>
