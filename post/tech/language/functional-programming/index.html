<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Functional Programming | Waiting For You</title>
<meta name="keywords" content="functional programming, language">
<meta name="description" content="我们将注意力转向过程抽象，这是一种将复杂程序分解成 functions (也称为 procedures 或 subroutines 。这些术语在不同语境中的用法有细微差别，但就我们的目的而言，我们将把它们视为同义词) 形式的较小代码片段的策略。函数将某些计算封装在一个接口之后，与任何抽象概念一样，函数的用户只需知道函数做了什么，而不需要知道函数是如何完成计算的。函数还通过接收影响其计算的参数来概括计算。计算的结果就是函数的返回值。
在本单元中，我们首先介绍 Lisp 家族中的函数式语言 Scheme。然后，我们将讨论与所有 procedural languages 相关的函数方面的问题，然后再仔细研究 functional programming，这是一种以数学函数为计算模型的编程范式。
Introduction to Scheme R5RS Scheme 语言采用了与 Python 非常相似的计算模型，但只使用 expressions (不使用statements)，擅长 symbolic computation。
Scheme 是 Lisp 的一种方言，Lisp 是当今仍在广泛使用的第二古老的编程语言（仅次于 Fortran）。几十年来，Lisp 程序员社区一直在蓬勃发展，而新的 Lisp 方言（如 Clojure）也是所有现代编程语言中开发者社区发展最快的。要跟上本文的示例，可以下载 Scheme 解释器或使用在线解释器。
Expressions Scheme 程序由 expressions 组成，expressions 可以是简单表达式，也可以是列表形式的组合。简单表达式由一个文字或符号组成。组合表达式是一种 compound expression，由一个运算符表达式和零个或多个操作数子表达式组成。运算符和操作数都包含在括号中：
1 2 &gt; (quotient 10 2) 5 Scheme 只使用前缀符号。操作符通常是符号，如 &#43; 和 *。复合表达式可以嵌套，也可以跨一行以上：
1 2 3 4 5 6 7 8 9 10 11 12 &gt; (&#43; (* 3 5) (- 10 6)) 19 &gt; (&#43; (* 3 (&#43; (* 2 4) (&#43; 3 5) ) ) (&#43; (- 10 7) 6 ) ) 57 对组合进行求值时，首先需要检查运算符是否代表 special form，因为 special form 有自己的求值程序。如果运算符不是 special form，那么运算符和操作数表达式将按照任意顺序进行求值。然后，作为运算符值的函数将应用于作为操作数值的参数。">
<meta name="author" content="WFUing">
<link rel="canonical" href="https://WFUing.github.io/post/tech/language/functional-programming/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.078343916625d121842bb25d5797d26510dec739246c5291e7aa1c8bdfed3a34.css" integrity="sha256-B4NDkWYl0SGEK7JdV5fSZRDexzkkbFKR56oci9/tOjQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://WFUing.github.io/img/logo.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://WFUing.github.io/img/logo.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://WFUing.github.io/img/logo.gif">
<link rel="apple-touch-icon" href="https://WFUing.github.io/logo.gif">
<link rel="mask-icon" href="https://WFUing.github.io/logo.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
    processEscapes: true,
    processEnvironments: true,
    autoload: {
      color: [],
      colorv2: ['color']
    },
    packages: {'[+]': ['noerrors']}
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/noerrors']
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>
<meta property="og:title" content="Functional Programming" />
<meta property="og:description" content="我们将注意力转向过程抽象，这是一种将复杂程序分解成 functions (也称为 procedures 或 subroutines 。这些术语在不同语境中的用法有细微差别，但就我们的目的而言，我们将把它们视为同义词) 形式的较小代码片段的策略。函数将某些计算封装在一个接口之后，与任何抽象概念一样，函数的用户只需知道函数做了什么，而不需要知道函数是如何完成计算的。函数还通过接收影响其计算的参数来概括计算。计算的结果就是函数的返回值。
在本单元中，我们首先介绍 Lisp 家族中的函数式语言 Scheme。然后，我们将讨论与所有 procedural languages 相关的函数方面的问题，然后再仔细研究 functional programming，这是一种以数学函数为计算模型的编程范式。
Introduction to Scheme R5RS Scheme 语言采用了与 Python 非常相似的计算模型，但只使用 expressions (不使用statements)，擅长 symbolic computation。
Scheme 是 Lisp 的一种方言，Lisp 是当今仍在广泛使用的第二古老的编程语言（仅次于 Fortran）。几十年来，Lisp 程序员社区一直在蓬勃发展，而新的 Lisp 方言（如 Clojure）也是所有现代编程语言中开发者社区发展最快的。要跟上本文的示例，可以下载 Scheme 解释器或使用在线解释器。
Expressions Scheme 程序由 expressions 组成，expressions 可以是简单表达式，也可以是列表形式的组合。简单表达式由一个文字或符号组成。组合表达式是一种 compound expression，由一个运算符表达式和零个或多个操作数子表达式组成。运算符和操作数都包含在括号中：
1 2 &gt; (quotient 10 2) 5 Scheme 只使用前缀符号。操作符通常是符号，如 &#43; 和 *。复合表达式可以嵌套，也可以跨一行以上：
1 2 3 4 5 6 7 8 9 10 11 12 &gt; (&#43; (* 3 5) (- 10 6)) 19 &gt; (&#43; (* 3 (&#43; (* 2 4) (&#43; 3 5) ) ) (&#43; (- 10 7) 6 ) ) 57 对组合进行求值时，首先需要检查运算符是否代表 special form，因为 special form 有自己的求值程序。如果运算符不是 special form，那么运算符和操作数表达式将按照任意顺序进行求值。然后，作为运算符值的函数将应用于作为操作数值的参数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://WFUing.github.io/post/tech/language/functional-programming/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-10-18T20:14:26+08:00" />
<meta property="article:modified_time" content="2023-10-18T20:14:26+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Functional Programming"/>
<meta name="twitter:description" content="我们将注意力转向过程抽象，这是一种将复杂程序分解成 functions (也称为 procedures 或 subroutines 。这些术语在不同语境中的用法有细微差别，但就我们的目的而言，我们将把它们视为同义词) 形式的较小代码片段的策略。函数将某些计算封装在一个接口之后，与任何抽象概念一样，函数的用户只需知道函数做了什么，而不需要知道函数是如何完成计算的。函数还通过接收影响其计算的参数来概括计算。计算的结果就是函数的返回值。
在本单元中，我们首先介绍 Lisp 家族中的函数式语言 Scheme。然后，我们将讨论与所有 procedural languages 相关的函数方面的问题，然后再仔细研究 functional programming，这是一种以数学函数为计算模型的编程范式。
Introduction to Scheme R5RS Scheme 语言采用了与 Python 非常相似的计算模型，但只使用 expressions (不使用statements)，擅长 symbolic computation。
Scheme 是 Lisp 的一种方言，Lisp 是当今仍在广泛使用的第二古老的编程语言（仅次于 Fortran）。几十年来，Lisp 程序员社区一直在蓬勃发展，而新的 Lisp 方言（如 Clojure）也是所有现代编程语言中开发者社区发展最快的。要跟上本文的示例，可以下载 Scheme 解释器或使用在线解释器。
Expressions Scheme 程序由 expressions 组成，expressions 可以是简单表达式，也可以是列表形式的组合。简单表达式由一个文字或符号组成。组合表达式是一种 compound expression，由一个运算符表达式和零个或多个操作数子表达式组成。运算符和操作数都包含在括号中：
1 2 &gt; (quotient 10 2) 5 Scheme 只使用前缀符号。操作符通常是符号，如 &#43; 和 *。复合表达式可以嵌套，也可以跨一行以上：
1 2 3 4 5 6 7 8 9 10 11 12 &gt; (&#43; (* 3 5) (- 10 6)) 19 &gt; (&#43; (* 3 (&#43; (* 2 4) (&#43; 3 5) ) ) (&#43; (- 10 7) 6 ) ) 57 对组合进行求值时，首先需要检查运算符是否代表 special form，因为 special form 有自己的求值程序。如果运算符不是 special form，那么运算符和操作数表达式将按照任意顺序进行求值。然后，作为运算符值的函数将应用于作为操作数值的参数。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://WFUing.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Technology",
      "item": "https://WFUing.github.io/post/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Language",
      "item": "https://WFUing.github.io/post/tech/language/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Functional Programming",
      "item": "https://WFUing.github.io/post/tech/language/functional-programming/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Functional Programming",
  "name": "Functional Programming",
  "description": "我们将注意力转向过程抽象，这是一种将复杂程序分解成 functions (也称为 procedures 或 subroutines 。这些术语在不同语境中的用法有细微差别，但就我们的目的而言，我们将把它们视为同义词) 形式的较小代码片段的策略。函数将某些计算封装在一个接口之后，与任何抽象概念一样，函数的用户只需知道函数做了什么，而不需要知道函数是如何完成计算的。函数还通过接收影响其计算的参数来概括计算。计算的结果就是函数的返回值。\n在本单元中，我们首先介绍 Lisp 家族中的函数式语言 Scheme。然后，我们将讨论与所有 procedural languages 相关的函数方面的问题，然后再仔细研究 functional programming，这是一种以数学函数为计算模型的编程范式。\nIntroduction to Scheme R5RS Scheme 语言采用了与 Python 非常相似的计算模型，但只使用 expressions (不使用statements)，擅长 symbolic computation。\nScheme 是 Lisp 的一种方言，Lisp 是当今仍在广泛使用的第二古老的编程语言（仅次于 Fortran）。几十年来，Lisp 程序员社区一直在蓬勃发展，而新的 Lisp 方言（如 Clojure）也是所有现代编程语言中开发者社区发展最快的。要跟上本文的示例，可以下载 Scheme 解释器或使用在线解释器。\nExpressions Scheme 程序由 expressions 组成，expressions 可以是简单表达式，也可以是列表形式的组合。简单表达式由一个文字或符号组成。组合表达式是一种 compound expression，由一个运算符表达式和零个或多个操作数子表达式组成。运算符和操作数都包含在括号中：\n1 2 \u0026gt; (quotient 10 2) 5 Scheme 只使用前缀符号。操作符通常是符号，如 + 和 *。复合表达式可以嵌套，也可以跨一行以上：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt; (+ (* 3 5) (- 10 6)) 19 \u0026gt; (+ (* 3 (+ (* 2 4) (+ 3 5) ) ) (+ (- 10 7) 6 ) ) 57 对组合进行求值时，首先需要检查运算符是否代表 special form，因为 special form 有自己的求值程序。如果运算符不是 special form，那么运算符和操作数表达式将按照任意顺序进行求值。然后，作为运算符值的函数将应用于作为操作数值的参数。",
  "keywords": [
    "functional programming", "language"
  ],
  "articleBody": "我们将注意力转向过程抽象，这是一种将复杂程序分解成 functions (也称为 procedures 或 subroutines 。这些术语在不同语境中的用法有细微差别，但就我们的目的而言，我们将把它们视为同义词) 形式的较小代码片段的策略。函数将某些计算封装在一个接口之后，与任何抽象概念一样，函数的用户只需知道函数做了什么，而不需要知道函数是如何完成计算的。函数还通过接收影响其计算的参数来概括计算。计算的结果就是函数的返回值。\n在本单元中，我们首先介绍 Lisp 家族中的函数式语言 Scheme。然后，我们将讨论与所有 procedural languages 相关的函数方面的问题，然后再仔细研究 functional programming，这是一种以数学函数为计算模型的编程范式。\nIntroduction to Scheme R5RS Scheme 语言采用了与 Python 非常相似的计算模型，但只使用 expressions (不使用statements)，擅长 symbolic computation。\nScheme 是 Lisp 的一种方言，Lisp 是当今仍在广泛使用的第二古老的编程语言（仅次于 Fortran）。几十年来，Lisp 程序员社区一直在蓬勃发展，而新的 Lisp 方言（如 Clojure）也是所有现代编程语言中开发者社区发展最快的。要跟上本文的示例，可以下载 Scheme 解释器或使用在线解释器。\nExpressions Scheme 程序由 expressions 组成，expressions 可以是简单表达式，也可以是列表形式的组合。简单表达式由一个文字或符号组成。组合表达式是一种 compound expression，由一个运算符表达式和零个或多个操作数子表达式组成。运算符和操作数都包含在括号中：\n1 2 \u003e (quotient 10 2) 5 Scheme 只使用前缀符号。操作符通常是符号，如 + 和 *。复合表达式可以嵌套，也可以跨一行以上：\n1 2 3 4 5 6 7 8 9 10 11 12 \u003e (+ (* 3 5) (- 10 6)) 19 \u003e (+ (* 3 (+ (* 2 4) (+ 3 5) ) ) (+ (- 10 7) 6 ) ) 57 对组合进行求值时，首先需要检查运算符是否代表 special form，因为 special form 有自己的求值程序。如果运算符不是 special form，那么运算符和操作数表达式将按照任意顺序进行求值。然后，作为运算符值的函数将应用于作为操作数值的参数。\n在 Scheme 中，if 表达式是特殊形式的一个例子。虽然它在语法上看起来与调用表达式相似，但它的评估过程却与调用表达式不同。if 表达式的一般形式是\n1 (if ) 要对 if 表达式进行求值，解释器首先会对表达式的 部分进行求值。如果 求值为 true，解释器将求值 并返回其值。否则，解释器将求值 ，并返回其值，可省略。\nNumerical values 可以使用熟悉的比较运算符进行比较，但在这种情况下也使用 prefix notation：\n1 2 \u003e (\u003e= 2 1) #t 在 Scheme 中，真值 (包括布尔值 #t 表示真， #f 表示假) 可以与布尔特殊形式相结合，它们的求值过程如下：\n(and ... ) 解释器按从左到右的顺序逐次求值表达式 。如果任何 的值为 false，则 and 表达式的值就是该 false，其余 的值不予求值。如果所有 的值都为 true，那么 and 表达式的值就是最后一个 的值。 (or ... ) 解释器按从左到右的顺序，一次评估一个 表达式。如果任何 的值为 true，该值将作为 or 表达式的值返回，其余的 将不被求值。如果所有 的值都为 false，则 or 表达式的值就是最后一个 的值。 true 也可以用 not 程序来处理：\n(not ) 当表达式 的值为假值时，not 表达式的值为 #t，否则为 #f。 Definitions 可以使用 define 特殊形式对值进行命名：\n1 2 3 \u003e (define pi 3.14) \u003e (* pi 2) 6.28 新函数（在 Scheme 中通常称为 procedures）可以使用 define 特殊形式的第二个版本来定义。例如，要定义平方，我们可以写下\n1 (define (square x) (* x x)) 程序定义的一般形式是\n1 (define ( ) ) 是与环境中存储过程定义相关联的符号。 是存储过程正文中使用的名称，用于指代存储过程的相应参数。 是一个表达式，当形式参数被存储过程的实际参数替换时，它将产生存储过程应用的值。 和 放在括号中，就像在实际调用存储过程时一样。 定义了 square 之后，我们就可以在调用表达式中使用它了:\n1 2 3 4 5 6 7 8 \u003e (square 21) 441 \u003e (square (+ 2 5)) 49 \u003e (square (square 3)) 81 用户自定义函数可以接受多个参数，并在函数体中包含特殊形式：\n1 2 3 4 5 6 7 8 9 10 11 12 \u003e (define (average x y) (/ (+ x y) 2)) \u003e (average 1 3) 2 \u003e (define (abs x) (if (\u003c x 0) (- x) x ) ) \u003e (abs -3) 3 Scheme 支持具有 static scope 的局部函数定义。我们将推迟到讨论高阶函数时再讨论这个问题。\n匿名函数也称为 lambda 函数，是使用 lambda 特殊形式创建的。使用 lambda 创建存储过程的方法与定义相同，只是不指定存储过程的名称：\n1 (lambda () ) 由此产生的存储过程与使用 define 创建的存储过程一样。唯一不同的是，它没有与环境中的任何名称相关联。事实上，下面的表达式是等价的：\n1 2 \u003e (define (plus4 x) (+ x 4)) \u003e (define plus4 (lambda (x) (+ x 4))) 与任何以 procedure 为值的表达式一样，lambda 表达式也可以用作 call expression 中的操作符：\n1 2 \u003e ((lambda (x y z) (+ x y (square z))) 1 2 3) 12 Compound Values Pairs 是内置于 Scheme 语言中的。由于历史原因，Pairs 使用 cons 内置函数创建，因此，Pairs 也被称为 cons 单元，Pairs 中的元素使用 car 和 cdr 访问：\n1 2 3 4 5 6 7 \u003e (define x (cons 1 2)) \u003e x (1 . 2) \u003e (car x) 1 \u003e (cdr x) 2 A pair consisting of the elements 1 and 2 该语言还使用成对的方式建立 Recursive lists 。用 '() 表示的特殊值代表 empty list。递归列表值的呈现方式是将其元素放在括号内，中间用空格隔开：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u003e (cons 1 (cons 2 (cons 3 (cons 4 '()) ) ) ) (1 2 3 4) \u003e (list 1 2 3 4) (1 2 3 4) \u003e (define one-through-four (list 1 2 3 4)) \u003e (car one-through-four) 1 \u003e (cdr one-through-four) (2 3 4) \u003e (car (cdr one-through-four)) 2 \u003e (cons 10 one-through-four) (10 1 2 3 4) \u003e (cons 5 one-through-four) (5 1 2 3 4) 下图为文本表示为 (1 2 3 4) 的列表对应的结构由一连串的对组成，以空列表在图中表示为包含符号 $\\emptyset$：\nA list containing the elements 1, 2, 3, and 4 以空列表以外的其他元素结束的数对序列称为 improper list。如上面的 (cons 1 2) 的结果就是一个例子，它只包含序列中的 pair。下面演示的是一个更复杂的序列：\n1 2 3 4 5 6 \u003e (cons 1 (cons 2 (cons 3 4) ) ) (1 2 3 . 4) An improper list containing the elements 1, 2, and 3, and terminated by 4 rather than the empty list 证明了 pairs 和其他 compound objects 具有引用语义 – 配对的 cdr 部分存储了对序列中下一对配对的引用。下面的代码通过变量进一步演示了这些引用语义：\n1 2 3 4 5 6 7 \u003e (define x (cons 1 2)) \u003e (define y x) \u003e (eqv? x y) #t \u003e (set-car! y 7) \u003e x (7 . 2) 在这里，定义 (define y x) 的结果是 x 和 y 指向同一个数据 pair object。只有当两个参数指向同一个对象对时，存储过程 eqv? 才会返回 true（而 equal? 则从结构上对对象对进行比较）。此外，当我们使用 set-car! 变量修改 y 所引用的配对的第一个项目时，我们可以看到 x 引用了同一个配对，因为它也显示了修改。\n一个对象是否为空列表，可以使用原始的 null? 。利用它，我们可以定义用于计算适当列表长度和选择元素的标准序列操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u003e (define (list-length items) (if (null? items) 0 (+ 1 (list-length (cdr items))) ) ) \u003e (define (getitem items n) (if (= n 0) (car items) (getitem (cdr items) (- n 1)) ) ) \u003e (define squares (list 1 4 9 16 25)) \u003e (length squares) 5 \u003e (getitem squares 3) 16 内置的 length 和 list-ref 程序提供了与这里的 list-length 和 getitem 相同的功能。\nSymbolic Data 我们迄今为止使用过的所有复合数据对象最终都是由数字构建的。使用任意符号作为数据是 Scheme 的优势之一。\n为了操作符号，我们需要在语言中加入一个新元素：引用数据对象的能力。假设我们要构造列表 (a b)。我们不能用 (list a b) 来实现这个目的，因为这个表达式构造的是一个包含 a 和 b 值的列表，而不是符号本身。在 Scheme 中，我们会在符号 a 和 b 之前加上单引号，来指代它们，而不是它们的值：\n1 2 3 4 5 6 7 8 \u003e (define a 1) \u003e (define b 2) \u003e (list a b) (1 2) \u003e (list 'a 'b) (a b) \u003e (list 'a b) (a 2) 在 Scheme 中，任何未被求值的表达式都被称为 quoted。引号的概念源于一个经典的哲学，即一个事物，如到处乱跑并吠叫的狗与 “狗” 这个词之间的区别，“狗” 这个词是用于指定此类事物的语言结构。当我们使用带引号的 “狗” 时，我们指的并不是某只狗，而是一个词。在语言中，引号允许我们谈论语言本身，在 Scheme 中也是如此：\n1 2 \u003e (list 'define 'list) (define list) 引号还允许我们使用传统的列表打印表示法键入复合对象。我们已经看到，'() 表示空列表。下面是其他例子：\n1 2 3 4 5 \u003e (car '(a b c)) a \u003e (cdr '(a b c)) (b c) Scheme 中的引号与字符串不同，后者表示字符格式的原始、非结构化数据，而前者表示结构化数据。\n1 2 3 4 5 6 7 8 9 10 \u003e \"(- 3)\" ; a string containing the characters #\\( #\\- #\\space #\\3 #\\) \"(- 3)\" \u003e '(- 3) ; produces a list containing the symbol - and number 3 (- 3) \u003e (car '(- 3)) - \u003e (cdr '(- 3)) (3) \u003e (- 3) ; calls the - procedure on the number 3 -3 在上面的示例中，字符串字面形式 \"(- 3)\" 的值为其本身，带引号的表达式 '(- 3) 求值为一个列表，列表的第一个元素是符号 -，第二个元素是数字 3。最后一个示例对符号 - 进行求值以获得相应的存储过程，将数字 3 求值为自身，然后在数字 3 上调用存储过程 -，得到 -3。换句话说，字符串字面量中的数据仍然是字符数据，既不会被求值，也不会被解析。带引号表达式会被解析，但不会被求值，而是产生数据的结构化表示。未加引号的表达式会被解释器解析和求值。\n完整的 Scheme 语言还包含其他功能，如 mutation operations、vectors 和 maps。不过，我们迄今为止介绍的子集提供了一种丰富的函数式编程语言，能够实现我们迄今为止讨论过的许多想法。\nFunctions 我们首先要考虑的是以参数形式向函数传递数据的各种方案。我们将出现在函数定义中的参数，也称为 formal parameters，与调用函数时传递给函数的实际值区分开来，后者通常被称为 actual parameter。\n本文将使用 argument 一词来指代 actual parameter， 用 parameter 一词指代 formal parameters。 Keyword Arguments 有些语言允许甚至要求在调用函数时提供参数名，这种策略称为 named parameters 或 keyword arguments。\n关键字参数通常允许以不同于函数参数列表的顺序提供参数。例如，在 Python 中，keyword argument 可以用于任何参数。请看下面的代码：\n1 2 def foo(x, y): print(x, y) 调用不带关键字参数的 foo() 时，第一个参数会作为第一个参数传递，第二个参数会作为第二个参数传递：\n1 2 \u003e\u003e\u003e foo(1, 2) 1 2 不过，参数可以使用参数名重新排序：\n1 2 \u003e\u003e\u003e foo(y = 1, x = 2) 2 1 Python 还提供了将参数定义为 positional-only 或 keyword-only 的机制，但我们不会在这里讨论这些机制。\n有少数语言要求默认为所有或大部分参数提供名称，并要求以与参数相同的顺序提供参数。下面是 Swift 3 中的一个示例：\n1 2 3 4 5 func greet(name: String, withGreeting: String) { print(withGreeting + \" \" + name) } greet(name: \"world\", withGreeting: \"hello\") 以相反的参数顺序调用 greet() 是错误的。\nSwift 允许为一个参数指定不同的参数名和参数名，这一点也很罕见。这意味着调用函数时为参数提供的名称可能与函数主体中使用的参数内部名称不同。\nDefault Arguments 在某些语言中，函数声明或定义可能会提供一个 default argument，允许在没有该参数的情况下调用函数。这可以替代重载，即编写单独的函数定义来处理存在或缺少参数的情况。\n下面是一个 Python 示例：\n1 2 def power(base, exponent=2): return base ** exponent power() 函数可以调用一个参数，在这种情况下，默认参数 2 用于计算数字的平方。也可以使用两个参数来计算任意幂：\n1 2 3 4 \u003e\u003e\u003e power(3) 9 \u003e\u003e\u003e power(3, 4) 81 有 default arguments 一般必须出现在参数列表的末尾。对于何时以及在哪种环境下评估默认参数，不同语言的做法各不相同。最常见的策略是每次调用函数时都评估缺省参数，但在定义 environment (static scope) 中进行。Python 的罕见之处在于，它只在函数定义语句执行时评估一次缺省参数。这意味着，如果在函数中修改了参数值，那么对同一函数的后续调用可能会对同一参数使用不同的缺省值。例如\n1 2 3 4 5 6 7 8 9 10 def test(x=[]): x.append(1) print(x) test() test() // output [1] [1, 1] C 和 C++ 有许多关于缺省参数的规则，这是因为一个实体可以声明多次。默认参数既可以在独立声明中提供，也可以在定义中提供。但是，同一实体的多个可见声明为同一参数提供默认参数是非法的，即使提供的值是相同的。缺省参数集是同一作用域内所有可见声明的集合，只有在前面和当前声明已为所有后续参数提供缺省参数的情况下，声明才能为参数引入缺省参数。缺省参数中使用的名称在声明时进行解析，但参数表达式在调用函数时进行求值。\n下面是 C++ 中多重声明的一个合法示例：\n1 2 3 4 int foo(int x, int y = 4); int foo(int x = 3, int y) { return x + y; } 除函数参数外，C++ 还允许模板参数使用默认参数，其有效性规则与此类似。\nVariadic Functions 一种语言可能会提供一种机制，让函数在调用时可以使用数量可变的参数。这种特性通常被称为 varargs，使用这种特性的函数被称为变量函数 (variadic)。这种机制可能提供类型安全，也可能允许不安全的使用，从而导致错误或未定义的行为。可变参数一般必须出现在参数列表的末尾，它匹配的是非可变参数匹配后剩余的参数。通常只允许使用一个变量参数。\n在提供安全变量函数的语言中，一种常见的机制是自动将变量参数打包到一个 container 中，例如 array 或 tuple。例如，下面的 Python 函数计算其参数的乘积：\n1 2 3 4 5 def product(*args): result = 1 for i in args: result *= i return result 参数名前面的 * 表示变量参数，变量参数以绑定到参数名的元组形式传递。上述函数遍历元组中的元素，更新总乘积。要调用 product()，必须提供 0 个或更多参数：\n1 2 3 4 \u003e\u003e\u003e product() 1 \u003e\u003e\u003e product(1, 2, 3) 6 Python 还提供了可变关键字参数，这些参数被打包成一个字典。在参数前面加上 ** 表示它是一个可变关键字参数，并且这样的参数必须是最后一个。例如，下面的函数同时包含一个非关键字可变参数和一个可变关键字参数，打印出前者对应的元组和后者对应的字典：\n1 2 3 def print_args(*args, **kwargs): print(args) print(kwargs) 1 2 3 \u003e\u003e\u003e print_args(3, 4, x = 5, y = 6) (3, 4) {'x': 5, 'y': 6} 最后，Python 允许使用 * 或 ** 操作符对序列或字典进行 “解包”，从而将解包后的值用于需要值列表的地方。例如，下面的代码将一个列表解包，以调用 product()：\n1 2 product(*[1, 2, 3]) 6 此外，Scheme 还支持可变参数。一个存储过程可以使用一个不恰当的列表作为参数列表，并以一个符号而不是空列表结束，这样就可以定义一个存储过程来接受可变参数。可变参数与任意数量的参数绑定，并打包成一个列表：\n1 2 3 4 5 6 7 \u003e (define (func . args) args ) \u003e (func) () \u003e (func 1 2 3) (1 2 3) 存储过程 func 可以接收任意数量的参数，并返回包含这些参数的 list。因此，它的行为与内置的 list 存储过程相同。我们还可以定义一个存储过程，同时接收必参数和可变参数，例如下面的 average 定义：\n1 2 3 4 5 6 7 8 9 10 11 \u003e (define (average x . nums) (/ (apply + x nums) (+ 1 (length nums)) ) ) \u003e (average 1) 1 \u003e (average 1 3) 2 \u003e (average 1 3 5 7) 4 procedure 接收一个或多个参数，其中第一个参数与参数 x 绑定，其余参数封装在一个与变量 nums 参数绑定的列表中。我们可以使用 apply 来转发变量参数，它接收一个存储过程、任意数量的常规参数，最后是一个包含其余参数的列表。例如，(apply + 1 2 '(3 4)) 相当于调用 (+ 1 2 3 4)。在上面第一个使用 average 的示例中，nums 在调用 (average 1) 时绑定为一个空列表，而 (apply + x nums) 相当于 (apply + 1 '()) ，后者本身相当于 (+ 1)。在第三个例子中，nums 绑定到一个列表 (3 5 7)，因此 (apply + x nums) 等价于 (apply + 1 '(3 5 7))，而 (apply + 1 '(3 5 7)) 又等价于 (+ 1 3 5 7)。\n在 Python 和 Scheme 中，可变参数可以匹配任何类型的参数，因为这两种语言都是动态类型的。然而，在静态类型语言中，可变参数通常被限制为单一类型，尽管该类型可能是多态的。例如，下面是 Java 中的一个变量方法：\n1 2 3 4 5 public static void print_all(String... args) { for (String s : args) { System.out.println(s); } } print_all() 的参数必须是字符串，并将它们打包成一个字符串数组。Java 也允许将单个字符串数组作为参数传递：\n1 2 print_all(\"hello\", \"world\"); print_all(new String[] { \"good\", \"bye\" }); C 和 C++ 也有一种可变参数机制，但它存在严重的安全问题。尤其是，它无法向被调用的函数提供关于参数个数及其类型的信息。下面是一个返回参数之和的函数示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include int sum(int count, ...) { va_list args; int total = 0; int i; va_start(args, count); for (i = 0; i \u003c count; i++) { total += va_arg(args, int); } va_end(args); return total; } 在该函数中，第一个参数被假定为其余参数的个数，而后一个参数被假定为 int 类型。如果违反其中任何一个条件，都会产生未定义的行为。另一种策略是使用格式字符串来确定参数的数量和类型，如 printf() 和类似函数中使用的方法。可变参数缺乏安全性，会导致格式字符串攻击等漏洞。\nC++11 提供了类型安全的 variadic templates。\nParameter Passing 语言的另一个不同之处在于函数与其调用者之间传递参数的 semantics 和 mechanism。函数参数可以是单向的，仅用于向函数传递输入或仅用于从函数向调用者传递输出，也可以是双向的。这些情况被称为 input、output 和 input/output 参数。一种语言不必支持所有三种参数类别。\n各种语言使用不同的参数传递技术或调用模式。这些技术会影响参数和参数的语义以及支持的参数类别。以下是不同语言使用的具体调用模式：\nCall by value，参数代表函数调用框架中的一个新变量。参数值被复制到与新变量相关的存储空间中。按值调用参数只为函数提供输入，如下面的 C++ 示例：\n1 2 3 4 5 6 7 8 9 10 void foo(int x) { x++; cout \u003c\u003c x \u003c\u003c endl; } int main() { int y = 3; foo(y); // prints 4 cout \u003c\u003c y \u003c\u003c endl; // prints 3 } 即使 foo() 修改了输入值，修改后的值也不会传回 caller。\nCall by reference，参数必须传递一个 l-value，因为参数 aliases 了传递进来的对象。对参数的任何修改都会反映在参数对象中。因此，引用调用参数同时提供输入和输出。在 C++ 中，引用参数提供了引用调用，并且可以通过声明 const 将其限制为仅提供输入。下面的 C++ 示例使用引用调用交换了两个对象的值：\n1 2 3 4 5 6 7 8 9 10 11 void swap(int \u0026x, int \u0026y) { int tmp = x; x = y; y = tmp; } int main() { int x = 3, y = 4; swap(x, y); cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; // prints 4 3 } 引用调用有时用来指使用指针间接传递对象。下面的 C/C++ 函数使用指针交换对象值：\n1 2 3 4 5 6 7 8 9 10 11 void swap(int *x, int *y) { int tmp = *x; *x = *y; *y = tmp; } int main() { int x = 3, y = 4; swap(\u0026x, \u0026y); printf(\"%d %d\\n\", x, y); // prints 4 3 } 但从技术上讲，参数和参量是独立的指针对象，通过值传递。尽管如此，这种效果模拟了引用调用，使输入和输出都能通过一个参数来实现。\nCall by result，在这种模式下，参数代表一个新变量，调用者不对其进行初始化。相反，调用者会为参数指定一个 l-value，当函数调用结束时，参数的最终值会被复制到 l-value 中。因此，按结果调用只提供输出参数。下面是一个使用类似 C 的语法、按结果调用的示例：\n1 2 3 4 5 6 7 8 void foo(result int x) { x = 3; x++; // x is now 4 } int y = 5; foo(y); // y is now 4 print(y); // prints 4 Call by value-result，这是 Call by value 和 Call by result 的组合。参数值被复制到与参数相对应的新变量中，然后从函数返回时，参数值又被复制到调用者提供的 l-value 值中。这与引用调用的不同之处在于，在进入和退出函数时都会进行复制。可以通过将相同的 l-value 传递给多个参数来说明这一点，例如在下面的示例中使用了类似于 C 语言的语法，即按 Call by value-result：\n1 2 3 4 5 6 7 8 int foo(value-result int x, value-result int y) { x++; return x - y; } int z = 3; print(foo(z, z)); // prints 1 print(z); // prints 3 or 4, depending on the semantics 在这段代码中，x 和 y 是新变量，它们被初始化为 z 的值，即 3。x 的增量不会影响 y，因为它们是独立的变量，所以调用 foo() 返回 1。因此，1 会被打印出来。z 的最终值取决于从 x 还是从 y 复制的语言语义。如果使用引用调用，那么 x 和 y 将 alias 为同一个对象，调用 foo() 将返回 0。\nCall by name，在这种模式下，可以提供一个完整的表达式作为参数，但在调用函数时不会对其进行求值。相反，在函数中出现参数名的地方，参数名会被表达式替换，而表达式会在主体中遇到时进行求值。这是一种 lazy evaluation，即在需要时才计算值。下面是一个使用 C-like syntax、按名称调用的示例：\n1 2 3 4 5 6 7 8 9 void foo(name int a, name int b) { print(b); // becomes print(++y) print(b); // becomes print(++y) } int x = -1, y = 3; foo(++x, ++y); // prints 4, then 4 or 5 depending on the exact // language semantics; y is now 4 or 5 print(x); // prints -1 -- x is unchanged 在本例中，参数表达式 ++x 从未被求值，因为相应的逐名调用参数 a 从未被使用。另一方面，表达式 ++y 被计算，因为相应的参数 b 确实被使用了。根据语言语义的不同，表达式可能只被求值一次，其值被缓存以备后续使用，也可能在每次使用参数时都被求值。\n按名称调用会产生一个微妙的问题。请看下面这段代码，它使用了 C-like syntax 和按名称调用：\n1 2 3 4 5 6 7 void bar(name int x) { int y = 3; print(x + y); } int y = 1; bar(y + 1); 如果我们用参数表达式替换 bar() 中出现的参数 x，就会得到 y + 1 + y 作为 print() 的参数。如果在 bar() 的环境中求值，结果将是 7。这是不可取的，因为这意味着局部声明 y 的实现细节改变了函数的行为。\n相反，参数表达式应在调用者的环境中进行评估。这就要求在函数调用时同时传递参数及其环境。使用名称调用的语言通常使用编译器生成的局部函数，称为 thunk ，来封装参数表达式及其环境。然后将 thunk 传递给被调用的函数，当遇到参数时，就会调用 thunk。\n在某些语言中，与 call-by-name parameter 相对应的表达式仅在首次引用该参数时进行评估，并缓存评估结果。缓存的结果将用于随后每次出现的参数。\ncall by value 是大多数现代语言使用的调用模式，包括 C、C++（用于非引用参数）、Java、Scheme 和 Python。程序员经常误以为后三种语言使用 call by reference，但实际上，它们将 call by value 与 call by reference 语义结合在一起。这种组合有时被称为 object reference 。下面的示例说明 Python 使用的是 call by value：\n1 2 3 4 def swap(x, y): tmp = x x = y y = tmp 1 2 3 4 \u003e\u003e\u003e x, y = 1, 2 \u003e\u003e\u003e swap(x, y) \u003e\u003e\u003e x, y (1, 2) 错误的 swap() 函数只是改变了局部变量的值，从而改变了它们所引用的对象，而没有影响作为参数的变量。这表明全局 x 和 y 的存储空间与参数的存储空间是不同的，因此 Python 没有使用引用调用。事实上，Python 甚至不能像 C 和 C++ 指针那样模拟引用调用。\nl-value and r-value l-value 和 r-value 是 C++ 表达式的基础。简单地说，l-value 是对象引用，r-value 是值。l-value 和 r-value 之间的区别在表达式的编写和理解中起着重要作用。\nl-value 是产生对象引用的表达式，例如变量名、数组下标引用、取消引用指针或返回引用的函数调用。l-value 总是有一个定义的存储区域，因此可以获取其地址。 r-value 是指不是 l-value 的表达式。r-value 的例子包括字面量、大多数运算符的结果以及返回非引用的函数调用。r-value 不一定与任何存储空间相关联。 严格来说，函数是一个 l-value，但它的唯一用途是用于调用函数或确定函数的地址。大多数情况下，l-value 指的是对象 l-value。\nEvaluation of Function Calls 下面我们总结一下函数调用的实现过程：\n第一步是确定嵌套函数调用的非本地环境。在使用嵌套函数和静态作用域的语言中，当执行嵌套函数定义本身时，非本地环境的引用会存储在关联的函数对象中。在具有深绑定的动态作用域下，非本地环境是在函数名称被引用时确定的。最后，在浅绑定的动态作用域中，非本地环境是函数被调用时处于活动状态的环境。\n下一步是使用新创建的函数调用激活记录将参数传递给函数。参数在现有环境中进行评估，并按如下方式传递给被调用者：\nCall by value and call by value-result : 对参数进行评估以获得其 r-value。r-value 将被复制到新激活记录中相应参数的存储空间。 Call by reference : 参数的 l-value。相应的参数会绑定到与 l-value 相关的对象上。 Call by result : 参数进行评估，以获得其 l-value 。在新的激活记录中，存储空间会被分配，但不会被初始化。 Call by name : 参数表达式会被打包到一个包含当前环境的 thunk 中。参数绑定到 thunk 的引用上。 一旦参数被传递，调用者的执行就会暂停，而被调用者的主体将在一个由新创建的激活记录和被调用者的非本地环境组成的环境中执行。对于 call by name，根据语言的语义，call by name 参数的出现会在参数第一次被指名或每次被指名时调用相应的 thunk。\n当被调用的函数返回时，其返回值（如果有的话）会被放置在指定的存储位置，通常是在调用者的激活记录中。对于 call-by-result 或 call-by-value-result 参数，参数的当前 r-value 会被复制到与相应函数调用参数的 l-value 相关联的对象中。然后，被调用者的激活记录将被销毁，调用者将在函数调用后恢复执行。函数调用本身的评估结果就是函数的返回值。\nRecursion Recursion 是一种利用函数和函数应用进行重复的机制。它涉及函数直接或间接地调用自身，通常使用在某种意义上比前一个参数 “小 “的参数。递归计算在达到基数时终止，基数是指无需进行任何递归调用即可直接计算出结果的输入。\n一种语言要想达到图灵完备性，只需提供 recursion 和 conditionals 即可。\nActivation Records 在机器上，递归之所以起作用，是因为函数的每次调用都有自己的激活记录，将局部变量映射为值。请看下面的阶乘递归定义：\n1 2 3 4 def factorial(n): if n == 0: return 1 return n * factorial(n - 1) 调用 factorial(4) 会导致五次调用 factorial()，参数从 4 到 0，每次都有自己的激活记录和参数 n 的绑定：\n1 2 3 4 5 factorial(4): n --\u003e 4 factorial(3): n --\u003e 3 factorial(2): n --\u003e 2 factorial(1): n --\u003e 1 factorial(0): n --\u003e 0 Activation records used to compute factorial(4) 在执行 factorial() 主体时查找 n，每次调用都会获得自己的 n 值，而不会受到其他激活记录的影响。\n要使函数调用生效，激活记录需要的不仅仅是参数和局部变量的存储空间。临时值也需要存储在某个地方，由于每个调用都需要自己的临时值存储空间，因此这些临时值通常也要放在激活记录中。调用还需要知道在哪里存储其返回值，通常是在调用者框架中的临时存储区。最后，函数需要知道如何将执行返回给调用者。具体细节不在本文讨论范围之内，但这些信息包括调用者函数调用后的指令地址和调用者激活记录的地址。\n临时对象集可以通过静态方式保守地确定，因此激活记录的大小以及对象在其中的位置都可以在编译时确定。对于上面的 factor()，需要临时存储 n - 1 以及递归调用 factorial() 的结果。递归调用会使用后者在调用程序中的位置来存储其返回值。根据不同的实现，调用 factorial(0) 的激活记录中可能仍然有这些临时对象的空间，即使它们不会被使用。\nTail Recursion 递归计算对函数的每次调用都使用单独的激活记录。存储这些记录所需的空间与激活函数调用的次数成正比。在上面的 factorial(n) 中，当计算达到 factorial(0) 时，所有 n + 1 次调用都同时激活，需要的空间为 O(n)。与之相比，下面的迭代实现使用的空间是恒定的：\n1 2 3 4 5 6 def factorial_iter(n): result = 1 while n \u003e 0: result *= n n -= 1 return result 然而，递归版本的 factorial() 所需的空间并不是使用递归的内在原因，而是函数编写方式的结果。事实上，由于在递归调用之后还需要完成调用的工作，因此在递归调用期间必须保留其激活记录，这就导致了线性空间需求。\n考虑另一种阶乘递推计算方法：\n1 2 3 4 def factorial_tail(n, partial_result = 1): if n == 0: return partial_result return factorial_tail(n - 1, n * partial_result) 请注意，在完成递归调用后，factorial_tail() 函数不做任何工作。这意味着在进行递归调用时，它不再需要存储参数、局部变量或临时对象。此外，由于 factorial(n, k) 直接返回递归调用 factorial(n - 1, n * k) 的结果，因此后者可以将其返回值存储在 factorial(n, k) 的调用者中用于存放 factorial(n, k) 返回值的位置，并直接将执行返回给该调用者。因此，优化后的实现可以为 factorial_tail(n - 1, n * k) 重用 factorial_tail(n, k) 的激活记录空间，因为前者不再需要激活记录。\n这个过程可以推广到任何函数调用，而不仅仅是递归调用。如果函数的调用者直接返回调用值，而不执行任何额外的计算，那么该函数调用就是尾调用。如果一个函数的所有递归调用都是尾调用，那么这个函数就是尾递归函数。因此，factorial_tail() 是尾部递归函数。\n尾递归计算只使用固定数量的激活记录，因此其空间使用量与等效的迭代计算相当。事实上，许多函数式语言并不提供迭代的构造，因为它们可以等效地使用尾递归来表达。这些语言通常要求实现执行尾调用优化，尽可能重复使用激活记录的空间。\n由于尾调用要求在返回后不执行任何计算，因此在语法上看似尾调用的调用可能不是尾调用，因为隐式计算可能发生在函数的末尾。这方面的一个具体例子是基于作用域的资源管理，如下例所示：\n1 2 3 4 5 6 int sum(vector\u003cint\u003e values, int index, int partial_result = 0) { if (values.size() == index) { return 0; } return sum(values, index + 1, partial_result + values[index]) } 虽然这段代码在递归调用后似乎没有进行计算，但本地 vector 对象有一个析构函数，必须在递归调用完成后运行。因此，对 sum() 的递归调用不是尾部调用，该计算也不是尾部递归计算。\n另一种阻碍尾调用优化的情况是，在使用静态作用域并支持高阶函数全部功能的语言中，函数内部包含一个函数定义。嵌套函数需要访问其定义环境，因此如果嵌套函数可以在其外层函数调用完成后或在尾调用中使用，则必须保留该环境。\nHigher-Order Functions first-class entity 是一种支持对语言中的其他 entities 进行操作的 entity，包括作为参数传递、从函数返回和动态创建。\n在 functions 是 first-class entity 的语言中，可以编写 higher-order functions，将另一个 function 作为参数传递或返回一个 function。 其他语言也可能支持 higher-order functions，但是在这些语言中 function 不是可以在运行时动态创建的 entity 。 Function Objects 在某些语言中，可以定义本身不是函数但提供与函数相同接口的对象。这些对象被称为函数对象或函数器。一般来说，语言通过允许重载函数调用操作符来编写函数器。请看下面的 C++ 示例：\n1 2 3 4 5 6 7 8 9 10 11 class Counter { public: Counter : count(0) {} int operator()() { return count++; } private: int count; }; Counter 类实现了一个函数，可以返回它被调用的次数。可以同时存在多个 Counter 对象，每个对象都有自己的计数：\n1 2 3 4 5 6 7 Counter counter1, counter2; cout \u003c\u003c counter1() \u003c\u003c endl; // prints 0 cout \u003c\u003c counter1() \u003c\u003c endl; // prints 1 cout \u003c\u003c counter1() \u003c\u003c endl; // prints 2 cout \u003c\u003c counter2() \u003c\u003c endl; // prints 0 cout \u003c\u003c counter2() \u003c\u003c endl; // prints 1 cout \u003c\u003c counter1() \u003c\u003c endl; // prints 3 函数允许 function-like object 存在多个实例，每个实例都有自己的状态，并在函数的生命周期内持续存在。这与 function 截然不同，function 中的自动对象不会在单次调用后持续存在，而静态对象则会在整个程序执行过程中持续存在。\nPython 还允许通过定义特殊的 __call__ 方法来编写函数：\n1 2 3 4 5 6 7 class Counter: def __init__(self): self.count = 0 def __call__(self): self.count += 1 return self.count - 1 一般来说，在重载函数调用操作符时，可以指定额外的参数，以模拟可以接收这些参数的函数。\n有些语言不允许重载函数调用操作符本身，但规定了允许定义和使用类函数对象的约定。例如，下面是 Counter 在 Java 中使用 Supplier 接口的实现，该接口指定了一个产生 T 的零参数方法：\n1 2 3 4 5 6 7 class Counter implements Supplier\u003cInteger\u003e { public Integer get() { return count++; } private int count = 0; } 然后通过明确调用 get() 方法来调用这个类函数对象：\n1 2 3 4 5 6 7 8 Supplier\u003cInteger\u003e counter1 = new Counter(); Supplier\u003cInteger\u003e counter2 = new Counter(); System.out.println(counter1.get()); // prints 0 System.out.println(counter1.get()); // prints 1 System.out.println(counter1.get()); // prints 2 System.out.println(counter2.get()); // prints 0 System.out.println(counter2.get()); // prints 1 System.out.println(counter1.get()); // prints 3 再比如，Java 中的 Predicate 接口是通过 functor-like objects 实现的，这些对象接收一个参数并返回一个布尔值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface Predicate\u003cT\u003e { boolean test(T t); ... } class GreaterThan implements Predicate\u003cInteger\u003e { public GreaterThan(int threshold) { this.threshold = threshold; } public boolean test(Integer i) { return i \u003e threshold; } private int threshold; } 使用这些 functor-like objects 的代码会调用 test() 方法，而不是直接调用对象：\n1 2 3 GreaterThan gt3 = new GreaterThan(3); System.out.println(gt3.test(2)); // prints out false System.out.println(gt3.test(20)); // prints out true java.util.function 函数库包中为常见模式提供了单独的接口。\nFunctions as Parameters higher-order function 可以将另一个函数作为参数。我们首先研究那些只有 top-level functions 并允许将函数指针或引用作为参数传递的语言。然后，我们将研究将函数作为参数传递会如何影响函数代码的执行环境。\nFunction Pointers 在某些语言中，函数可以作为参数或返回值传递，但不能在另一个函数的上下文中创建。在这些语言中，所有函数都是在顶层定义的，只有指向函数的指针或引用才能作为值使用。下面是 C 语言中的一个例子，C 语言提供了函数指针：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void apply(int *array, size_t size, int (*func)(int)) { for (; size \u003e 0; --size, ++array) { *array = func(*array); } } int add_one(int x) { return x + 1; } int main() { int A[5] = { 1, 2, 3, 4, 5 }; apply(A, 5, add_one); printf(\"%d, %d, %d, %d, %d\\n\", A[0], A[1], A[2], A[3], A[4]); return 0; } apply() 函数接收数组、数组大小和一个指向接收 int 并返回 int 的 function pointer。它将函数应用于数组中的每个元素，并用结果替换原值。add_one() 函数作为参数传递给 apply()，C 语言会自动将函数转换为函数指针，其结果是 A 中的每个元素都被递增。\nBinding Policy 在上面的代码中，有三个环境与 add_one() 函数相关联：定义环境、在 main() 中引用环境和在 apply() 中调用环境。根据语言的语义，这三个环境中的任何一个都可能是 add_one() 主体执行环境的组成部分。\n在静态作用域中，函数中的代码可以访问其定义环境中的名称，而在动态作用域中，它可以访问其使用环境中的名称。考虑到动态作用域，函数的非本地环境是函数被引用的环境还是函数被调用的环境？下面是一个与这种区别有关的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int foo(int (*bar)()) { int x = 3; return bar(); } int baz() { return x; } int main() { int x = 4; print(foo(baz)); } 在动态作用域中，函数可以访问其使用环境。然而，在上面的示例中，根据 baz() 的使用环境是函数被引用的地方还是被调用的地方，结果是不同的。\n函数被引用的地方的情况下，baz() 的非本地环境是 main() 的环境，baz() 主体中的 x 将引用 main() 中定义的 x。这就是所谓的深度绑定。 函数被调用的地方的情况下，baz() 的非本地环境是 foo() 的环境，baz() 中的 x 将引用 foo() 中定义的 x。这就是所谓的浅绑定。这两种方法都是有效的，语言的绑定策略决定了使用哪种方法。 使用静态作用域时，绑定策略也会对递归函数内部本地定义的函数产生影响。然而，在使用静态作用域的语言中，深度绑定被普遍使用，因此函数定义时所建立的环境就是函数所能访问的环境。\nNested Functions 函数式编程的一个主要特点是可以在另一个函数中定义一个函数，从而动态创建一个函数。在具有静态作用域的语言中，这种嵌套函数可以访问其定义环境，函数与其定义环境的组合称为 closure。嵌套函数中使用但在外层环境中定义的变量被称为 closure 所捕获。如果嵌套函数从外层函数中返回或泄漏，外层函数的环境通常必须在函数返回后继续存在，因为嵌套函数可能会访问其中的绑定。\n举例来说，请看下面这个返回嵌套函数的 Python higher-order function：\n1 2 3 4 5 def make_greater_than(threshold): def greater_than(x): return x \u003e threshold return greater_than make_greater_than() 函数接收一个阈值，并构造一个嵌套函数来判断其输入是否大于阈值。threshold 变量位于 make_greater_than() 的激活记录中，但被 greater_than() 捕获。由于后者会返回阈值，因此激活记录必须持续存在，这样 greater_than() 的调用才能访问 threshold 的绑定。\n请注意，每次调用 make_greater_than()，都会创建一个不同的 greater_than() 实例，并拥有自己的外层环境。因此，不同的 make_greater_than() 调用会产生不同的函数：\n1 2 3 4 5 6 7 8 9 10 \u003e\u003e\u003e gt3 = make_greater_than(3) \u003e\u003e\u003e gt30 = make_greater_than(30) \u003e\u003e\u003e gt3(2) False \u003e\u003e\u003e gt3(20) True \u003e\u003e\u003e gt30(20) False \u003e\u003e\u003e gt30(200) True Environment for multiple instances of a nested function 调用的父框架是 threshold 绑定为 3 的框架，因此 x \u003e threshold 的值为 false。\n非纯函数式语言可能允许修改捕获的变量。例如，下面使用嵌套函数定义了一个银行账户的数据抽象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def make_account(balance): def deposit(amount): nonlocal balance balance += amount return balance def withdraw(amount): nonlocal balance if 0 \u003c= amount \u003c= balance: balance -= amount return amount else: return 0 return deposit, withdraw Python 需要 nonlocal ，因为它默认赋值给本地变量。然后，我们可以如下使用创建的函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003e\u003e\u003e deposit, withdraw = make_account(100) \u003e\u003e\u003e withdraw(10) 10 \u003e\u003e\u003e deposit(0) 90 \u003e\u003e\u003e withdraw(20) 20 \u003e\u003e\u003e deposit(0) 70 \u003e\u003e\u003e deposit(10) 80 \u003e\u003e\u003e withdraw(100) 0 \u003e\u003e\u003e deposit(0) 80 Decorators Python 中的一种常见模式是通过应用高阶函数来转换函数或类。这样的高阶函数被称为 decorator，Python 有专门的语法来装饰函数：\n1 2 3 @\u003cdecorator\u003e def \u003cname\u003e(\u003cparameters\u003e): \u003cbody\u003e 这在很大程度上相当于\n1 2 3 4 def \u003cname\u003e(\u003cparameters\u003e): \u003cbody\u003e \u003cname\u003e = \u003cdecorator\u003e(\u003cname\u003e) 被装饰函数的定义被正常执行，然后在函数上调用装饰器。调用的结果与函数名称绑定。\n举个例子，假设我们想通过打印函数名称及其参数来跟踪函数被调用的时间。我们可以定义一个高阶函数，接收一个函数并返回一个新的嵌套函数，该函数首先打印出原始函数的名称及其参数，然后调用该函数：\n1 2 3 4 5 6 7 def trace(fn): def tracer(*args): args_string = ', '.join(repr(arg) for arg in args) print(f'{fn.__name__}({args_string})') return fn(*args) return tracer 在这里，我们使用变量参数为原始函数传递任意数量的参数。为了简单起见，我们忽略了关键字参数。然后，我们可以使用装饰器语法将其应用到函数中：\n1 2 3 @trace def factorial(n): return 1 if n == 0 else n * factorial(n - 1) 现在，只要调用 factorial()，我们就能得到参数的打印输出：\n1 2 3 4 5 6 7 8 \u003e\u003e\u003e factorial(5) factorial(5) factorial(4) factorial(3) factorial(2) factorial(1) factorial(0) 120 请注意，递归调用也会调用转换后的函数。这是因为在 factorial() 的外层环境中，factorial 这个名称现在与嵌套的跟踪函数绑定在一起，因此查找这个名称时，会调用跟踪函数，而不是原来的函数。这样做的一个副作用是产生了相互递归，即一组函数通过彼此间接地进行递归调用。\nMutual recursion resulting from decorating a recursive function Lambda Functions 嵌套函数定义允许在运行时构造函数，从而满足了函数成为 first-class entity 的要求之一。不过，到目前为止，我们只看到了嵌套函数定义的命名，即在定义环境中引入了绑定。这与其他一流实体，如数据值，形成了鲜明对比，后者可以在不绑定名称的情况下创建。就像构造不带名称的值很有用一样，比如将其作为参数传递或返回时，构造不带名称的函数也很有用。这些函数被称为匿名函数或 lambda 函数。\nlambda 函数在函数式语言中无处不在，但许多常用的命令式语言也提供某种形式的 lambda 函数。不同语言的语法和功能各不相同，我们将研究几个具有代表性的示例。\nScheme 在以函数式为主的 Lisp 系列语言中，lambda 是一种常见的构造，Scheme 也不例外。lambda 特殊形式构造了一个匿名函数：\n1 (lambda () ) 使用 define 形式的函数定义可视为变量定义和 lambda 的简写：\n1 2 3 (define ( ) ) --\u003e (define (lambda () )) 例如，下面的函数创建并返回一个匿名函数，该函数将给定的数字添加到参数中：\n1 2 3 4 5 (define (make-adder n) (lambda (x) (+ x n) ) ) 这比只使用 define 的等价定义更简单、更恰当：\n1 2 3 4 5 6 (define (make-adder n) (define (adder x) (+ x n) ) adder ) 然后，我们就可以在各个参数上调用 make-adder 的结果：\n1 2 3 4 5 6 7 \u003e (define add3 (make-adder 3)) \u003e (add3 4) 7 \u003e (add3 5) 8 \u003e ((make-adder 4) 5) 9 Scheme 中的嵌套函数使用静态作用域，因此匿名函数可以访问其定义环境中的变量 n。然后，它将自己的参数 x 与 n 相加，返回总和。\nScheme 并非纯函数式，它允许变量和复合数据的变异。嵌套函数，无论是否匿名，都可以修改其非本地环境中的变量。下面的函数创建了一个计数器函数，返回它被调用的次数：\n1 2 3 4 5 6 7 8 (define (make-counter) (let ((count 0)) (lambda () (set! count (+ count 1)) (- count 1) ) ) ) set! 将变量变为给定值。这样，我们就可以使用 make-counter 函数了：\n1 2 3 4 5 6 7 \u003e (define counter (make-counter)) \u003e (counter) 0 \u003e (counter) 1 \u003e (counter) 2 Python Python 支持使用 lambda 表达式的匿名函数。其形式如下：\n1 lambda \u003cparameters\u003e: \u003cbody expression\u003e Python 中 lambda 表达式的语法对匿名函数产生了命名嵌套函数所没有的限制：主体必须是一个表达式，该表达式的值自动成为函数的返回值。在实践中，这个限制通常不是问题，因为 lambda 通常用于语句和副作用可能不合适的函数式上下文中。\nResources https://eecs390.github.io/notes/functional.html ",
  "wordCount" : "3251",
  "inLanguage": "zh",
  "datePublished": "2023-10-18T20:14:26+08:00",
  "dateModified": "2023-10-18T20:14:26+08:00",
  "author":{
    "@type": "Person",
    "name": "WFUing"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://WFUing.github.io/post/tech/language/functional-programming/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Waiting For You",
    "logo": {
      "@type": "ImageObject",
      "url": "https://WFUing.github.io/img/logo.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<header class="header"><nav class="nav">
    <div class="logo">
        <a style="color: rgb(218, 218, 219);" href="https://WFUing.github.io/" accesskey="h" title="Waiting For You (Alt + H)">Waiting For You</a>
        <div class="logo-switches">
            <button id="theme-toggle" accesskey="t" title="(Alt + T)" style="color: rgb(218, 218, 219);">
                <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
                <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
            </button>
        </div>
    </div>
    <ul id="menu">
        <li>
            <a href="https://WFUing.github.io/search" title="SEARCH (Alt &#43; /)" accesskey=/>
                <span style="color: rgb(218, 218, 219);">SEARCH</span>
            </a>
        </li>
        <li>
            <a href="https://WFUing.github.io/" title="HOME">
                <span style="color: rgb(218, 218, 219);">HOME</span>
            </a>
        </li>
        <li>
            <a href="https://WFUing.github.io/post" title="BLOGS">
                <span style="color: rgb(218, 218, 219);">BLOGS</span>
            </a>
        </li>
        <li>
            <a href="https://WFUing.github.io/archives" title="ARCHIVE">
                <span style="color: rgb(218, 218, 219);">ARCHIVE</span>
            </a>
        </li>
        <li>
            <a href="https://WFUing.github.io/tags" title="TAGS">
                <span style="color: rgb(218, 218, 219);">TAGS</span>
            </a>
        </li>
    </ul>
</nav>
</header>


<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://WFUing.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/post/">Posts</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/post/tech/">Technology</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/post/tech/language/">Language</a></div>
    <h1 class="post-title">
      Functional Programming
    </h1>
    <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-10-18
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>3251字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>16分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>WFUing
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://WFUing.github.io/tags/functional-programming/" style="color: var(--secondary)!important;">functional programming</a>
                &nbsp;<a href="https://WFUing.github.io/tags/language/" style="color: var(--secondary)!important;">language</a>
            </span>
        </span>
    </span>
</span>
        &nbsp;|&nbsp;标签: &nbsp;
        <ul class="post-tags-meta">
            <a href="https://WFUing.github.io/tags/functional-programming/">functional programming</a>
            <a href="https://WFUing.github.io/tags/language/">、language</a>
        </ul>

        
        
        
        
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_page_pv">
            &nbsp;| 访问: <span id="busuanzi_value_page_pv"></span>
        </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#introduction-to-scheme" aria-label="Introduction to Scheme">Introduction to Scheme</a><ul>
                            
                    <li>
                        <a href="#expressions" aria-label="Expressions">Expressions</a></li>
                    <li>
                        <a href="#definitions" aria-label="Definitions">Definitions</a></li>
                    <li>
                        <a href="#compound-values" aria-label="Compound Values">Compound Values</a></li>
                    <li>
                        <a href="#symbolic-data" aria-label="Symbolic Data">Symbolic Data</a></li></ul>
                    </li>
                    <li>
                        <a href="#functions" aria-label="Functions">Functions</a><ul>
                            
                    <li>
                        <a href="#keyword-arguments" aria-label="Keyword Arguments">Keyword Arguments</a></li>
                    <li>
                        <a href="#default-arguments" aria-label="Default Arguments">Default Arguments</a></li>
                    <li>
                        <a href="#variadic-functions" aria-label="Variadic Functions">Variadic Functions</a></li>
                    <li>
                        <a href="#parameter-passing" aria-label="Parameter Passing">Parameter Passing</a><ul>
                            
                    <li>
                        <a href="#l-value-and-r-value" aria-label="l-value and r-value">l-value and r-value</a></li></ul>
                    </li>
                    <li>
                        <a href="#evaluation-of-function-calls" aria-label="Evaluation of Function Calls">Evaluation of Function Calls</a></li></ul>
                    </li>
                    <li>
                        <a href="#recursion" aria-label="Recursion">Recursion</a><ul>
                            
                    <li>
                        <a href="#activation-records" aria-label="Activation Records">Activation Records</a></li>
                    <li>
                        <a href="#tail-recursion" aria-label="Tail Recursion">Tail Recursion</a></li></ul>
                    </li>
                    <li>
                        <a href="#higher-order-functions" aria-label="Higher-Order Functions">Higher-Order Functions</a><ul>
                            
                    <li>
                        <a href="#function-objects" aria-label="Function Objects">Function Objects</a></li>
                    <li>
                        <a href="#functions-as-parameters" aria-label="Functions as Parameters">Functions as Parameters</a><ul>
                            
                    <li>
                        <a href="#function-pointers" aria-label="Function Pointers">Function Pointers</a></li>
                    <li>
                        <a href="#binding-policy" aria-label="Binding Policy">Binding Policy</a></li>
                    <li>
                        <a href="#nested-functions" aria-label="Nested Functions">Nested Functions</a></li>
                    <li>
                        <a href="#decorators" aria-label="Decorators">Decorators</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#lambda-functions" aria-label="Lambda Functions">Lambda Functions</a><ul>
                            
                    <li>
                        <a href="#scheme" aria-label="Scheme">Scheme</a></li>
                    <li>
                        <a href="#python" aria-label="Python">Python</a></li></ul>
                    </li>
                    <li>
                        <a href="#resources" aria-label="Resources">Resources</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>我们将注意力转向过程抽象，这是一种将复杂程序分解成 functions (也称为 procedures 或 subroutines 。这些术语在不同语境中的用法有细微差别，但就我们的目的而言，我们将把它们视为同义词) 形式的较小代码片段的策略。函数将某些计算封装在一个接口之后，与任何抽象概念一样，函数的用户只需知道函数做了什么，而不需要知道函数是如何完成计算的。函数还通过接收影响其计算的参数来概括计算。计算的结果就是函数的返回值。</p>
<p>在本单元中，我们首先介绍 Lisp 家族中的函数式语言 Scheme。然后，我们将讨论与所有 procedural languages 相关的函数方面的问题，然后再仔细研究 functional programming，这是一种以数学函数为计算模型的编程范式。</p>
<h2 id="introduction-to-scheme">Introduction to Scheme<a hidden class="anchor" aria-hidden="true" href="#introduction-to-scheme">#</a></h2>
<p>R5RS Scheme 语言采用了与 Python 非常相似的计算模型，但只使用 expressions (不使用statements)，擅长 symbolic computation。</p>
<p>Scheme 是 Lisp 的一种方言，Lisp 是当今仍在广泛使用的第二古老的编程语言（仅次于 Fortran）。几十年来，Lisp 程序员社区一直在蓬勃发展，而新的 Lisp 方言（如 Clojure）也是所有现代编程语言中开发者社区发展最快的。要跟上本文的示例，可以下载 Scheme 解释器或使用在线解释器。</p>
<h3 id="expressions">Expressions<a hidden class="anchor" aria-hidden="true" href="#expressions">#</a></h3>
<p>Scheme 程序由 expressions 组成，expressions 可以是简单表达式，也可以是列表形式的组合。简单表达式由一个文字或符号组成。组合表达式是一种 compound expression，由一个运算符表达式和零个或多个操作数子表达式组成。运算符和操作数都包含在括号中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (quotient 10 2)
</span></span><span class="line"><span class="cl">5
</span></span></code></pre></td></tr></table>
</div>
</div><p>Scheme 只使用前缀符号。操作符通常是符号，如 <code>+</code> 和 <code>*</code>。复合表达式可以嵌套，也可以跨一行以上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (+ (* 3 5) (- 10 6))
</span></span><span class="line"><span class="cl">19
</span></span><span class="line"><span class="cl">&gt; (+ (* 3
</span></span><span class="line"><span class="cl">        (+ (* 2 4)
</span></span><span class="line"><span class="cl">           (+ 3 5)
</span></span><span class="line"><span class="cl">        )
</span></span><span class="line"><span class="cl">     )
</span></span><span class="line"><span class="cl">     (+ (- 10 7)
</span></span><span class="line"><span class="cl">        6
</span></span><span class="line"><span class="cl">     )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">57
</span></span></code></pre></td></tr></table>
</div>
</div><p>对组合进行求值时，首先需要检查运算符是否代表 special form，因为 special form 有自己的求值程序。如果运算符不是 special form，那么运算符和操作数表达式将按照任意顺序进行求值。然后，作为运算符值的函数将应用于作为操作数值的参数。</p>
<p>在 Scheme 中，<code>if</code> 表达式是特殊形式的一个例子。虽然它在语法上看起来与调用表达式相似，但它的评估过程却与调用表达式不同。<code>if</code> 表达式的一般形式是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>要对 <code>if</code> 表达式进行求值，解释器首先会对表达式的 <code>&lt;predicate&gt;</code> 部分进行求值。如果 <code>&lt;predicate&gt;</code> 求值为 true，解释器将求值 <code>&lt;consequent&gt;</code> 并返回其值。否则，解释器将求值 <code>&lt;alternative&gt;</code>，并返回其值，<code>&lt;alternative&gt;</code>可省略。</p>
<p>Numerical values 可以使用熟悉的比较运算符进行比较，但在这种情况下也使用 prefix notation：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (&gt;= 2 1)
</span></span><span class="line"><span class="cl">#t
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 Scheme 中，真值 (包括布尔值 <code>#t</code> 表示真， <code>#f</code> 表示假) 可以与布尔特殊形式相结合，它们的求值过程如下：</p>
<ul>
<li><code>(and &lt;e1&gt; ... &lt;en&gt;)</code> 解释器按从左到右的顺序逐次求值表达式 <code>&lt;e&gt;</code>。如果任何 <code>&lt;e&gt;</code> 的值为 false，则 <code>and</code> 表达式的值就是该 false，其余 <code>&lt;e&gt;</code> 的值不予求值。如果所有 <code>&lt;e&gt;</code> 的值都为 true，那么 <code>and</code> 表达式的值就是最后一个 <code>&lt;e&gt;</code> 的值。</li>
<li><code>(or &lt;e1&gt; ... &lt;en&gt;)</code> 解释器按从左到右的顺序，一次评估一个 <code>&lt;e&gt;</code> 表达式。如果任何 <code>&lt;e&gt;</code> 的值为 true，该值将作为 <code>or</code> 表达式的值返回，其余的 <code>&lt;e&gt;</code> 将不被求值。如果所有 <code>&lt;e&gt;</code> 的值都为 false，则 or 表达式的值就是最后一个 <code>&lt;e&gt;</code> 的值。</li>
</ul>
<p>true 也可以用 not 程序来处理：</p>
<ul>
<li><code>(not &lt;e&gt;)</code> 当表达式 <code>&lt;e&gt;</code> 的值为假值时，not 表达式的值为 <code>#t</code>，否则为 <code>#f</code>。</li>
</ul>
<h3 id="definitions">Definitions<a hidden class="anchor" aria-hidden="true" href="#definitions">#</a></h3>
<p>可以使用 <code>define</code> 特殊形式对值进行命名：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define pi 3.14)
</span></span><span class="line"><span class="cl">&gt; (* pi 2)
</span></span><span class="line"><span class="cl">6.28
</span></span></code></pre></td></tr></table>
</div>
</div><p>新函数（在 Scheme 中通常称为 procedures）可以使用 <code>define</code> 特殊形式的第二个版本来定义。例如，要定义平方，我们可以写下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define (square x) (* x x))
</span></span></code></pre></td></tr></table>
</div>
</div><p>程序定义的一般形式是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>&lt;name&gt;</code> 是与环境中存储过程定义相关联的符号。</li>
<li><code>&lt;formal parameters&gt;</code> 是存储过程正文中使用的名称，用于指代存储过程的相应参数。</li>
<li><code>&lt;body&gt;</code> 是一个表达式，当形式参数被存储过程的实际参数替换时，它将产生存储过程应用的值。</li>
<li><code>&lt;name&gt;</code> 和 <code>&lt;formal parameters&gt;</code> 放在括号中，就像在实际调用存储过程时一样。</li>
</ul>
<p>定义了 square 之后，我们就可以在调用表达式中使用它了:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (square 21)
</span></span><span class="line"><span class="cl">441
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; (square (+ 2 5))
</span></span><span class="line"><span class="cl">49
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; (square (square 3))
</span></span><span class="line"><span class="cl">81
</span></span></code></pre></td></tr></table>
</div>
</div><p>用户自定义函数可以接受多个参数，并在函数体中包含特殊形式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define (average x y)
</span></span><span class="line"><span class="cl">    (/ (+ x y) 2))
</span></span><span class="line"><span class="cl">&gt; (average 1 3)
</span></span><span class="line"><span class="cl">2
</span></span><span class="line"><span class="cl">&gt; (define (abs x)
</span></span><span class="line"><span class="cl">    (if (&lt; x 0)
</span></span><span class="line"><span class="cl">        (- x)
</span></span><span class="line"><span class="cl">        x
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">&gt; (abs -3)
</span></span><span class="line"><span class="cl">3
</span></span></code></pre></td></tr></table>
</div>
</div><p>Scheme 支持具有 static scope 的局部函数定义。我们将推迟到讨论<a href="">高阶函数</a>时再讨论这个问题。</p>
<p>匿名函数也称为 lambda 函数，是使用 lambda 特殊形式创建的。使用 lambda 创建存储过程的方法与定义相同，只是不指定存储过程的名称：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(lambda (&lt;formal-parameters&gt;) &lt;body&gt;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>由此产生的存储过程与使用 <code>define</code> 创建的存储过程一样。唯一不同的是，它没有与环境中的任何名称相关联。事实上，下面的表达式是等价的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define (plus4 x) (+ x 4))
</span></span><span class="line"><span class="cl">&gt; (define plus4 (lambda (x) (+ x 4)))
</span></span></code></pre></td></tr></table>
</div>
</div><p>与任何以 procedure 为值的表达式一样，lambda 表达式也可以用作 call expression 中的操作符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; ((lambda (x y z) (+ x y (square z))) 1 2 3)
</span></span><span class="line"><span class="cl">12
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="compound-values">Compound Values<a hidden class="anchor" aria-hidden="true" href="#compound-values">#</a></h3>
<p>Pairs 是内置于 Scheme 语言中的。由于历史原因，Pairs 使用 <code>cons</code> 内置函数创建，因此，Pairs 也被称为 <code>cons</code> 单元，Pairs 中的元素使用 <code>car</code> 和 <code>cdr</code> 访问：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define x (cons 1 2))
</span></span><span class="line"><span class="cl">&gt; x
</span></span><span class="line"><span class="cl">(1 . 2)
</span></span><span class="line"><span class="cl">&gt; (car x)
</span></span><span class="line"><span class="cl">1
</span></span><span class="line"><span class="cl">&gt; (cdr x)
</span></span><span class="line"><span class="cl">2
</span></span></code></pre></td></tr></table>
</div>
</div><center><figure>
    <img loading="lazy" src="./scheme_pair.svg" width="10%"/> <figcaption>
            A pair consisting of the elements 1 and 2
        </figcaption>
</figure>
</center>
<p>该语言还使用成对的方式建立 Recursive lists 。用 <code>'()</code> 表示的特殊值代表 empty list。递归列表值的呈现方式是将其元素放在括号内，中间用空格隔开：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (cons 1
</span></span><span class="line"><span class="cl">        (cons 2
</span></span><span class="line"><span class="cl">              (cons 3
</span></span><span class="line"><span class="cl">                    (cons 4 &#39;())
</span></span><span class="line"><span class="cl">              )
</span></span><span class="line"><span class="cl">         )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">(1 2 3 4)
</span></span><span class="line"><span class="cl">&gt; (list 1 2 3 4)
</span></span><span class="line"><span class="cl">(1 2 3 4)
</span></span><span class="line"><span class="cl">&gt; (define one-through-four (list 1 2 3 4))
</span></span><span class="line"><span class="cl">&gt; (car one-through-four)
</span></span><span class="line"><span class="cl">1
</span></span><span class="line"><span class="cl">&gt; (cdr one-through-four)
</span></span><span class="line"><span class="cl">(2 3 4)
</span></span><span class="line"><span class="cl">&gt; (car (cdr one-through-four))
</span></span><span class="line"><span class="cl">2
</span></span><span class="line"><span class="cl">&gt; (cons 10 one-through-four)
</span></span><span class="line"><span class="cl">(10 1 2 3 4)
</span></span><span class="line"><span class="cl">&gt; (cons 5 one-through-four)
</span></span><span class="line"><span class="cl">(5 1 2 3 4)
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图为文本表示为 <code>(1 2 3 4)</code> 的列表对应的结构由一连串的对组成，以空列表在图中表示为包含符号 $\emptyset$：</p>
<center><figure>
    <img loading="lazy" src="./scheme_list.svg" width="60%"/> <figcaption>
            A list containing the elements 1, 2, 3, and 4
        </figcaption>
</figure>
</center>
<p>以空列表以外的其他元素结束的数对序列称为 improper list。如上面的 <code>(cons 1 2)</code> 的结果就是一个例子，它只包含序列中的 <code>pair</code>。下面演示的是一个更复杂的序列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (cons 1
</span></span><span class="line"><span class="cl">        (cons 2
</span></span><span class="line"><span class="cl">              (cons 3 4)
</span></span><span class="line"><span class="cl">        )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">(1 2 3 . 4)
</span></span></code></pre></td></tr></table>
</div>
</div><center><figure>
    <img loading="lazy" src="./scheme_improper_list.svg" width="40%"/> <figcaption>
            An improper list containing the elements 1, 2, and 3, and terminated by 4 rather than the empty list
        </figcaption>
</figure>
</center>
<p>证明了 pairs 和其他 compound objects 具有引用语义 &ndash; 配对的 cdr 部分存储了对序列中下一对配对的引用。下面的代码通过变量进一步演示了这些引用语义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define x (cons 1 2))
</span></span><span class="line"><span class="cl">&gt; (define y x)
</span></span><span class="line"><span class="cl">&gt; (eqv? x y)
</span></span><span class="line"><span class="cl">#t
</span></span><span class="line"><span class="cl">&gt; (set-car! y 7)
</span></span><span class="line"><span class="cl">&gt; x
</span></span><span class="line"><span class="cl">(7 . 2)
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，定义 <code>(define y x)</code> 的结果是 <code>x</code> 和 <code>y</code> 指向同一个数据 pair object。只有当两个参数指向同一个对象对时，存储过程 <code>eqv?</code> 才会返回 <code>true</code>（而 <code>equal?</code> 则从结构上对对象对进行比较）。此外，当我们使用 <code>set-car!</code> 变量修改 <code>y</code> 所引用的配对的第一个项目时，我们可以看到 <code>x</code> 引用了同一个配对，因为它也显示了修改。</p>
<p>一个对象是否为空列表，可以使用原始的 <code>null?</code> 。利用它，我们可以定义用于计算适当列表长度和选择元素的标准序列操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define (list-length items)
</span></span><span class="line"><span class="cl">    (if (null? items)
</span></span><span class="line"><span class="cl">        0
</span></span><span class="line"><span class="cl">        (+ 1 (list-length (cdr items)))
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">&gt; (define (getitem items n)
</span></span><span class="line"><span class="cl">    (if (= n 0)
</span></span><span class="line"><span class="cl">        (car items)
</span></span><span class="line"><span class="cl">        (getitem (cdr items) (- n 1))
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">&gt; (define squares (list 1 4 9 16 25))
</span></span><span class="line"><span class="cl">&gt; (length squares)
</span></span><span class="line"><span class="cl">5
</span></span><span class="line"><span class="cl">&gt; (getitem squares 3)
</span></span><span class="line"><span class="cl">16
</span></span></code></pre></td></tr></table>
</div>
</div><p>内置的 <code>length</code> 和 <code>list-ref</code> 程序提供了与这里的 <code>list-length</code> 和 <code>getitem</code> 相同的功能。</p>
<h3 id="symbolic-data">Symbolic Data<a hidden class="anchor" aria-hidden="true" href="#symbolic-data">#</a></h3>
<p>我们迄今为止使用过的所有复合数据对象最终都是由数字构建的。使用任意符号作为数据是 Scheme 的优势之一。</p>
<p>为了操作符号，我们需要在语言中加入一个新元素：引用数据对象的能力。假设我们要构造列表 <code>(a b)</code>。我们不能用 <code>(list a b)</code> 来实现这个目的，因为这个表达式构造的是一个包含 <code>a</code> 和 <code>b</code> 值的列表，而不是符号本身。在 Scheme 中，我们会在符号 <code>a</code> 和 <code>b</code> 之前加上单引号，来指代它们，而不是它们的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define a 1)
</span></span><span class="line"><span class="cl">&gt; (define b 2)
</span></span><span class="line"><span class="cl">&gt; (list a b)
</span></span><span class="line"><span class="cl">(1 2)
</span></span><span class="line"><span class="cl">&gt; (list &#39;a &#39;b)
</span></span><span class="line"><span class="cl">(a b)
</span></span><span class="line"><span class="cl">&gt; (list &#39;a b)
</span></span><span class="line"><span class="cl">(a 2)
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 Scheme 中，任何未被求值的表达式都被称为 quoted。引号的概念源于一个经典的哲学，即一个事物，如到处乱跑并吠叫的狗与 &ldquo;狗&rdquo; 这个词之间的区别，&ldquo;狗&rdquo; 这个词是用于指定此类事物的语言结构。当我们使用带引号的 &ldquo;狗&rdquo; 时，我们指的并不是某只狗，而是一个词。在语言中，引号允许我们谈论语言本身，在 Scheme 中也是如此：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (list &#39;define &#39;list)
</span></span><span class="line"><span class="cl">(define list)
</span></span></code></pre></td></tr></table>
</div>
</div><p>引号还允许我们使用传统的列表打印表示法键入复合对象。我们已经看到，<code>'()</code> 表示空列表。下面是其他例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (car &#39;(a b c))
</span></span><span class="line"><span class="cl">a
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; (cdr &#39;(a b c))
</span></span><span class="line"><span class="cl">(b c)
</span></span></code></pre></td></tr></table>
</div>
</div><p>Scheme 中的引号与字符串不同，后者表示字符格式的原始、非结构化数据，而前者表示结构化数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; &#34;(- 3)&#34;  ; a string containing the characters #\( #\- #\space #\3 #\)
</span></span><span class="line"><span class="cl">&#34;(- 3)&#34;
</span></span><span class="line"><span class="cl">&gt; &#39;(- 3)   ; produces a list containing the symbol - and number 3
</span></span><span class="line"><span class="cl">(- 3)
</span></span><span class="line"><span class="cl">&gt; (car &#39;(- 3))
</span></span><span class="line"><span class="cl">-
</span></span><span class="line"><span class="cl">&gt; (cdr &#39;(- 3))
</span></span><span class="line"><span class="cl">(3)
</span></span><span class="line"><span class="cl">&gt; (- 3)    ; calls the - procedure on the number 3
</span></span><span class="line"><span class="cl">-3
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的示例中，字符串字面形式 <code>&quot;(- 3)&quot;</code> 的值为其本身，带引号的表达式 <code>'(- 3)</code> 求值为一个列表，列表的第一个元素是符号 <code>-</code>，第二个元素是数字 <code>3</code>。最后一个示例对符号 <code>-</code> 进行求值以获得相应的存储过程，将数字 <code>3</code> 求值为自身，然后在数字 <code>3</code> 上调用存储过程 <code>-</code>，得到 <code>-3</code>。换句话说，字符串字面量中的数据仍然是字符数据，既不会被求值，也不会被解析。带引号表达式会被解析，但不会被求值，而是产生数据的结构化表示。未加引号的表达式会被解释器解析和求值。</p>
<p>完整的 Scheme 语言还包含其他功能，如 mutation operations、vectors 和 maps。不过，我们迄今为止介绍的子集提供了一种丰富的函数式编程语言，能够实现我们迄今为止讨论过的许多想法。</p>
<h2 id="functions">Functions<a hidden class="anchor" aria-hidden="true" href="#functions">#</a></h2>
<p>我们首先要考虑的是以参数形式向函数传递数据的各种方案。我们将出现在函数定义中的参数，也称为 formal parameters，与调用函数时传递给函数的实际值区分开来，后者通常被称为 actual parameter。</p>
<ul>
<li>本文将使用 argument 一词来指代 actual parameter，</li>
<li>用 parameter 一词指代 formal parameters。</li>
</ul>
<h3 id="keyword-arguments">Keyword Arguments<a hidden class="anchor" aria-hidden="true" href="#keyword-arguments">#</a></h3>
<p>有些语言允许甚至要求在调用函数时提供参数名，这种策略称为 named parameters  或 keyword arguments。</p>
<p>关键字参数通常允许以不同于函数参数列表的顺序提供参数。例如，在 Python 中，keyword argument 可以用于任何参数。请看下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用不带关键字参数的 foo() 时，第一个参数会作为第一个参数传递，第二个参数会作为第二个参数传递：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; foo(1, 2)
</span></span><span class="line"><span class="cl">1 2
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过，参数可以使用参数名重新排序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; foo(y = 1, x = 2)
</span></span><span class="line"><span class="cl">2 1
</span></span></code></pre></td></tr></table>
</div>
</div><p>Python 还提供了将参数定义为 <a href="https://peps.python.org/pep-0570/">positional-only</a> 或 <a href="https://peps.python.org/pep-3102/">keyword-only</a> 的机制，但我们不会在这里讨论这些机制。</p>
<p>有少数语言要求默认为所有或大部分参数提供名称，并要求以与参数相同的顺序提供参数。下面是 Swift 3 中的一个示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">withGreeting</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="bp">print</span><span class="p">(</span><span class="n">withGreeting</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&#34;world&#34;</span><span class="p">,</span> <span class="n">withGreeting</span><span class="p">:</span> <span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以相反的参数顺序调用 <code>greet()</code> 是错误的。</p>
<p>Swift 允许为一个参数指定不同的参数名和参数名，这一点也很罕见。这意味着调用函数时为参数提供的名称可能与函数主体中使用的参数内部名称不同。</p>
<h3 id="default-arguments">Default Arguments<a hidden class="anchor" aria-hidden="true" href="#default-arguments">#</a></h3>
<p>在某些语言中，函数声明或定义可能会提供一个 default argument，允许在没有该参数的情况下调用函数。这可以替代重载，即编写单独的函数定义来处理存在或缺少参数的情况。</p>
<p>下面是一个 Python 示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">base</span> <span class="o">**</span> <span class="n">exponent</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>power()</code> 函数可以调用一个参数，在这种情况下，默认参数 2 用于计算数字的平方。也可以使用两个参数来计算任意幂：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; power(3)
</span></span><span class="line"><span class="cl">9
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; power(3, 4)
</span></span><span class="line"><span class="cl">81
</span></span></code></pre></td></tr></table>
</div>
</div><p>有 default arguments 一般必须出现在参数列表的末尾。对于何时以及在哪种环境下评估默认参数，不同语言的做法各不相同。最常见的策略是每次调用函数时都评估缺省参数，但在定义 environment (static scope) 中进行。Python 的罕见之处在于，它只在函数定义语句执行时评估一次缺省参数。这意味着，如果在函数中修改了参数值，那么对同一函数的后续调用可能会对同一参数使用不同的缺省值。例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="p">[]):</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">test</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">test</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">output</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>C 和 C++ 有许多关于缺省参数的规则，这是因为一个实体可以声明多次。默认参数既可以在独立声明中提供，也可以在定义中提供。但是，同一实体的多个可见声明为同一参数提供默认参数是非法的，即使提供的值是相同的。缺省参数集是同一作用域内所有可见声明的集合，只有在前面和当前声明已为所有后续参数提供缺省参数的情况下，声明才能为参数引入缺省参数。缺省参数中使用的名称在声明时进行解析，但参数表达式在调用函数时进行求值。</p>
<p>下面是 C++ 中多重声明的一个合法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除函数参数外，C++ 还允许模板参数使用默认参数，其有效性规则与此类似。</p>
<h3 id="variadic-functions">Variadic Functions<a hidden class="anchor" aria-hidden="true" href="#variadic-functions">#</a></h3>
<p>一种语言可能会提供一种机制，让函数在调用时可以使用数量可变的参数。这种特性通常被称为 varargs，使用这种特性的函数被称为变量函数 (variadic)。这种机制可能提供类型安全，也可能允许不安全的使用，从而导致错误或未定义的行为。可变参数一般必须出现在参数列表的末尾，它匹配的是非可变参数匹配后剩余的参数。通常只允许使用一个变量参数。</p>
<p>在提供安全变量函数的语言中，一种常见的机制是自动将变量参数打包到一个 container 中，例如 array 或 tuple。例如，下面的 Python 函数计算其参数的乘积：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">*=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数名前面的 <code>*</code> 表示变量参数，变量参数以绑定到参数名的元组形式传递。上述函数遍历元组中的元素，更新总乘积。要调用 <code>product()</code>，必须提供 0 个或更多参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; product()
</span></span><span class="line"><span class="cl">1
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; product(1, 2, 3)
</span></span><span class="line"><span class="cl">6
</span></span></code></pre></td></tr></table>
</div>
</div><p>Python 还提供了可变关键字参数，这些参数被打包成一个字典。在参数前面加上 <code>**</code> 表示它是一个可变关键字参数，并且这样的参数必须是最后一个。例如，下面的函数同时包含一个非关键字可变参数和一个可变关键字参数，打印出前者对应的元组和后者对应的字典：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">print_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; print_args(3, 4, x = 5, y = 6)
</span></span><span class="line"><span class="cl">(3, 4)
</span></span><span class="line"><span class="cl">{&#39;x&#39;: 5, &#39;y&#39;: 6}
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，Python 允许使用 <code>*</code> 或 <code>**</code> 操作符对序列或字典进行 &ldquo;解包&rdquo;，从而将解包后的值用于需要值列表的地方。例如，下面的代码将一个列表解包，以调用 <code>product()</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此外，Scheme 还支持可变参数。一个存储过程可以使用一个不恰当的列表作为参数列表，并以一个符号而不是空列表结束，这样就可以定义一个存储过程来接受可变参数。可变参数与任意数量的参数绑定，并打包成一个列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="p">(</span><span class="n">define</span> <span class="p">(</span><span class="k">func</span> <span class="o">.</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">args</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="p">(</span><span class="k">func</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="p">(</span><span class="k">func</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>存储过程 <code>func</code> 可以接收任意数量的参数，并返回包含这些参数的 list。因此，它的行为与内置的 list 存储过程相同。我们还可以定义一个存储过程，同时接收必参数和可变参数，例如下面的 <code>average</code> 定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define (average x . nums)
</span></span><span class="line"><span class="cl">    (/ (apply + x nums)
</span></span><span class="line"><span class="cl">       (+ 1 (length nums))
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">&gt; (average 1)
</span></span><span class="line"><span class="cl">1
</span></span><span class="line"><span class="cl">&gt; (average 1 3)
</span></span><span class="line"><span class="cl">2
</span></span><span class="line"><span class="cl">&gt; (average 1 3 5 7)
</span></span><span class="line"><span class="cl">4
</span></span></code></pre></td></tr></table>
</div>
</div><p>procedure 接收一个或多个参数，其中第一个参数与参数 <code>x</code> 绑定，其余参数封装在一个与变量 <code>nums</code> 参数绑定的列表中。我们可以使用 <code>apply</code> 来转发变量参数，它接收一个存储过程、任意数量的常规参数，最后是一个包含其余参数的列表。例如，<code>(apply + 1 2 '(3 4))</code> 相当于调用 <code>(+ 1 2 3 4)</code>。在上面第一个使用 average 的示例中，nums 在调用 <code>(average 1)</code> 时绑定为一个空列表，而 <code>(apply + x nums)</code> 相当于 <code>(apply + 1 '())</code> ，后者本身相当于 <code>(+ 1)</code>。在第三个例子中，<code>nums</code> 绑定到一个列表 <code>(3 5 7)</code>，因此 <code>(apply + x nums)</code> 等价于 <code>(apply + 1 '(3 5 7))</code>，而 <code>(apply + 1 '(3 5 7))</code> 又等价于 <code>(+ 1 3 5 7)</code>。</p>
<p>在 Python 和 Scheme 中，可变参数可以匹配任何类型的参数，因为这两种语言都是动态类型的。然而，在静态类型语言中，可变参数通常被限制为单一类型，尽管该类型可能是多态的。例如，下面是 Java 中的一个变量方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_all</span><span class="p">(</span><span class="n">String</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>print_all()</code> 的参数必须是字符串，并将它们打包成一个字符串数组。Java 也允许将单个字符串数组作为参数传递：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">print_all</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;world&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">print_all</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&#34;good&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;bye&#34;</span><span class="w"> </span><span class="p">});</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>C 和 C++ 也有一种可变参数机制，但它存在严重的安全问题。尤其是，它无法向被调用的函数提供关于参数个数及其类型的信息。下面是一个返回参数之和的函数示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">va_list</span> <span class="n">args</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">total</span> <span class="o">+=</span> <span class="nf">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该函数中，第一个参数被假定为其余参数的个数，而后一个参数被假定为 int 类型。如果违反其中任何一个条件，都会产生未定义的行为。另一种策略是使用格式字符串来确定参数的数量和类型，如 printf() 和类似函数中使用的方法。可变参数缺乏安全性，会导致<a href="https://en.wikipedia.org/wiki/Uncontrolled_format_string">格式字符串攻击</a>等漏洞。</p>
<p>C++11 提供了类型安全的 variadic templates。</p>
<h3 id="parameter-passing">Parameter Passing<a hidden class="anchor" aria-hidden="true" href="#parameter-passing">#</a></h3>
<p>语言的另一个不同之处在于函数与其调用者之间传递参数的 semantics 和 mechanism。函数参数可以是单向的，仅用于向函数传递输入或仅用于从函数向调用者传递输出，也可以是双向的。这些情况被称为 input、output 和 input/output 参数。一种语言不必支持所有三种参数类别。</p>
<p>各种语言使用不同的参数传递技术或调用模式。这些技术会影响参数和参数的语义以及支持的参数类别。以下是不同语言使用的具体调用模式：</p>
<p><strong>Call by value</strong>，参数代表函数调用框架中的一个新变量。参数值被复制到与新变量相关的存储空间中。按值调用参数只为函数提供输入，如下面的 C++ 示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">foo</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>              <span class="c1">// prints 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">// prints 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>即使 <code>foo()</code> 修改了输入值，修改后的值也不会传回 caller。</p>
<p><strong>Call by reference</strong>，参数必须传递一个 l-value，因为参数 aliases 了传递进来的对象。对参数的任何修改都会反映在参数对象中。因此，引用调用参数同时提供输入和输出。在 C++ 中，引用参数提供了引用调用，并且可以通过声明 <code>const</code> 将其限制为仅提供输入。下面的 C++ 示例使用引用调用交换了两个对象的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">// prints 4 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>引用调用有时用来指使用指针间接传递对象。下面的 C/C++ 函数使用指针交换对象值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>   <span class="c1">// prints 4 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但从技术上讲，参数和参量是独立的指针对象，通过值传递。尽管如此，这种效果模拟了引用调用，使输入和输出都能通过一个参数来实现。</p>
<p><strong>Call by result</strong>，在这种模式下，参数代表一个新变量，调用者不对其进行初始化。相反，调用者会为参数指定一个 l-value，当函数调用结束时，参数的最终值会被复制到 l-value 中。因此，按结果调用只提供输出参数。下面是一个使用类似 C 的语法、按结果调用的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">result</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span><span class="o">++</span><span class="p">;</span>      <span class="c1">// x is now 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>     <span class="c1">// y is now 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">print</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>   <span class="c1">// prints 4
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Call by value-result</strong>，这是 Call by value 和 Call by result 的组合。参数值被复制到与参数相对应的新变量中，然后从函数返回时，参数值又被复制到调用者提供的 l-value 值中。这与引用调用的不同之处在于，在进入和退出函数时都会进行复制。可以通过将相同的 l-value 传递给多个参数来说明这一点，例如在下面的示例中使用了类似于 C 语言的语法，即按 Call by value-result：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="n">result</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="o">-</span><span class="n">result</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">print</span><span class="p">(</span><span class="nf">foo</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">));</span>   <span class="c1">// prints 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">print</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>           <span class="c1">// prints 3 or 4, depending on the semantics
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这段代码中，<code>x</code> 和 <code>y</code> 是新变量，它们被初始化为 <code>z</code> 的值，即 3。<code>x</code> 的增量不会影响 <code>y</code>，因为它们是独立的变量，所以调用 <code>foo()</code> 返回 1。因此，1 会被打印出来。<code>z</code> 的最终值取决于从 <code>x</code> 还是从 <code>y</code> 复制的语言语义。如果使用引用调用，那么 <code>x</code> 和 <code>y</code> 将 alias 为同一个对象，调用 <code>foo()</code> 将返回 0。</p>
<p><strong>Call by name</strong>，在这种模式下，可以提供一个完整的表达式作为参数，但在调用函数时不会对其进行求值。相反，在函数中出现参数名的地方，参数名会被表达式替换，而表达式会在主体中遇到时进行求值。这是一种 lazy evaluation，即在需要时才计算值。下面是一个使用 C-like syntax、按名称调用的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">name</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">name</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">print</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>   <span class="c1">// becomes print(++y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">print</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>   <span class="c1">// becomes print(++y)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">foo</span><span class="p">(</span><span class="o">++</span><span class="n">x</span><span class="p">,</span> <span class="o">++</span><span class="n">y</span><span class="p">);</span>   <span class="c1">// prints 4, then 4 or 5 depending on the exact
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                 <span class="c1">// language semantics; y is now 4 or 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>        <span class="c1">// prints -1 -- x is unchanged
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在本例中，参数表达式 <code>++x</code> 从未被求值，因为相应的逐名调用参数 <code>a</code> 从未被使用。另一方面，表达式 <code>++y</code> 被计算，因为相应的参数 <code>b</code> 确实被使用了。根据语言语义的不同，表达式可能只被求值一次，其值被缓存以备后续使用，也可能在每次使用参数时都被求值。</p>
<p>按名称调用会产生一个微妙的问题。请看下面这段代码，它使用了 C-like syntax 和按名称调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">name</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">bar</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们用参数表达式替换 <code>bar()</code> 中出现的参数 <code>x</code>，就会得到 <code>y + 1 + y</code> 作为 <code>print()</code> 的参数。如果在 <code>bar()</code> 的环境中求值，结果将是 7。这是不可取的，因为这意味着局部声明 <code>y</code> 的实现细节改变了函数的行为。</p>
<p>相反，参数表达式应在调用者的环境中进行评估。这就要求在函数调用时同时传递参数及其环境。使用名称调用的语言通常使用编译器生成的局部函数，称为 thunk ，来封装参数表达式及其环境。然后将 thunk 传递给被调用的函数，当遇到参数时，就会调用 thunk。</p>
<p>在某些语言中，与 call-by-name parameter 相对应的表达式仅在首次引用该参数时进行评估，并缓存评估结果。缓存的结果将用于随后每次出现的参数。</p>
<p>call by value 是大多数现代语言使用的调用模式，包括 C、C++（用于非引用参数）、Java、Scheme 和 Python。程序员经常误以为后三种语言使用 call by reference，但实际上，它们将 call by value 与 call by reference 语义结合在一起。这种组合有时被称为 object reference 。下面的示例说明 Python 使用的是 call by value：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; x, y = 1, 2
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; swap(x, y)
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; x, y
</span></span><span class="line"><span class="cl">(1, 2)
</span></span></code></pre></td></tr></table>
</div>
</div><p>错误的 <code>swap()</code> 函数只是改变了局部变量的值，从而改变了它们所引用的对象，而没有影响作为参数的变量。这表明全局 x 和 y 的存储空间与参数的存储空间是不同的，因此 Python 没有使用引用调用。事实上，Python 甚至不能像 C 和 C++ 指针那样模拟引用调用。</p>
<h4 id="l-value-and-r-value">l-value and r-value<a hidden class="anchor" aria-hidden="true" href="#l-value-and-r-value">#</a></h4>
<p>l-value 和 r-value 是 C++ 表达式的基础。简单地说，l-value 是对象引用，r-value 是值。l-value 和 r-value 之间的区别在表达式的编写和理解中起着重要作用。</p>
<ul>
<li>l-value 是产生对象引用的表达式，例如变量名、数组下标引用、取消引用指针或返回引用的函数调用。l-value 总是有一个定义的存储区域，因此可以获取其地址。</li>
<li>r-value 是指不是 l-value 的表达式。r-value 的例子包括字面量、大多数运算符的结果以及返回非引用的函数调用。r-value 不一定与任何存储空间相关联。</li>
</ul>
<p>严格来说，函数是一个 l-value，但它的唯一用途是用于调用函数或确定函数的地址。大多数情况下，l-value 指的是对象 l-value。</p>
<h3 id="evaluation-of-function-calls">Evaluation of Function Calls<a hidden class="anchor" aria-hidden="true" href="#evaluation-of-function-calls">#</a></h3>
<p>下面我们总结一下函数调用的实现过程：</p>
<p>第一步是确定嵌套函数调用的非本地环境。在使用嵌套函数和静态作用域的语言中，当执行嵌套函数定义本身时，非本地环境的引用会存储在关联的函数对象中。在具有深绑定的动态作用域下，非本地环境是在函数名称被引用时确定的。最后，在浅绑定的动态作用域中，非本地环境是函数被调用时处于活动状态的环境。</p>
<p>下一步是使用新创建的函数调用激活记录将参数传递给函数。参数在现有环境中进行评估，并按如下方式传递给被调用者：</p>
<ol>
<li><strong>Call by value and call by value-result</strong> : 对参数进行评估以获得其 r-value。r-value 将被复制到新激活记录中相应参数的存储空间。</li>
<li><strong>Call by reference</strong> : 参数的 l-value。相应的参数会绑定到与 l-value 相关的对象上。</li>
<li><strong>Call by result</strong> : 参数进行评估，以获得其 l-value 。在新的激活记录中，存储空间会被分配，但不会被初始化。</li>
<li><strong>Call by name</strong> : 参数表达式会被打包到一个包含当前环境的 thunk 中。参数绑定到 thunk 的引用上。</li>
</ol>
<p>一旦参数被传递，调用者的执行就会暂停，而被调用者的主体将在一个由新创建的激活记录和被调用者的非本地环境组成的环境中执行。对于 call by name，根据语言的语义，call by name 参数的出现会在参数第一次被指名或每次被指名时调用相应的 thunk。</p>
<p>当被调用的函数返回时，其返回值（如果有的话）会被放置在指定的存储位置，通常是在调用者的激活记录中。对于 call-by-result 或 call-by-value-result 参数，参数的当前 r-value 会被复制到与相应函数调用参数的 l-value 相关联的对象中。然后，被调用者的激活记录将被销毁，调用者将在函数调用后恢复执行。函数调用本身的评估结果就是函数的返回值。</p>
<h2 id="recursion">Recursion<a hidden class="anchor" aria-hidden="true" href="#recursion">#</a></h2>
<p>Recursion 是一种利用函数和函数应用进行重复的机制。它涉及函数直接或间接地调用自身，通常使用在某种意义上比前一个参数 &ldquo;小 &ldquo;的参数。递归计算在达到基数时终止，基数是指无需进行任何递归调用即可直接计算出结果的输入。</p>
<p>一种语言要想达到图灵完备性，只需提供 recursion 和 conditionals 即可。</p>
<h3 id="activation-records">Activation Records<a hidden class="anchor" aria-hidden="true" href="#activation-records">#</a></h3>
<p>在机器上，递归之所以起作用，是因为函数的每次调用都有自己的激活记录，将局部变量映射为值。请看下面的阶乘递归定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用 factorial(4) 会导致五次调用 factorial()，参数从 4 到 0，每次都有自己的激活记录和参数 n 的绑定：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">factorial(4):   n --&gt; 4
</span></span><span class="line"><span class="cl">factorial(3):   n --&gt; 3
</span></span><span class="line"><span class="cl">factorial(2):   n --&gt; 2
</span></span><span class="line"><span class="cl">factorial(1):   n --&gt; 1
</span></span><span class="line"><span class="cl">factorial(0):   n --&gt; 0
</span></span></code></pre></td></tr></table>
</div>
</div><center><figure>
    <img loading="lazy" src="./factorial.svg" width="40%"/> <figcaption>
            Activation records used to compute factorial(4)
        </figcaption>
</figure>
</center>
<p>在执行 <code>factorial()</code> 主体时查找 n，每次调用都会获得自己的 n 值，而不会受到其他激活记录的影响。</p>
<p>要使函数调用生效，激活记录需要的不仅仅是参数和局部变量的存储空间。临时值也需要存储在某个地方，由于每个调用都需要自己的临时值存储空间，因此这些临时值通常也要放在激活记录中。调用还需要知道在哪里存储其返回值，通常是在调用者框架中的临时存储区。最后，函数需要知道如何将执行返回给调用者。具体细节不在本文讨论范围之内，但这些信息包括调用者函数调用后的指令地址和调用者激活记录的地址。</p>
<p>临时对象集可以通过静态方式保守地确定，因此激活记录的大小以及对象在其中的位置都可以在编译时确定。对于上面的 <code>factor()</code>，需要临时存储 <code>n - 1</code> 以及递归调用 <code>factorial()</code> 的结果。递归调用会使用后者在调用程序中的位置来存储其返回值。根据不同的实现，调用 <code>factorial(0)</code> 的激活记录中可能仍然有这些临时对象的空间，即使它们不会被使用。</p>
<h3 id="tail-recursion">Tail Recursion<a hidden class="anchor" aria-hidden="true" href="#tail-recursion">#</a></h3>
<p>递归计算对函数的每次调用都使用单独的激活记录。存储这些记录所需的空间与激活函数调用的次数成正比。在上面的 <code>factorial(n)</code> 中，当计算达到 <code>factorial(0)</code> 时，所有 <code>n + 1</code> 次调用都同时激活，需要的空间为 <code>O(n)</code>。与之相比，下面的迭代实现使用的空间是恒定的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">factorial_iter</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">*=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而，递归版本的 <code>factorial()</code> 所需的空间并不是使用递归的内在原因，而是函数编写方式的结果。事实上，由于在递归调用之后还需要完成调用的工作，因此在递归调用期间必须保留其激活记录，这就导致了线性空间需求。</p>
<p>考虑另一种阶乘递推计算方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">factorial_tail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">partial_result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">partial_result</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">factorial_tail</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">partial_result</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，在完成递归调用后，<code>factorial_tail()</code> 函数不做任何工作。这意味着在进行递归调用时，它不再需要存储参数、局部变量或临时对象。此外，由于 <code>factorial(n, k)</code> 直接返回递归调用 <code>factorial(n - 1, n * k)</code> 的结果，因此后者可以将其返回值存储在 <code>factorial(n, k)</code> 的调用者中用于存放 <code>factorial(n, k)</code> 返回值的位置，并直接将执行返回给该调用者。因此，优化后的实现可以为 <code>factorial_tail(n - 1, n * k)</code> 重用 <code>factorial_tail(n, k)</code> 的激活记录空间，因为前者不再需要激活记录。</p>
<p>这个过程可以推广到任何函数调用，而不仅仅是递归调用。如果函数的调用者直接返回调用值，而不执行任何额外的计算，那么该函数调用就是尾调用。如果一个函数的所有递归调用都是尾调用，那么这个函数就是尾递归函数。因此，<code>factorial_tail()</code> 是尾部递归函数。</p>
<p>尾递归计算只使用固定数量的激活记录，因此其空间使用量与等效的迭代计算相当。事实上，许多函数式语言并不提供迭代的构造，因为它们可以等效地使用尾递归来表达。这些语言通常要求实现执行尾调用优化，尽可能重复使用激活记录的空间。</p>
<p>由于尾调用要求在返回后不执行任何计算，因此在语法上看似尾调用的调用可能不是尾调用，因为隐式计算可能发生在函数的末尾。这方面的一个具体例子是基于作用域的资源管理，如下例所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partial_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">sum</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">partial_result</span> <span class="o">+</span> <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然这段代码在递归调用后似乎没有进行计算，但本地 <code>vector&lt;int&gt;</code> 对象有一个析构函数，必须在递归调用完成后运行。因此，对 <code>sum()</code> 的递归调用不是尾部调用，该计算也不是尾部递归计算。</p>
<p>另一种阻碍尾调用优化的情况是，在使用静态作用域并支持高阶函数全部功能的语言中，函数内部包含一个函数定义。嵌套函数需要访问其定义环境，因此如果嵌套函数可以在其外层函数调用完成后或在尾调用中使用，则必须保留该环境。</p>
<h2 id="higher-order-functions">Higher-Order Functions<a hidden class="anchor" aria-hidden="true" href="#higher-order-functions">#</a></h2>
<p>first-class entity 是一种支持对语言中的其他 entities 进行操作的 entity，包括<strong>作为参数传递</strong>、<strong>从函数返回</strong>和<strong>动态创建</strong>。</p>
<ul>
<li>在 functions 是 first-class entity 的语言中，可以编写 higher-order functions，将另一个 function 作为参数传递或返回一个 function。</li>
<li>其他语言也可能支持 higher-order functions，但是在这些语言中 function 不是可以在运行时动态创建的 entity 。</li>
</ul>
<h3 id="function-objects">Function Objects<a hidden class="anchor" aria-hidden="true" href="#function-objects">#</a></h3>
<p>在某些语言中，可以定义本身不是函数但提供与函数相同接口的对象。这些对象被称为函数对象或函数器。一般来说，语言通过允许重载函数调用操作符来编写函数器。请看下面的 C++ 示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Counter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="nl">Counter</span> <span class="p">:</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">operator</span><span class="p">()()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Counter 类实现了一个函数，可以返回它被调用的次数。可以同时存在多个 Counter 对象，每个对象都有自己的计数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Counter</span> <span class="n">counter1</span><span class="p">,</span> <span class="n">counter2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">counter1</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// prints 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">counter1</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// prints 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">counter1</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// prints 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">counter2</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// prints 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">counter2</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// prints 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">counter1</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// prints 3
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>函数允许 function-like object 存在多个实例，每个实例都有自己的状态，并在函数的生命周期内持续存在。这与 function 截然不同，function 中的自动对象不会在单次调用后持续存在，而静态对象则会在整个程序执行过程中持续存在。</p>
<p>Python 还允许通过定义特殊的 <code>__call__</code> 方法来编写函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Counter</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一般来说，在重载函数调用操作符时，可以指定额外的参数，以模拟可以接收这些参数的函数。</p>
<p>有些语言不允许重载函数调用操作符本身，但规定了允许定义和使用类函数对象的约定。例如，下面是 <code>Counter</code> 在 Java 中使用 <code>Supplier&lt;T&gt;</code> 接口的实现，该接口指定了一个产生 <code>T</code> 的零参数方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Counter</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">Integer</span><span class="w"> </span><span class="nf">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>然后通过明确调用 <code>get()</code> 方法来调用这个类函数对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Counter</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Counter</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">counter1</span><span class="p">.</span><span class="na">get</span><span class="p">());</span><span class="w"> </span><span class="c1">// prints 0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">counter1</span><span class="p">.</span><span class="na">get</span><span class="p">());</span><span class="w"> </span><span class="c1">// prints 1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">counter1</span><span class="p">.</span><span class="na">get</span><span class="p">());</span><span class="w"> </span><span class="c1">// prints 2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">counter2</span><span class="p">.</span><span class="na">get</span><span class="p">());</span><span class="w"> </span><span class="c1">// prints 0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">counter2</span><span class="p">.</span><span class="na">get</span><span class="p">());</span><span class="w"> </span><span class="c1">// prints 1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">counter1</span><span class="p">.</span><span class="na">get</span><span class="p">());</span><span class="w"> </span><span class="c1">// prints 3</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再比如，Java 中的 <code>Predicate</code> 接口是通过 functor-like objects 实现的，这些对象接收一个参数并返回一个布尔值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">interface</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">test</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">class</span> <span class="nc">GreaterThan</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">GreaterThan</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">threshold</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threshold</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">test</span><span class="p">(</span><span class="n">Integer</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threshold</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">threshold</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用这些 functor-like objects 的代码会调用 <code>test()</code> 方法，而不是直接调用对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">GreaterThan</span><span class="w"> </span><span class="n">gt3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GreaterThan</span><span class="p">(</span><span class="n">3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">gt3</span><span class="p">.</span><span class="na">test</span><span class="p">(</span><span class="n">2</span><span class="p">));</span><span class="w">    </span><span class="c1">// prints out false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">gt3</span><span class="p">.</span><span class="na">test</span><span class="p">(</span><span class="n">20</span><span class="p">));</span><span class="w">   </span><span class="c1">// prints out true</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>java.util.function</code> 函数库包中为常见模式提供了单独的接口。</p>
<h3 id="functions-as-parameters">Functions as Parameters<a hidden class="anchor" aria-hidden="true" href="#functions-as-parameters">#</a></h3>
<p>higher-order function 可以将另一个函数作为参数。我们首先研究那些只有 top-level functions 并允许将函数指针或引用作为参数传递的语言。然后，我们将研究将函数作为参数传递会如何影响函数代码的执行环境。</p>
<h4 id="function-pointers">Function Pointers<a hidden class="anchor" aria-hidden="true" href="#function-pointers">#</a></h4>
<p>在某些语言中，函数可以作为参数或返回值传递，但不能在另一个函数的上下文中创建。在这些语言中，所有函数都是在顶层定义的，只有指向函数的指针或引用才能作为值使用。下面是 C 语言中的一个例子，C 语言提供了函数指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">apply</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">size</span><span class="p">,</span> <span class="o">++</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add_one</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nf">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">add_one</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d, %d, %d, %d, %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>apply()</code> 函数接收数组、数组大小和一个指向接收 int 并返回 int 的 function pointer。它将函数应用于数组中的每个元素，并用结果替换原值。<code>add_one()</code> 函数作为参数传递给 <code>apply()</code>，C 语言会自动将函数转换为函数指针，其结果是 A 中的每个元素都被递增。</p>
<h4 id="binding-policy">Binding Policy<a hidden class="anchor" aria-hidden="true" href="#binding-policy">#</a></h4>
<p>在上面的代码中，有三个环境与 <code>add_one()</code> 函数相关联：定义环境、在 <code>main()</code> 中引用环境和在 <code>apply()</code> 中调用环境。根据语言的语义，这三个环境中的任何一个都可能是 <code>add_one()</code> 主体执行环境的组成部分。</p>
<p>在静态作用域中，函数中的代码可以访问其定义环境中的名称，而在动态作用域中，它可以访问其使用环境中的名称。考虑到动态作用域，函数的非本地环境是函数被引用的环境还是函数被调用的环境？下面是一个与这种区别有关的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bar</span><span class="p">)())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">bar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">baz</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">print</span><span class="p">(</span><span class="nf">foo</span><span class="p">(</span><span class="n">baz</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在动态作用域中，函数可以访问其使用环境。然而，在上面的示例中，根据 <code>baz()</code> 的使用环境是函数被引用的地方还是被调用的地方，结果是不同的。</p>
<ul>
<li>函数被引用的地方的情况下，<code>baz()</code> 的非本地环境是 <code>main()</code> 的环境，<code>baz()</code> 主体中的 <code>x</code> 将引用 <code>main()</code> 中定义的 <code>x</code>。这就是所谓的深度绑定。</li>
<li>函数被调用的地方的情况下，<code>baz()</code> 的非本地环境是 <code>foo()</code> 的环境，<code>baz()</code> 中的 <code>x</code> 将引用 <code>foo()</code> 中定义的 <code>x</code>。这就是所谓的浅绑定。这两种方法都是有效的，语言的绑定策略决定了使用哪种方法。</li>
</ul>
<p>使用静态作用域时，绑定策略也会对递归函数内部本地定义的函数产生影响。然而，在使用静态作用域的语言中，深度绑定被普遍使用，因此函数定义时所建立的环境就是函数所能访问的环境。</p>
<h4 id="nested-functions">Nested Functions<a hidden class="anchor" aria-hidden="true" href="#nested-functions">#</a></h4>
<p>函数式编程的一个主要特点是可以在另一个函数中定义一个函数，从而动态创建一个函数。在具有静态作用域的语言中，这种嵌套函数可以访问其定义环境，函数与其定义环境的组合称为 closure。嵌套函数中使用但在外层环境中定义的变量被称为 closure 所捕获。如果嵌套函数从外层函数中返回或泄漏，外层函数的环境通常必须在函数返回后继续存在，因为嵌套函数可能会访问其中的绑定。</p>
<p>举例来说，请看下面这个返回嵌套函数的 Python higher-order function：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">make_greater_than</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">greater_than</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">threshold</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">greater_than</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>make_greater_than()</code> 函数接收一个阈值，并构造一个嵌套函数来判断其输入是否大于阈值。<code>threshold</code> 变量位于 <code>make_greater_than()</code> 的激活记录中，但被 <code>greater_than()</code> 捕获。由于后者会返回阈值，因此激活记录必须持续存在，这样 <code>greater_than()</code> 的调用才能访问 <code>threshold</code> 的绑定。</p>
<p>请注意，每次调用 <code>make_greater_than()</code>，都会创建一个不同的 <code>greater_than()</code> 实例，并拥有自己的外层环境。因此，不同的 <code>make_greater_than()</code> 调用会产生不同的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt;&gt;&gt; <span class="nv">gt3</span> <span class="o">=</span> make_greater_than<span class="o">(</span>3<span class="o">)</span>
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; <span class="nv">gt30</span> <span class="o">=</span> make_greater_than<span class="o">(</span>30<span class="o">)</span>
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; gt3<span class="o">(</span>2<span class="o">)</span>
</span></span><span class="line"><span class="cl">False
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; gt3<span class="o">(</span>20<span class="o">)</span>
</span></span><span class="line"><span class="cl">True
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; gt30<span class="o">(</span>20<span class="o">)</span>
</span></span><span class="line"><span class="cl">False
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; gt30<span class="o">(</span>200<span class="o">)</span>
</span></span><span class="line"><span class="cl">True
</span></span></code></pre></td></tr></table>
</div>
</div><center><figure>
    <img loading="lazy" src="./greater_than.svg" width="60%"/> <figcaption>
            Environment for multiple instances of a nested function
        </figcaption>
</figure>
</center>
<p>调用的父框架是 <code>threshold</code> 绑定为 3 的框架，因此 <code>x &gt; threshold</code> 的值为 false。</p>
<p>非纯函数式语言可能允许修改捕获的变量。例如，下面使用嵌套函数定义了一个银行账户的数据抽象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">make_account</span><span class="p">(</span><span class="n">balance</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">nonlocal</span> <span class="n">balance</span>
</span></span><span class="line"><span class="cl">        <span class="n">balance</span> <span class="o">+=</span> <span class="n">amount</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">balance</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">withdraw</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">nonlocal</span> <span class="n">balance</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">balance</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">balance</span> <span class="o">-=</span> <span class="n">amount</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">amount</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">deposit</span><span class="p">,</span> <span class="n">withdraw</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Python 需要 <code>nonlocal</code> ，因为它默认赋值给本地变量。然后，我们可以如下使用创建的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">deposit</span><span class="p">,</span> <span class="n">withdraw</span> <span class="o">=</span> <span class="n">make_account</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">withdraw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">deposit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">90</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">withdraw</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">deposit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">70</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">deposit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">80</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">withdraw</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">deposit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">80</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="decorators">Decorators<a hidden class="anchor" aria-hidden="true" href="#decorators">#</a></h4>
<p>Python 中的一种常见模式是通过应用高阶函数来转换函数或类。这样的高阶函数被称为 decorator，Python 有专门的语法来装饰函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="o">@&lt;</span><span class="n">decorator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">parameters</span><span class="o">&gt;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这在很大程度上相当于</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">parameters</span><span class="o">&gt;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">decorator</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>被装饰函数的定义被正常执行，然后在函数上调用装饰器。调用的结果与函数名称绑定。</p>
<p>举个例子，假设我们想通过打印函数名称及其参数来跟踪函数被调用的时间。我们可以定义一个高阶函数，接收一个函数并返回一个新的嵌套函数，该函数首先打印出原始函数的名称及其参数，然后调用该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">tracer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">args_string</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">args_string</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">tracer</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们使用变量参数为原始函数传递任意数量的参数。为了简单起见，我们忽略了关键字参数。然后，我们可以使用装饰器语法将其应用到函数中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="nd">@trace</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在，只要调用 <code>factorial()</code>，我们就能得到参数的打印输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">factorial</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">factorial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">120</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，递归调用也会调用转换后的函数。这是因为在 <code>factorial()</code> 的外层环境中，<code>factorial</code> 这个名称现在与嵌套的跟踪函数绑定在一起，因此查找这个名称时，会调用跟踪函数，而不是原来的函数。这样做的一个副作用是产生了相互递归，即一组函数通过彼此间接地进行递归调用。</p>
<center><figure>
    <img loading="lazy" src="./trace.svg" width="50%"/> <figcaption>
            Mutual recursion resulting from decorating a recursive function
        </figcaption>
</figure>
</center>
<h2 id="lambda-functions">Lambda Functions<a hidden class="anchor" aria-hidden="true" href="#lambda-functions">#</a></h2>
<p>嵌套函数定义允许在运行时构造函数，从而满足了函数成为 first-class entity 的要求之一。不过，到目前为止，我们只看到了嵌套函数定义的命名，即在定义环境中引入了绑定。这与其他一流实体，如数据值，形成了鲜明对比，后者可以在不绑定名称的情况下创建。就像构造不带名称的值很有用一样，比如将其作为参数传递或返回时，构造不带名称的函数也很有用。这些函数被称为匿名函数或 lambda 函数。</p>
<p>lambda 函数在函数式语言中无处不在，但许多常用的命令式语言也提供某种形式的 lambda 函数。不同语言的语法和功能各不相同，我们将研究几个具有代表性的示例。</p>
<h3 id="scheme">Scheme<a hidden class="anchor" aria-hidden="true" href="#scheme">#</a></h3>
<p>在以函数式为主的 Lisp 系列语言中，lambda 是一种常见的构造，Scheme 也不例外。lambda 特殊形式构造了一个匿名函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(lambda (&lt;parameters&gt;) &lt;body&gt;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 define 形式的函数定义可视为变量定义和 lambda 的简写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define (&lt;name&gt; &lt;parameters&gt;) &lt;body&gt;)
</span></span><span class="line"><span class="cl">  --&gt;
</span></span><span class="line"><span class="cl">(define &lt;name&gt; (lambda (&lt;parameters&gt;) &lt;body&gt;))
</span></span></code></pre></td></tr></table>
</div>
</div><p>例如，下面的函数创建并返回一个匿名函数，该函数将给定的数字添加到参数中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define (make-adder n)
</span></span><span class="line"><span class="cl">  (lambda (x)
</span></span><span class="line"><span class="cl">    (+ x n)
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">)
</span></span></code></pre></td></tr></table>
</div>
</div><p>这比只使用 define 的等价定义更简单、更恰当：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define (make-adder n)
</span></span><span class="line"><span class="cl">  (define (adder x)
</span></span><span class="line"><span class="cl">    (+ x n)
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">  adder
</span></span><span class="line"><span class="cl">)
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，我们就可以在各个参数上调用 make-adder 的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define add3 (make-adder 3))
</span></span><span class="line"><span class="cl">&gt; (add3 4)
</span></span><span class="line"><span class="cl">7
</span></span><span class="line"><span class="cl">&gt; (add3 5)
</span></span><span class="line"><span class="cl">8
</span></span><span class="line"><span class="cl">&gt; ((make-adder 4) 5)
</span></span><span class="line"><span class="cl">9
</span></span></code></pre></td></tr></table>
</div>
</div><p>Scheme 中的嵌套函数使用静态作用域，因此匿名函数可以访问其定义环境中的变量 n。然后，它将自己的参数 x 与 n 相加，返回总和。</p>
<p>Scheme 并非纯函数式，它允许变量和复合数据的变异。嵌套函数，无论是否匿名，都可以修改其非本地环境中的变量。下面的函数创建了一个计数器函数，返回它被调用的次数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define (make-counter)
</span></span><span class="line"><span class="cl">  (let ((count 0))
</span></span><span class="line"><span class="cl">    (lambda ()
</span></span><span class="line"><span class="cl">      (set! count (+ count 1))
</span></span><span class="line"><span class="cl">      (- count 1)
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">)
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>set!</code> 将变量变为给定值。这样，我们就可以使用 <code>make-counter</code> 函数了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; (define counter (make-counter))
</span></span><span class="line"><span class="cl">&gt; (counter)
</span></span><span class="line"><span class="cl">0
</span></span><span class="line"><span class="cl">&gt; (counter)
</span></span><span class="line"><span class="cl">1
</span></span><span class="line"><span class="cl">&gt; (counter)
</span></span><span class="line"><span class="cl">2
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="python">Python<a hidden class="anchor" aria-hidden="true" href="#python">#</a></h3>
<p>Python 支持使用 lambda 表达式的匿名函数。其形式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="k">lambda</span> <span class="o">&lt;</span><span class="n">parameters</span><span class="o">&gt;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">body</span> <span class="n">expression</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Python 中 lambda 表达式的语法对匿名函数产生了命名嵌套函数所没有的限制：主体必须是一个表达式，该表达式的值自动成为函数的返回值。在实践中，这个限制通常不是问题，因为 lambda 通常用于语句和副作用可能不合适的函数式上下文中。</p>
<h2 id="resources">Resources<a hidden class="anchor" aria-hidden="true" href="#resources">#</a></h2>
<ul>
<li><a href="https://eecs390.github.io/notes/functional.html">https://eecs390.github.io/notes/functional.html</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://WFUing.github.io/tags/functional-programming/">functional programming</a></li>
      <li><a href="https://WFUing.github.io/tags/language/">language</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://WFUing.github.io/post/tech/architecture/shell/">
    <span class="title">« 上一页</span>
    <br>
    <span>Shell 简介</span>
  </a>
  <a class="next" href="https://WFUing.github.io/post/read/%E4%BA%BA%E4%BB%B6/">
    <span class="title">下一页 »</span>
    <br>
    <span>《人件》读书笔记</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Functional Programming on twitter"
        href="https://twitter.com/intent/tweet/?text=Functional%20Programming&amp;url=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2ffunctional-programming%2f&amp;hashtags=functionalprogramming%2clanguage">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Functional Programming on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2ffunctional-programming%2f&amp;title=Functional%20Programming&amp;summary=Functional%20Programming&amp;source=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2ffunctional-programming%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Functional Programming on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2ffunctional-programming%2f&title=Functional%20Programming">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Functional Programming on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2ffunctional-programming%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Functional Programming on whatsapp"
        href="https://api.whatsapp.com/send?text=Functional%20Programming%20-%20https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2ffunctional-programming%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Functional Programming on telegram"
        href="https://telegram.me/share/url?text=Functional%20Programming&amp;url=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2ffunctional-programming%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Functional Programming on ycombinator"
        href="https://news.ycombinator.com/submitlink?t=Functional%20Programming&u=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2ffunctional-programming%2f">
        <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
            xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
            <path
                d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
        </svg>
    </a>
</div>

  </footer>
<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>
    <div id="tcomment"></div>
    <script src="https://cdn.staticfile.org/twikoo/1.4.11/twikoo.all.min.js"></script>
    <script>
        twikoo.init({
            envId: "https://twikoo-api-three-gamma.vercel.app/",  
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou',  
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        });
    </script>
</div>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://WFUing.github.io/">Waiting For You</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
