<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>meta-programming | Waiting For You</title>
<meta name="keywords" content="metaprogramming, language">
<meta name="description" content="元编程是编写可在其他程序上运行的计算机程序的技术。诸如编译器和程序分析器之类的系统可以被视为元程序，因为它们将其他程序作为输入。我们将在这里讨论的元编程形式特别关注生成要作为程序一部分包含的代码。从某种意义上说，它们可以被认为是初级编译器。
Macros and Code Generation macro 是将输入序列转换为某种替换输出序列的规则。这个翻译过程称为 macro expansion，一些语言提供宏作为其规范的一部分。宏设施可以被实现为 preprocessing step，其中宏扩展发生在 lexical and syntactic analysis 之前，或者它可以被合并为 syntax analysis 或 a later translation step。
使用最广泛的 macro systems 之一是 C 预处理器（CPP），它作为处理程序的第一步被包含在 C 和 C&#43;&#43; 中。预处理器指令以散列符号开头，包括 #include、#define、#if 等。例如，下面定义了一个类似函数的 macro 来交换两个项目：
1 #define SWAP(a, b) { auto tmp = b; b = a; a = tmp; } 然后，我们可以如下使用宏：
1 2 3 4 5 6 7 8 9 int main() { int x = 3; int y = 4; SWAP(x, y); cout &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; y &lt;&lt; endl; } // output 4 3 通过向 g&#43;&#43; 传递 -E 标志，可以获得宏扩展的结果：">
<meta name="author" content="WFUing">
<link rel="canonical" href="https://WFUing.github.io/post/tech/language/metaprogramming/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.078343916625d121842bb25d5797d26510dec739246c5291e7aa1c8bdfed3a34.css" integrity="sha256-B4NDkWYl0SGEK7JdV5fSZRDexzkkbFKR56oci9/tOjQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://WFUing.github.io/img/logo.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://WFUing.github.io/img/logo.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://WFUing.github.io/img/logo.gif">
<link rel="apple-touch-icon" href="https://WFUing.github.io/logo.gif">
<link rel="mask-icon" href="https://WFUing.github.io/logo.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
    processEscapes: true,
    processEnvironments: true,
    autoload: {
      color: [],
      colorv2: ['color']
    },
    packages: {'[+]': ['noerrors']}
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/noerrors']
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>
<meta property="og:title" content="meta-programming" />
<meta property="og:description" content="元编程是编写可在其他程序上运行的计算机程序的技术。诸如编译器和程序分析器之类的系统可以被视为元程序，因为它们将其他程序作为输入。我们将在这里讨论的元编程形式特别关注生成要作为程序一部分包含的代码。从某种意义上说，它们可以被认为是初级编译器。
Macros and Code Generation macro 是将输入序列转换为某种替换输出序列的规则。这个翻译过程称为 macro expansion，一些语言提供宏作为其规范的一部分。宏设施可以被实现为 preprocessing step，其中宏扩展发生在 lexical and syntactic analysis 之前，或者它可以被合并为 syntax analysis 或 a later translation step。
使用最广泛的 macro systems 之一是 C 预处理器（CPP），它作为处理程序的第一步被包含在 C 和 C&#43;&#43; 中。预处理器指令以散列符号开头，包括 #include、#define、#if 等。例如，下面定义了一个类似函数的 macro 来交换两个项目：
1 #define SWAP(a, b) { auto tmp = b; b = a; a = tmp; } 然后，我们可以如下使用宏：
1 2 3 4 5 6 7 8 9 int main() { int x = 3; int y = 4; SWAP(x, y); cout &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; y &lt;&lt; endl; } // output 4 3 通过向 g&#43;&#43; 传递 -E 标志，可以获得宏扩展的结果：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://WFUing.github.io/post/tech/language/metaprogramming/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-10-16T15:29:44+08:00" />
<meta property="article:modified_time" content="2023-10-16T15:29:44+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="meta-programming"/>
<meta name="twitter:description" content="元编程是编写可在其他程序上运行的计算机程序的技术。诸如编译器和程序分析器之类的系统可以被视为元程序，因为它们将其他程序作为输入。我们将在这里讨论的元编程形式特别关注生成要作为程序一部分包含的代码。从某种意义上说，它们可以被认为是初级编译器。
Macros and Code Generation macro 是将输入序列转换为某种替换输出序列的规则。这个翻译过程称为 macro expansion，一些语言提供宏作为其规范的一部分。宏设施可以被实现为 preprocessing step，其中宏扩展发生在 lexical and syntactic analysis 之前，或者它可以被合并为 syntax analysis 或 a later translation step。
使用最广泛的 macro systems 之一是 C 预处理器（CPP），它作为处理程序的第一步被包含在 C 和 C&#43;&#43; 中。预处理器指令以散列符号开头，包括 #include、#define、#if 等。例如，下面定义了一个类似函数的 macro 来交换两个项目：
1 #define SWAP(a, b) { auto tmp = b; b = a; a = tmp; } 然后，我们可以如下使用宏：
1 2 3 4 5 6 7 8 9 int main() { int x = 3; int y = 4; SWAP(x, y); cout &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; y &lt;&lt; endl; } // output 4 3 通过向 g&#43;&#43; 传递 -E 标志，可以获得宏扩展的结果："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://WFUing.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Technology",
      "item": "https://WFUing.github.io/post/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Language",
      "item": "https://WFUing.github.io/post/tech/language/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "meta-programming",
      "item": "https://WFUing.github.io/post/tech/language/metaprogramming/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "meta-programming",
  "name": "meta-programming",
  "description": "元编程是编写可在其他程序上运行的计算机程序的技术。诸如编译器和程序分析器之类的系统可以被视为元程序，因为它们将其他程序作为输入。我们将在这里讨论的元编程形式特别关注生成要作为程序一部分包含的代码。从某种意义上说，它们可以被认为是初级编译器。\nMacros and Code Generation macro 是将输入序列转换为某种替换输出序列的规则。这个翻译过程称为 macro expansion，一些语言提供宏作为其规范的一部分。宏设施可以被实现为 preprocessing step，其中宏扩展发生在 lexical and syntactic analysis 之前，或者它可以被合并为 syntax analysis 或 a later translation step。\n使用最广泛的 macro systems 之一是 C 预处理器（CPP），它作为处理程序的第一步被包含在 C 和 C++ 中。预处理器指令以散列符号开头，包括 #include、#define、#if 等。例如，下面定义了一个类似函数的 macro 来交换两个项目：\n1 #define SWAP(a, b) { auto tmp = b; b = a; a = tmp; } 然后，我们可以如下使用宏：\n1 2 3 4 5 6 7 8 9 int main() { int x = 3; int y = 4; SWAP(x, y); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } // output 4 3 通过向 g++ 传递 -E 标志，可以获得宏扩展的结果：",
  "keywords": [
    "metaprogramming", "language"
  ],
  "articleBody": "元编程是编写可在其他程序上运行的计算机程序的技术。诸如编译器和程序分析器之类的系统可以被视为元程序，因为它们将其他程序作为输入。我们将在这里讨论的元编程形式特别关注生成要作为程序一部分包含的代码。从某种意义上说，它们可以被认为是初级编译器。\nMacros and Code Generation macro 是将输入序列转换为某种替换输出序列的规则。这个翻译过程称为 macro expansion，一些语言提供宏作为其规范的一部分。宏设施可以被实现为 preprocessing step，其中宏扩展发生在 lexical and syntactic analysis 之前，或者它可以被合并为 syntax analysis 或 a later translation step。\n使用最广泛的 macro systems 之一是 C 预处理器（CPP），它作为处理程序的第一步被包含在 C 和 C++ 中。预处理器指令以散列符号开头，包括 #include、#define、#if 等。例如，下面定义了一个类似函数的 macro 来交换两个项目：\n1 #define SWAP(a, b) { auto tmp = b; b = a; a = tmp; } 然后，我们可以如下使用宏：\n1 2 3 4 5 6 7 8 9 int main() { int x = 3; int y = 4; SWAP(x, y); cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; } // output 4 3 通过向 g++ 传递 -E 标志，可以获得宏扩展的结果：\n1 $ g++ -E 不过，如果使用 #includes 指令，结果可能会非常混乱，因为该指令会从给定文件中调入代码。\nCPP macros perform text 替换，因此上述代码等同于：\n1 2 3 4 5 6 int main() { int x = 3; int y = 4; { auto tmp = y; y = x; x = tmp; }; cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; } 使用 SWAP 宏后的分号仍然保留，表示空语句。不过，在需要使用单一语句的情况下，例如一个没有被 block 括住的条件分支，这就会造成问题：\n1 2 3 4 if (x \u003c y) SWAP(x, y); else cout \u003c\u003c \"no swap\" \u003c\u003c endl; 避免这一问题的常用方法是将 macro 的扩展代码放在 do/while 中：\n1 2 3 4 5 #define SWAP(a, b) do { \\ auto tmp = b; \\ b = a; \\ a = tmp; \\ } while (false) 在这里，我们在一行的末尾添加了一个 \\，表示下一行应被视为上一行的继续。do/while 循环在语法上以分号结束，因此 SWAP(x, y); 中的分号在语法上是 do/while 循环的一部分。因此，扩展代码的语法是正确的：\n1 2 3 4 if (x \u003c y) do { auto tmp = b; b = a; a = tmp; } while (false); else cout \u003c\u003c \"no swap\" \u003c\u003c endl; 虽然 textual replacement 很有用，但它也有缺点，因为虽然宏在语法上类似函数，但它们的行为却不像函数。具体来说，它们不把参数作为自己的实体，也不引入独立的作用域。请看下面的例子：\n1 2 3 4 5 6 7 8 9 10 int main() { int x = 3; int y = 4; int z = 5; SWAP(x \u003c y ? x : y, z); cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c \" \" \u003c\u003c z \u003c\u003c endl; } // output 3 4 3 使用 g++ -E，我们可以看到预处理后的代码。只看 main() 的输出，我们会发现\n1 2 3 4 5 6 7 8 9 10 11 int main() { int x = 3; int y = 4; int z = 5; do { auto tmp = z; z = x \u003c y ? x : y; x \u003c y ? x : y = tmp; } while (false); cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c \" \" \u003c\u003c z \u003c\u003c endl; } 在这里，我们手动添加了换行符和空格，以使输出更易读；而预处理器本身会将宏输出放在一行中。罪魁祸首是最后生成的语句：\n1 x \u003c y ? x : y = tmp; 在 C++ 中，条件运算符 ? : 和赋值运算符 = 具有相同的优先级，并且从右向左关联，因此这等同于\n1 x \u003c y ? x : (y = tmp); 由于 x \u003c y，这里没有赋值。因此，x 的值保持不变。\n我们可以在每次使用 macro argument 时加上括号来解决这个问题：\n1 2 3 4 5 #define SWAP(a, b) do { \\ auto tmp = (b); \\ (b) = (a); \\ (a) = tmp; \\ } while (false) Ranking the Operator Precedence in C++ 现在会产生预期的结果，因为括号明确地将这些操作联系起来：\n1 2 3 4 5 6 7 8 9 10 11 int main() { int x = 3; int y = 4; int z = 5; do { auto tmp = (z); (z) = (x \u003c y ? x : y); (x \u003c y ? x : y) = tmp; } while (false); cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c \" \" \u003c\u003c z \u003c\u003c endl; } 然而，第二个问题并不那么容易解决。考虑一下当我们将 SWAP 宏应用于名为 tmp 的变量时会发生什么：\n1 2 3 4 5 6 7 8 9 int main() { int x = 3; int tmp = 4; SWAP(tmp, x); cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c tmp \u003c\u003c endl; } // output 3 4 没有发生交换！再次使用 g++ -E 检查输出，我们可以看到（模数间隔）\n1 2 3 4 5 6 7 8 9 10 int main() { int x = 3; int tmp = 4; do { auto tmp = (x); (x) = (tmp); (tmp) = tmp; } while (false); cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c tmp \u003c\u003c endl; } 由于 SWAP 使用的临时变量与参数同名，因此临时变量会捕获生成代码中出现的参数。这是因为宏只是执行文本替换，并不能确保名称被解析到适当的作用域。因此，宏实际上并不使用按名称调用，而按名称调用可确保参数中的名称解析到适当的作用域。对文本替换的依赖使 CPP 成为一个不卫生的宏系统。其他系统（如 Scheme 的系统）是卫生的，它们为宏引入的名称创建了单独的作用域，并确保参数不会被捕获。\nScheme Macros 作为 R5RS Scheme 规范的一部分，宏系统是卫生的。宏由 define-syntax、let-syntax 或 letrec-syntax 中的一种形式引入，并将给定的名称与宏绑定。例如，下面是 let 作为宏的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 (define-syntax let (syntax-rules () ((let ((name val) ...) body1 body2 ... ) ((lambda (name ...) body1 body2 ... ) val ... ) ) ) ) syntax-rules 指定了宏转换的规则。第一个参数是规则模式与输入之间必须匹配的字面形式列表。例如，cond 形式中的 else 标识符。但在这种情况下，没有字面意义。syntax-rules 的其余参数指定了转换。转换的第一项是输入模式，第二项是输出模式。...的作用类似于克莱因星，将前一项与输入中出现的零次或多次相匹配。输入模式中出现但不在字面量列表中的名称，除了作为宏名称的第一项，都是与输入元素相匹配的卫生变量。这些变量可以在输出模式中引用，以指定如何构造输出。\n在全局环境中评估上述表达式时，会将 let 名称与一个转换为 lambda 的宏绑定。\n宏主体引入的标识符保证避免与其他标识符冲突，解释器通常会重命名标识符以避免冲突。下面是 swap 宏的定义：\n1 2 3 4 5 6 7 8 9 10 (define-syntax swap (syntax-rules () ((swap a b) (let ((tmp b)) (set! b a) (set! a tmp) ) ) ) ) 这就将 swap 的使用转化为一个表达式，通过临时变量 tmp 交换两个参数。因此\n1 2 3 4 5 6 7 \u003e (define x 3) \u003e (define y 4) \u003e (swap x y) \u003e x 4 \u003e y 3 不过，与 CPP 宏不同的是，swap 宏引入的 tmp 与其他任何 tmp 都是不同的：\n1 2 3 4 5 6 \u003e (define tmp 5) \u003e (swap x tmp) \u003e x 5 \u003e tmp 4 因为宏在 Scheme 中是卫生的，所以我们会得到预期的行为。\n为了支持宏，Scheme 解释器的评估过程会像往常一样评估列表中的第一个项目。如果评估结果是一个宏，那么解释器将对列表的其余部分执行宏扩展，而不会首先评估参数。扩展引入的任何名称都与其他名称置于不同的作用域。扩展后，解释器会对扩展结果重复求值过程，因此，如果最终结果是一个 let 表达式 (如上文 swap 中的表达式)，就会对该表达式进行求值。\n一个宏定义可以指定多个模式规则。再加上扩展的结果会被求值，这使得宏定义可以递归，如下面的 let* 定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 (define-syntax let* (syntax-rules () ((let* () body1 body2 ... ) (let () body1 body2 ... ) ) ((let* ((name1 val1) (name2 val2) ...) body1 body2 ... ) (let ((name1 val1)) (let* ((name2 val2) ...) body1 body2 ... ) ) ) ) ) 当 let* 没有绑定时，有一种基本模式，在这种情况下，它直接转化为一个 let。当至少有一个绑定时，也有一个递归模式，在这种情况下，let* 会转化为一个嵌套在 let 中的更简单的 let*。宏定义中的省略号 (...) 类似于正则表达式中的 Kleene 星号 (*)，表示前一项可以匹配零次或多次。因此，具有单一绑定的 let* 与上述第二条模式规则相匹配，其中 (name2 val2) 匹配次数为零。\nCPP Macros 我们再来看看 CPP 宏。尽管宏不卫生，但在涉及元编程的任务中却非常有用。\nCPP 允许我们使用 #define 来定义两种类型的 macro，即 object-like macro 和 function-like macro。object-like macro 是一种简单的文本替换，用一个文本序列替换另一个文本序列。在历史上，定义常量是一种常用的方法：\n1 2 3 4 5 6 #define PI 3.1415926535 int main() { cout \u003c\u003c \"pi = \" \u003c\u003c PI \u003c\u003c endl; cout \u003c\u003c \"tau = \" \u003c\u003c PI * 2 \u003c\u003c endl; } 在 C++ 中，更好的做法是使用 const 或 constexpr 定义常量。\nfunction-like macro 接受参数 (如上文的 SWAP)，并能将参数文本替换到替换文本中的特定位置。\n使用 function-like macro 的一个更复杂的例子是对遵循相同模式的多段代码进行抽象定义。请看表示复数的类型定义：\n1 2 3 4 5 6 7 8 struct Complex { double real; double imag; }; ostream \u0026operator\u003c\u003c(ostream \u0026os, Complex c) { return os \u003c\u003c \"(\" \u003c\u003c c.real \u003c\u003c \"+\" \u003c\u003c c.imag \u003c\u003c \"i)\"; } 假设除了上述重载的流插入操作符之外，我们还希望支持算术运算 +、- 和 *。这些运算的基本形式相同：\n1 2 3 Complex operator \u003cop\u003e(Complex a, Complex b) { return Complex{ \u003cexpression for real\u003e, \u003cexpression for imag\u003e }; } 在这里，我们使用了 uniform initialization syntax 来初始化一个含有其成员值的 Complex。然后，我们可以编写一个 function-like macro 来抽象这个结构：\n1 2 3 4 #define COMPLEX_OP(op, real_part, imag_part) \\ Complex operator op(Complex a, Complex b) { \\ return Complex{ real_part, imag_part }; \\ } 该 macro 的参数包括运算符、计算实部的表达式和计算虚部的表达式。我们可以使用下面的宏来定义运算：\n1 2 3 4 COMPLEX_OP(+, a.real+b.real, a.imag+b.imag); COMPLEX_OP(-, a.real-b.real, a.imag-b.imag); COMPLEX_OP(*, a.real*b.real - a.imag*b.imag, a.imag*b.real + a.real*b.imag); 与我们最初的 SWAP 实现一样，尾部的分号是多余的，但却提高了可读性以及与语法高亮程序的交互性。使用 g++ -E 在预处理器中运行代码，我们可以得到（修改间距）：\n1 2 3 4 5 6 7 8 9 10 Complex operator +(Complex a, Complex b) { return Complex{ a.real+b.real, a.imag+b.imag }; }; Complex operator -(Complex a, Complex b) { return Complex{ a.real-b.real, a.imag-b.imag }; }; Complex operator *(Complex a, Complex b) { return Complex{ a.real*b.real - a.imag*b.imag, a.imag*b.real + a.real*b.imag }; }; 接下来，我们可以定义 Complex 和 double 之间的运算。我们再次发现，这种操作具有特定的模式：\n1 2 3 Complex operator \u003cop\u003e(\u003ctype1\u003e a, \u003ctype2\u003e b) { return \u003cexpr1\u003e \u003cop\u003e \u003cexpr2\u003e; } 这里， 是转换为 Complex 表示的相应参数。我们可以使用宏对其进行抽象：\n1 2 3 4 #define REAL_OP(op, typeA, typeB, argA, argB) \\ Complex operator op(typeA a, typeB b) { \\ return argA op argB; \\ } 我们还可以定义一个宏，将 double 转换为 Complex：\n1 2 #define CONVERT(a) \\ (Complex{ a, 0 }) 这样，我们就可以对操作进行如下定义：\n1 2 3 4 5 6 REAL_OP(+, Complex, double, a, CONVERT(b)); REAL_OP(+, double, Complex, CONVERT(a), b); REAL_OP(-, Complex, double, a, CONVERT(b)); REAL_OP(-, double, Complex, CONVERT(a), b); REAL_OP(*, Complex, double, a, CONVERT(b)); REAL_OP(*, double, Complex, CONVERT(a), b); 通过预处理器运行，我们可以得到\n1 2 3 4 5 6 Complex operator +(Complex a, double b) { return a + (Complex{ b, 0 }); }; Complex operator +(double a, Complex b) { return (Complex{ a, 0 }) + b; }; Complex operator -(Complex a, double b) { return a - (Complex{ b, 0 }); }; Complex operator -(double a, Complex b) { return (Complex{ a, 0 }) - b; }; Complex operator *(Complex a, double b) { return a * (Complex{ b, 0 }); }; Complex operator *(double a, Complex b) { return (Complex{ a, 0 }) * b; }; 现在我们可以如下使用复数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { Complex c1{ 3, 4 }; Complex c2{ -1, 2 }; double d = 0.5; cout \u003c\u003c c1 + c2 \u003c\u003c endl; cout \u003c\u003c c1 - c2 \u003c\u003c endl; cout \u003c\u003c c1 * c2 \u003c\u003c endl; cout \u003c\u003c c1 + d \u003c\u003c endl; cout \u003c\u003c c1 - d \u003c\u003c endl; cout \u003c\u003c c1 * d \u003c\u003c endl; cout \u003c\u003c d + c1 \u003c\u003c endl; cout \u003c\u003c d - c1 \u003c\u003c endl; cout \u003c\u003c d * c1 \u003c\u003c endl; } 1 2 3 4 5 6 7 8 9 (2+6i) (4+2i) (-11+2i) (3.5+4i) (2.5+4i) (1.5+2i) (3.5+4i) (-2.5+-4i) (1.5+2i) Stringification and Concatenation 在使用宏时，将宏参数转换为字符串或将其与其他标记连接起来可能很有用。例如，假设我们要编写一个交互式应用程序，读取用户的输入并执行相应的操作。对于复数，目标函数可能如下：\n1 2 3 4 5 6 7 8 Complex Complex_conjugate(Complex c) { return Complex{ c.real, -c.imag }; } string Complex_polar(Complex c) { return \"(\" + to_string(sqrt(pow(c.real, 2) + pow(c.imag, 2))) + \",\" + to_string(atan(c.imag / c.real)) + \")\"; } 应用程序会将用户输入与代表操作的字符串进行比较，调用相应的函数，并打印出结果。这就是常见的模式：\n1 2 if (\u003cinput\u003e == \"\") cout \u003c\u003c Complex_\u003caction\u003e(\u003cvalue\u003e) \u003c\u003c endl; 在这里，我们既需要动作的字符串表示法，也需要将 Complex_ 标记与动作标记本身连接起来的能力。我们可以为这种模式定义如下宏：\n1 2 3 #define ACTION(str, name, arg) \\ if (str == #name) \\ cout \u003c\u003c Complex_ ## name(arg) \u003c\u003c endl 标记前的 ## 是字符串化运算符，将标记转换为字符串。Complex_ 和 name 之间的 ## 是标记粘贴操作符，用于连接两边的标记。\n这样，我们就可以编写如下应用代码：\n1 2 3 4 5 6 Complex c1 { 3, 4 }; string s; while (cin \u003e\u003e s) { ACTION(s, conjugate, c1); ACTION(s, polar, c1); } 通过预处理器运行这个程序，我们就能得到想要的结果：\n1 2 3 4 5 6 Complex c1 { 3, 4 }; string s; while (cin \u003e\u003e s) { if (s == \"conjugate\") cout \u003c\u003c Complex_conjugate(c1) \u003c\u003c endl; if (s == \"polar\") cout \u003c\u003c Complex_polar(c1) \u003c\u003c endl; } The Macro Namespace 使用 CPP 宏的一个缺陷是，它们不包含在任何特定的命名空间中。事实上，只要定义了宏，它就能替换任何符合条件的标识符，无论该标识符位于何处。因此，定义一个宏就相当于让一个特定的标识符充当保留关键字，程序员无法使用。这也是为什么常量通常最好定义为变量，限定为 const 或 constexpr，而不是类似对象的宏的原因之一。\n为避免污染全局命名空间，使用了几种约定。\n第一种是在所有宏的前缀加上定义宏的库所特有的字符，以避免与其他库发生冲突。例如，我们的复数宏可以用 COMPLEX_ 作为前缀，以避免与其他宏或标识符冲突。 第二种策略是在不再需要宏时，使用 #undef 预处理器指令取消对宏的定义。例如，在库代码的末尾，我们可能有如下代码： 1 2 3 4 #undef COMPLEX_OP #undef REAL_OP #undef CONVERT #undef ACTION 这样，标识符就可以在以后的代码中用于其他目的。\nCode Generation 虽然 macros 允许我们使用一种语言提供的宏设施生成代码，但在某些情况下，这种设施无法使用或不足以满足我们的目的。在这种情况下，在外部程序中用同一种语言或另一种语言编写代码生成器可能会比较方便。这种技术也称为 automatic programming。\n例如，R5RS Scheme 规范要求实现提供 car 和 cdr 的组合，最深可达四层。例如，(caar x) 应等同于 (car (car x))，(caddar x) 应等同于 (car (cdr (cdr (car x))))。除了 car 和 cdr 本身外，还需要提供 28 种组合，手工编写既繁琐又容易出错。相反，我们可以定义下面的 Python 脚本来生成一个 Scheme 库文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import itertools def cadrify(seq): if len(seq): return '(c{0}r {1})'.format(seq[0], cadrify(seq[1:])) return 'x' def defun(seq): return '(define (c{0}r x) {1})'.format(''.join(seq), cadrify(seq)) for i in range(2, 5): for seq in itertools.product(('a', 'd'), repeat=i): print(defun(seq)) cadrify() 函数是一个递归函数，它接收一个序列，如 ('a','d','a')，并使用第一个项目和序列其余部分的递归结果构造一个调用。在本例中，后者是 (cdr (car x))，因此结果是 (car (cdr (car x)))。基本情况是序列为空，只产生 x。\ndefun() 函数接收一个序列，并用它为相应的组合构建定义。它调用 cadrify() 构建正文。对于序列 ('a','d','a')，结果是\n1 (define (cadar x) (car (cdr (car x)))) 最后，循环结束时会产生每个长度的 a 和 d 的所有组合。它使用函数库中的 itertools.product() 函数来获得一个序列，该序列是元组 ('a','d') 的第 i 次幂。对于每个组合，它都会调用 defun() 生成该组合的函数。\n1 2 3 4 5 6 7 8 9 (define (caar x) (car (car x))) (define (cadr x) (car (cdr x))) (define (cdar x) (cdr (car x))) (define (cddr x) (cdr (cdr x))) (define (caaar x) (car (car (car x)))) (define (caadr x) (car (car (cdr x)))) ... (define (cdddar x) (cdr (cdr (cdr (car x))))) (define (cddddr x) (cdr (cdr (cdr (cdr x))))) 我们可以将生成的代码放入标准库中，由 Scheme 解释器加载。\nTemplate Metaprogramming Template metaprogramming 是一种在编译时使用模板生成源代码的技术，然后将源代码与程序的其他代码一起编译。它通常是指利用语言的模板实例化规则进行编译时执行的一种形式。Template metaprogramming 在 C++ 中最为常见，但也有少数其他语言可以使用。\nC++ 中模板元编程的关键是 template specialization，它允许编写专门的定义来实例化带有特定参数的模板。例如，考虑一个包含静态值域的类模板，如果模板参数为 int，该值域为 true，否则为 false。我们可以如下编写通用模板：\n1 2 3 4 template \u003cclass T\u003e struct is_int { static const bool value = false; }; 现在我们可以定义当参数为 int 时该模板的特殊化：\n1 2 3 4 template \u003c\u003e struct is_int\u003cint\u003e { static const bool value = true; }; 特化中的模板参数列表包含非特化参数。在上面的例子中，没有任何参数，所以是空的。然后，在模板名称之后，我们提供了实例化的全部参数集，在本例中只有 int。然后，我们提供实例化的其余定义。\n现在，当我们使用模板时，如果模板参数与特化兼容，编译器就会使用特化，否则就会使用通用模板：\n1 2 3 4 5 cout \u003c\u003c is_int\u003cdouble\u003e::value \u003c\u003c endl; cout \u003c\u003c is_int\u003cint\u003e::value \u003c\u003c endl; // output 0 1 模板特化使我们能够编写以模板参数为条件的代码。与递归实例化相结合，这使得模板实例化具有图灵完备性。模板不对可变变量进行编码，因此模板元编程实际上是函数式编程的一种形式。\nPairs 举个更复杂的例子，让我们定义可在编译时操作的 pairs 和 lists。这些结构中存储的元素将是任意类型。\n在开始定义 pairs 之前，我们先构建一个报告机制，以便在编译时检查结果。我们将在编译器生成的错误信息中包含相关信息：\n1 2 3 4 template \u003cclass A, int I\u003e struct report { static_assert(I \u003c 0, \"report\"); }; 为了简单起见，我们使用了一个 integer 模板参数，当然也可以使用类型对数字进行编码。在实例化 report 模板时，如果模板参数 I 为非负，static_assert 会引发错误。请看下面的内容：\n1 report\u003cint, 5\u003e foo; 编译器会报错，指出是哪个实例导致 static_assert 失败。在 Clang 中，我们会得到类似下面的错误：\n1 2 3 4 5 6 pair.cpp:64:3: error: static_assert failed \"report\" static_assert(I \u003c 0, \"report\"); ^ ~~~~~ pair.cpp:67:16: note: in instantiation of template class 'report' requested here report foo; 使用 GCC，错误如下：\n1 2 3 4 5 pair.cpp: In instantiation of 'struct report': pair.cpp:67:16: required from here main.cpp:64:3: error: static assertion failed: report static_assert(I \u003c 0, \"report\"); ^ 两个编译器都报告了相关信息，即报告模板的参数是 int 和 5。\n这样，我们就可以定义 pair 模板如下：\n1 2 3 4 5 template \u003cclass First, class Second\u003e struct pair { using car = First; using cdr = Second; }; 在 template 中，我们定义了类型别名 car 和 cdr，用于指代配对的第一项和第二项。因此，pair::car 是 int 的别名，而 pair::cdr 是 double 的别名。\n我们还可以定义类型别名，以便从数据对中提取第一项和第二项：\n1 2 3 4 template \u003cclass Pair\u003e using car_t = typename Pair::car; template \u003cclass Pair\u003e using cdr_t = typename Pair::cdr; 在 Pair::car 和 Pair::cdr 之前需要使用 typename 关键字，因为我们使用的是嵌套类型，其外层类型依赖于模板参数。在这种情况下，C++ 无法确定我们命名的是一个类型而不是一个值，因此 typename 关键字明确表示这是一个类型。使用上述别名，car_t",
  "wordCount" : "2392",
  "inLanguage": "zh",
  "datePublished": "2023-10-16T15:29:44+08:00",
  "dateModified": "2023-10-16T15:29:44+08:00",
  "author":{
    "@type": "Person",
    "name": "WFUing"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://WFUing.github.io/post/tech/language/metaprogramming/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Waiting For You",
    "logo": {
      "@type": "ImageObject",
      "url": "https://WFUing.github.io/img/logo.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<header class="header"><nav class="nav">
    <div class="logo">
        <a style="color: rgb(218, 218, 219);" href="https://WFUing.github.io/" accesskey="h" title="Waiting For You (Alt + H)">Waiting For You</a>
        <div class="logo-switches">
            <button id="theme-toggle" accesskey="t" title="(Alt + T)" style="color: rgb(218, 218, 219);">
                <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
                <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
            </button>
        </div>
    </div>
    <ul id="menu">
        <li>
            <a href="https://WFUing.github.io/search" title="SEARCH (Alt &#43; /)" accesskey=/>
                <span style="color: rgb(218, 218, 219);">SEARCH</span>
            </a>
        </li>
        <li>
            <a href="https://WFUing.github.io/" title="HOME">
                <span style="color: rgb(218, 218, 219);">HOME</span>
            </a>
        </li>
        <li>
            <a href="https://WFUing.github.io/post" title="BLOGS">
                <span style="color: rgb(218, 218, 219);">BLOGS</span>
            </a>
        </li>
        <li>
            <a href="https://WFUing.github.io/archives" title="ARCHIVE">
                <span style="color: rgb(218, 218, 219);">ARCHIVE</span>
            </a>
        </li>
        <li>
            <a href="https://WFUing.github.io/tags" title="TAGS">
                <span style="color: rgb(218, 218, 219);">TAGS</span>
            </a>
        </li>
    </ul>
</nav>
</header>


<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://WFUing.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/post/">Posts</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/post/tech/">Technology</a>&nbsp;»&nbsp;<a href="https://WFUing.github.io/post/tech/language/">Language</a></div>
    <h1 class="post-title">
      meta-programming
    </h1>
    <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-10-16
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>2392字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>12分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>WFUing
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://WFUing.github.io/tags/metaprogramming/" style="color: var(--secondary)!important;">metaprogramming</a>
                &nbsp;<a href="https://WFUing.github.io/tags/language/" style="color: var(--secondary)!important;">language</a>
            </span>
        </span>
    </span>
</span>
        &nbsp;|&nbsp;标签: &nbsp;
        <ul class="post-tags-meta">
            <a href="https://WFUing.github.io/tags/metaprogramming/">metaprogramming</a>
            <a href="https://WFUing.github.io/tags/language/">、language</a>
        </ul>

        
        
        
        
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_page_pv">
            &nbsp;| 访问: <span id="busuanzi_value_page_pv"></span>
        </span>

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#macros-and-code-generation" aria-label="Macros and Code Generation">Macros and Code Generation</a><ul>
                            
                    <li>
                        <a href="#scheme-macros" aria-label="Scheme Macros">Scheme Macros</a></li>
                    <li>
                        <a href="#cpp-macros" aria-label="CPP Macros">CPP Macros</a><ul>
                            
                    <li>
                        <a href="#stringification-and-concatenation" aria-label="Stringification and Concatenation">Stringification and Concatenation</a></li>
                    <li>
                        <a href="#the-macro-namespace" aria-label="The Macro Namespace">The Macro Namespace</a></li></ul>
                    </li>
                    <li>
                        <a href="#code-generation" aria-label="Code Generation">Code Generation</a></li></ul>
                    </li>
                    <li>
                        <a href="#template-metaprogramming" aria-label="Template Metaprogramming">Template Metaprogramming</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#pairs" aria-label="Pairs">Pairs</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#resources" aria-label="RESOURCES">RESOURCES</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>元编程是编写可在其他程序上运行的计算机程序的技术。诸如编译器和程序分析器之类的系统可以被视为元程序，因为它们将其他程序作为输入。我们将在这里讨论的元编程形式特别关注生成要作为程序一部分包含的代码。从某种意义上说，它们可以被认为是初级编译器。</p>
<h2 id="macros-and-code-generation">Macros and Code Generation<a hidden class="anchor" aria-hidden="true" href="#macros-and-code-generation">#</a></h2>
<p>macro 是将输入序列转换为某种替换输出序列的规则。这个翻译过程称为 macro expansion，一些语言提供宏作为其规范的一部分。宏设施可以被实现为 preprocessing step，其中宏扩展发生在 lexical and syntactic analysis 之前，或者它可以被合并为 syntax analysis 或 a later translation step。</p>
<p>使用最广泛的 macro systems 之一是 C 预处理器（CPP），它作为处理程序的第一步被包含在 C 和 C++ 中。预处理器指令以散列符号开头，包括 <code>#include</code>、<code>#define</code>、<code>#if</code> 等。例如，下面定义了一个类似函数的 macro 来交换两个项目：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define SWAP(a, b) { auto tmp = b; b = a; a = tmp; }
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后，我们可以如下使用宏：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">SWAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">4</span> <span class="mi">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过向 <code>g++</code> 传递 <code>-E</code> 标志，可以获得宏扩展的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ g++ -E &lt;source&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过，如果使用 <code>#includes</code> 指令，结果可能会非常混乱，因为该指令会从给定文件中调入代码。</p>
<p>CPP macros perform text 替换，因此上述代码等同于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 SWAP 宏后的分号仍然保留，表示空语句。不过，在需要使用单一语句的情况下，例如一个没有被 block 括住的条件分支，这就会造成问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">SWAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;no swap&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>避免这一问题的常用方法是将 macro 的扩展代码放在 do/while 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define SWAP(a, b) do {                         \
</span></span></span><span class="line"><span class="cl"><span class="cp">    auto tmp = b;                               \
</span></span></span><span class="line"><span class="cl"><span class="cp">    b = a;                                      \
</span></span></span><span class="line"><span class="cl"><span class="cp">    a = tmp;                                    \
</span></span></span><span class="line"><span class="cl"><span class="cp">  } while (false)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们在一行的末尾添加了一个 <code>\</code>，表示下一行应被视为上一行的继续。do/while 循环在语法上以分号结束，因此 <code>SWAP(x, y);</code> 中的分号在语法上是 do/while 循环的一部分。因此，扩展代码的语法是正确的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span> <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;no swap&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然 textual replacement 很有用，但它也有缺点，因为虽然宏在语法上类似函数，但它们的行为却不像函数。具体来说，它们不把参数作为自己的实体，也不引入独立的作用域。请看下面的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">SWAP</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 <code>g++ -E</code>，我们可以看到预处理后的代码。只看 <code>main()</code> 的输出，我们会发现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们手动添加了换行符和空格，以使输出更易读；而预处理器本身会将宏输出放在一行中。罪魁祸首是最后生成的语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 C++ 中，条件运算符 <code>? :</code> 和赋值运算符 <code>=</code> 具有相同的优先级，并且从右向左关联，因此这等同于</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于 <code>x &lt; y，</code>这里没有赋值。因此，<code>x</code> 的值保持不变。</p>
<p>我们可以在每次使用 macro argument 时加上括号来解决这个问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define SWAP(a, b) do {                         \
</span></span></span><span class="line"><span class="cl"><span class="cp">    auto tmp = (b);                             \
</span></span></span><span class="line"><span class="cl"><span class="cp">    (b) = (a);                                  \
</span></span></span><span class="line"><span class="cl"><span class="cp">    (a) = tmp;                                  \
</span></span></span><span class="line"><span class="cl"><span class="cp">  } while (false)
</span></span></span></code></pre></td></tr></table>
</div>
</div><center><figure>
    <img loading="lazy" src="./c&#43;&#43;associativity.png" width="60%"/> <figcaption>
            Ranking the Operator Precedence in C&#43;&#43;
        </figcaption>
</figure>
</center>
<p>现在会产生预期的结果，因为括号明确地将这些操作联系起来：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而，第二个问题并不那么容易解决。考虑一下当我们将 SWAP 宏应用于名为 tmp 的变量时会发生什么：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">SWAP</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">3</span> <span class="mi">4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>没有发生交换！再次使用 <code>g++ -E</code> 检查输出，我们可以看到（模数间隔）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于 SWAP 使用的临时变量与参数同名，因此临时变量会捕获生成代码中出现的参数。这是因为宏只是执行文本替换，并不能确保名称被解析到适当的作用域。因此，宏实际上并不使用按名称调用，而按名称调用可确保参数中的名称解析到适当的作用域。对文本替换的依赖使 CPP 成为一个不卫生的宏系统。其他系统（如 Scheme 的系统）是卫生的，它们为宏引入的名称创建了单独的作用域，并确保参数不会被捕获。</p>
<h3 id="scheme-macros">Scheme Macros<a hidden class="anchor" aria-hidden="true" href="#scheme-macros">#</a></h3>
<p>作为 R5RS Scheme 规范的一部分，宏系统是卫生的。宏由 define-syntax、let-syntax 或 letrec-syntax 中的一种形式引入，并将给定的名称与宏绑定。例如，下面是 let 作为宏的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define-syntax let
</span></span><span class="line"><span class="cl">  (syntax-rules ()
</span></span><span class="line"><span class="cl">    ((let ((name val) ...)
</span></span><span class="line"><span class="cl">       body1 body2 ...
</span></span><span class="line"><span class="cl">     )
</span></span><span class="line"><span class="cl">     ((lambda (name ...)
</span></span><span class="line"><span class="cl">        body1 body2 ...
</span></span><span class="line"><span class="cl">      )
</span></span><span class="line"><span class="cl">      val ...
</span></span><span class="line"><span class="cl">     )
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">)
</span></span></code></pre></td></tr></table>
</div>
</div><p>syntax-rules 指定了宏转换的规则。第一个参数是规则模式与输入之间必须匹配的字面形式列表。例如，cond 形式中的 else 标识符。但在这种情况下，没有字面意义。syntax-rules 的其余参数指定了转换。转换的第一项是输入模式，第二项是输出模式。<code>...</code>的作用类似于克莱因星，将前一项与输入中出现的零次或多次相匹配。输入模式中出现但不在字面量列表中的名称，除了作为宏名称的第一项，都是与输入元素相匹配的卫生变量。这些变量可以在输出模式中引用，以指定如何构造输出。</p>
<p>在全局环境中评估上述表达式时，会将 let 名称与一个转换为 lambda 的宏绑定。</p>
<p>宏主体引入的标识符保证避免与其他标识符冲突，解释器通常会重命名标识符以避免冲突。下面是 swap 宏的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define-syntax swap
</span></span><span class="line"><span class="cl">  (syntax-rules ()
</span></span><span class="line"><span class="cl">    ((swap a b)
</span></span><span class="line"><span class="cl">     (let ((tmp b))
</span></span><span class="line"><span class="cl">       (set! b a)
</span></span><span class="line"><span class="cl">       (set! a tmp)
</span></span><span class="line"><span class="cl">     )
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">)
</span></span></code></pre></td></tr></table>
</div>
</div><p>这就将 swap 的使用转化为一个表达式，通过临时变量 tmp 交换两个参数。因此</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; <span class="o">(</span>define x 3<span class="o">)</span>
</span></span><span class="line"><span class="cl">&gt; <span class="o">(</span>define y 4<span class="o">)</span>
</span></span><span class="line"><span class="cl">&gt; <span class="o">(</span>swap x y<span class="o">)</span>
</span></span><span class="line"><span class="cl">&gt; x
</span></span><span class="line"><span class="cl"><span class="m">4</span>
</span></span><span class="line"><span class="cl">&gt; y
</span></span><span class="line"><span class="cl"><span class="m">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过，与 CPP 宏不同的是，swap 宏引入的 tmp 与其他任何 tmp 都是不同的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; <span class="o">(</span>define tmp 5<span class="o">)</span>
</span></span><span class="line"><span class="cl">&gt; <span class="o">(</span>swap x tmp<span class="o">)</span>
</span></span><span class="line"><span class="cl">&gt; x
</span></span><span class="line"><span class="cl"><span class="m">5</span>
</span></span><span class="line"><span class="cl">&gt; tmp
</span></span><span class="line"><span class="cl"><span class="m">4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为宏在 Scheme 中是卫生的，所以我们会得到预期的行为。</p>
<p>为了支持宏，Scheme 解释器的评估过程会像往常一样评估列表中的第一个项目。如果评估结果是一个宏，那么解释器将对列表的其余部分执行宏扩展，而不会首先评估参数。扩展引入的任何名称都与其他名称置于不同的作用域。扩展后，解释器会对扩展结果重复求值过程，因此，如果最终结果是一个 <code>let</code> 表达式 (如上文 <code>swap</code> 中的表达式)，就会对该表达式进行求值。</p>
<p>一个宏定义可以指定多个模式规则。再加上扩展的结果会被求值，这使得宏定义可以递归，如下面的 <code>let*</code> 定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define-syntax let*
</span></span><span class="line"><span class="cl">  (syntax-rules ()
</span></span><span class="line"><span class="cl">    ((let* ()
</span></span><span class="line"><span class="cl">       body1 body2 ...
</span></span><span class="line"><span class="cl">     )
</span></span><span class="line"><span class="cl">     (let ()
</span></span><span class="line"><span class="cl">       body1 body2 ...
</span></span><span class="line"><span class="cl">     )
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">    ((let* ((name1 val1) (name2 val2) ...)
</span></span><span class="line"><span class="cl">       body1 body2 ...
</span></span><span class="line"><span class="cl">     )
</span></span><span class="line"><span class="cl">     (let ((name1 val1))
</span></span><span class="line"><span class="cl">       (let* ((name2 val2) ...)
</span></span><span class="line"><span class="cl">         body1 body2 ...
</span></span><span class="line"><span class="cl">       )
</span></span><span class="line"><span class="cl">     )
</span></span><span class="line"><span class="cl">    )
</span></span><span class="line"><span class="cl">  )
</span></span><span class="line"><span class="cl">)
</span></span></code></pre></td></tr></table>
</div>
</div><p>当 <code>let*</code> 没有绑定时，有一种基本模式，在这种情况下，它直接转化为一个 <code>let</code>。当至少有一个绑定时，也有一个递归模式，在这种情况下，<code>let*</code> 会转化为一个嵌套在 <code>let</code> 中的更简单的 <code>let*</code>。宏定义中的省略号 (<code>...</code>) 类似于正则表达式中的 Kleene 星号 (<code>*</code>)，表示前一项可以匹配零次或多次。因此，具有单一绑定的 <code>let*</code> 与上述第二条模式规则相匹配，其中 (<code>name2 val2</code>) 匹配次数为零。</p>
<h3 id="cpp-macros">CPP Macros<a hidden class="anchor" aria-hidden="true" href="#cpp-macros">#</a></h3>
<p>我们再来看看 CPP 宏。尽管宏不卫生，但在涉及元编程的任务中却非常有用。</p>
<p>CPP 允许我们使用 <code>#define</code> 来定义两种类型的 macro，即 <code>object-like macro</code> 和 <code>function-like macro</code>。<code>object-like macro</code> 是一种简单的文本替换，用一个文本序列替换另一个文本序列。在历史上，定义常量是一种常用的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define PI 3.1415926535
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;pi = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">PI</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;tau = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 C++ 中，更好的做法是使用 const 或 constexpr 定义常量。</p>
<p><code>function-like macro</code> 接受参数 (如上文的 <code>SWAP</code>)，并能将参数文本替换到替换文本中的特定位置。</p>
<p>使用 <code>function-like macro</code> 的一个更复杂的例子是对遵循相同模式的多段代码进行抽象定义。请看表示复数的类型定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">Complex</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">real</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">imag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;(&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;+&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">imag</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;i)&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设除了上述重载的流插入操作符之外，我们还希望支持算术运算 <code>+</code>、<code>-</code> 和 <code>*</code>。这些运算的基本形式相同：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">&lt;</span><span class="n">op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">Complex</span><span class="p">{</span> <span class="o">&lt;</span><span class="n">expression</span> <span class="k">for</span> <span class="n">real</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">expression</span> <span class="k">for</span> <span class="n">imag</span><span class="o">&gt;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们使用了 <code>uniform initialization syntax</code> 来初始化一个含有其成员值的 <code>Complex</code>。然后，我们可以编写一个 <code>function-like macro</code> 来抽象这个结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define COMPLEX_OP(op, real_part, imag_part)    \
</span></span></span><span class="line"><span class="cl"><span class="cp">  Complex operator op(Complex a, Complex b) {   \
</span></span></span><span class="line"><span class="cl"><span class="cp">    return Complex{ real_part, imag_part };     \
</span></span></span><span class="line"><span class="cl"><span class="cp">  }
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>该 <code>macro</code> 的参数包括运算符、计算实部的表达式和计算虚部的表达式。我们可以使用下面的宏来定义运算：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">COMPLEX_OP</span><span class="p">(</span><span class="o">+</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">COMPLEX_OP</span><span class="p">(</span><span class="o">-</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">COMPLEX_OP</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>与我们最初的 <code>SWAP</code> 实现一样，尾部的分号是多余的，但却提高了可读性以及与语法高亮程序的交互性。使用 <code>g++ -E</code> 在预处理器中运行代码，我们可以得到（修改间距）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">+</span><span class="p">(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">Complex</span><span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">+</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">-</span><span class="p">(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">Complex</span><span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">*</span><span class="p">(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">Complex</span><span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">a</span><span class="p">.</span><span class="n">imag</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">real</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">imag</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，我们可以定义 <code>Complex</code> 和 <code>double</code> 之间的运算。我们再次发现，这种操作具有特定的模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">&lt;</span><span class="n">op</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">type1</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">type2</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">&lt;</span><span class="n">expr1</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">op</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">expr2</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里，<code>&lt;exprN&gt;</code> 是转换为 <code>Complex</code> 表示的相应参数。我们可以使用宏对其进行抽象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define REAL_OP(op, typeA, typeB, argA, argB)   \
</span></span></span><span class="line"><span class="cl"><span class="cp">  Complex operator op(typeA a, typeB b) {       \
</span></span></span><span class="line"><span class="cl"><span class="cp">    return argA op argB;                        \
</span></span></span><span class="line"><span class="cl"><span class="cp">  }
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们还可以定义一个宏，将 <code>double</code> 转换为 <code>Complex</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define CONVERT(a)                              \
</span></span></span><span class="line"><span class="cl"><span class="cp">  (Complex{ a, 0 })
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样，我们就可以对操作进行如下定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">REAL_OP</span><span class="p">(</span><span class="o">+</span><span class="p">,</span> <span class="n">Complex</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="nf">CONVERT</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nf">REAL_OP</span><span class="p">(</span><span class="o">+</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">Complex</span><span class="p">,</span> <span class="nf">CONVERT</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">REAL_OP</span><span class="p">(</span><span class="o">-</span><span class="p">,</span> <span class="n">Complex</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="nf">CONVERT</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nf">REAL_OP</span><span class="p">(</span><span class="o">-</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">Complex</span><span class="p">,</span> <span class="nf">CONVERT</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">REAL_OP</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">Complex</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="nf">CONVERT</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nf">REAL_OP</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">Complex</span><span class="p">,</span> <span class="nf">CONVERT</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过预处理器运行，我们可以得到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">+</span><span class="p">(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">Complex</span><span class="p">{</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span> <span class="p">});</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">+</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">Complex</span><span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span> <span class="p">})</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">-</span><span class="p">(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="p">(</span><span class="n">Complex</span><span class="p">{</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span> <span class="p">});</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">-</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">Complex</span><span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span> <span class="p">})</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">*</span><span class="p">(</span><span class="n">Complex</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">Complex</span><span class="p">{</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span> <span class="p">});</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">operator</span> <span class="o">*</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">Complex</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">Complex</span><span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span> <span class="p">})</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们可以如下使用复数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Complex</span> <span class="n">c1</span><span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">Complex</span> <span class="n">c2</span><span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span> <span class="o">-</span> <span class="n">c2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">c2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span> <span class="o">-</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">+</span> <span class="n">c1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">-</span> <span class="n">c1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">*</span> <span class="n">c1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">(</span>2+6i<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>4+2i<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>-11+2i<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>3.5+4i<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>2.5+4i<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>1.5+2i<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>3.5+4i<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>-2.5+-4i<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>1.5+2i<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="stringification-and-concatenation">Stringification and Concatenation<a hidden class="anchor" aria-hidden="true" href="#stringification-and-concatenation">#</a></h4>
<p>在使用宏时，将宏参数转换为字符串或将其与其他标记连接起来可能很有用。例如，假设我们要编写一个交互式应用程序，读取用户的输入并执行相应的操作。对于复数，目标函数可能如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Complex</span> <span class="nf">Complex_conjugate</span><span class="p">(</span><span class="n">Complex</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">Complex</span><span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">.</span><span class="n">imag</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">Complex_polar</span><span class="p">(</span><span class="n">Complex</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="s">&#34;(&#34;</span> <span class="o">+</span> <span class="nf">to_string</span><span class="p">(</span><span class="nf">sqrt</span><span class="p">(</span><span class="nf">pow</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">pow</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">imag</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;,&#34;</span> <span class="o">+</span> <span class="nf">to_string</span><span class="p">(</span><span class="nf">atan</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">))</span> <span class="o">+</span> <span class="s">&#34;)&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>应用程序会将用户输入与代表操作的字符串进行比较，调用相应的函数，并打印出结果。这就是常见的模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">input</span><span class="o">&gt;</span> <span class="o">==</span> <span class="s">&#34;&lt;action&gt;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Complex_</span><span class="o">&lt;</span><span class="n">action</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们既需要动作的字符串表示法，也需要将 <code>Complex_</code> 标记与动作标记本身连接起来的能力。我们可以为这种模式定义如下宏：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define ACTION(str, name, arg)                  \
</span></span></span><span class="line"><span class="cl"><span class="cp">  if (str == #name)                             \
</span></span></span><span class="line"><span class="cl"><span class="cp">    cout &lt;&lt; Complex_ ## name(arg) &lt;&lt; endl
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>标记前的 <code>##</code> 是字符串化运算符，将标记转换为字符串。<code>Complex_</code> 和 <code>name</code> 之间的 <code>##</code> 是标记粘贴操作符，用于连接两边的标记。</p>
<p>这样，我们就可以编写如下应用代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">c1</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ACTION</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">,</span> <span class="n">c1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ACTION</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">polar</span><span class="p">,</span> <span class="n">c1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过预处理器运行这个程序，我们就能得到想要的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Complex</span> <span class="n">c1</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="s">&#34;conjugate&#34;</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nf">Complex_conjugate</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="s">&#34;polar&#34;</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="nf">Complex_polar</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="the-macro-namespace">The Macro Namespace<a hidden class="anchor" aria-hidden="true" href="#the-macro-namespace">#</a></h4>
<p>使用 CPP 宏的一个缺陷是，它们不包含在任何特定的命名空间中。事实上，只要定义了宏，它就能替换任何符合条件的标识符，无论该标识符位于何处。因此，定义一个宏就相当于让一个特定的标识符充当保留关键字，程序员无法使用。这也是为什么常量通常最好定义为变量，限定为 const 或 constexpr，而不是类似对象的宏的原因之一。</p>
<p>为避免污染全局命名空间，使用了几种约定。</p>
<ul>
<li>第一种是在所有宏的前缀加上定义宏的库所特有的字符，以避免与其他库发生冲突。例如，我们的复数宏可以用 COMPLEX_ 作为前缀，以避免与其他宏或标识符冲突。</li>
<li>第二种策略是在不再需要宏时，使用 <code>#undef</code> 预处理器指令取消对宏的定义。例如，在库代码的末尾，我们可能有如下代码：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#undef COMPLEX_OP
</span></span></span><span class="line"><span class="cl"><span class="cp">#undef REAL_OP
</span></span></span><span class="line"><span class="cl"><span class="cp">#undef CONVERT
</span></span></span><span class="line"><span class="cl"><span class="cp">#undef ACTION
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这样，标识符就可以在以后的代码中用于其他目的。</p>
<h3 id="code-generation">Code Generation<a hidden class="anchor" aria-hidden="true" href="#code-generation">#</a></h3>
<p>虽然 macros 允许我们使用一种语言提供的宏设施生成代码，但在某些情况下，这种设施无法使用或不足以满足我们的目的。在这种情况下，在外部程序中用同一种语言或另一种语言编写代码生成器可能会比较方便。这种技术也称为 <strong>automatic programming</strong>。</p>
<p>例如，R5RS Scheme 规范要求实现提供 car 和 cdr 的组合，最深可达四层。例如，<code>(caar x)</code> 应等同于 <code>(car (car x))</code>，<code>(caddar x)</code> 应等同于 <code>(car (cdr (cdr (car x))))</code>。除了 <code>car</code> 和 <code>cdr</code> 本身外，还需要提供 28 种组合，手工编写既繁琐又容易出错。相反，我们可以定义下面的 Python 脚本来生成一个 Scheme 库文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">itertools</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">cadrify</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s1">&#39;(c</span><span class="si">{0}</span><span class="s1">r </span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cadrify</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;x&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">defun</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;(define (c</span><span class="si">{0}</span><span class="s1">r x) </span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="n">cadrify</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">defun</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>cadrify()</code> 函数是一个递归函数，它接收一个序列，如 <code>('a','d','a')</code>，并使用第一个项目和序列其余部分的递归结果构造一个调用。在本例中，后者是 <code>(cdr (car x))</code>，因此结果是 <code>(car (cdr (car x)))</code>。基本情况是序列为空，只产生 <code>x</code>。</p>
<p><code>defun()</code> 函数接收一个序列，并用它为相应的组合构建定义。它调用 <code>cadrify()</code> 构建正文。对于序列 <code>('a','d','a')</code>，结果是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define (cadar x) (car (cdr (car x))))
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，循环结束时会产生每个长度的 <code>a</code> 和 <code>d</code> 的所有组合。它使用函数库中的 <code>itertools.product()</code> 函数来获得一个序列，该序列是元组 <code>('a','d')</code> 的第 <code>i</code> 次幂。对于每个组合，它都会调用 <code>defun()</code> 生成该组合的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">(define (caar x) (car (car x)))
</span></span><span class="line"><span class="cl">(define (cadr x) (car (cdr x)))
</span></span><span class="line"><span class="cl">(define (cdar x) (cdr (car x)))
</span></span><span class="line"><span class="cl">(define (cddr x) (cdr (cdr x)))
</span></span><span class="line"><span class="cl">(define (caaar x) (car (car (car x))))
</span></span><span class="line"><span class="cl">(define (caadr x) (car (car (cdr x))))
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">(define (cdddar x) (cdr (cdr (cdr (car x)))))
</span></span><span class="line"><span class="cl">(define (cddddr x) (cdr (cdr (cdr (cdr x)))))
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以将生成的代码放入标准库中，由 Scheme 解释器加载。</p>
<h2 id="template-metaprogramming">Template Metaprogramming<a hidden class="anchor" aria-hidden="true" href="#template-metaprogramming">#</a></h2>
<p>Template metaprogramming 是一种在编译时使用模板生成源代码的技术，然后将源代码与程序的其他代码一起编译。它通常是指利用语言的模板实例化规则进行编译时执行的一种形式。Template metaprogramming 在 C++ 中最为常见，但也有少数其他语言可以使用。</p>
<p>C++ 中模板元编程的关键是 template specialization，它允许编写专门的定义来实例化带有特定参数的模板。例如，考虑一个包含静态值域的类模板，如果模板参数为 int，该值域为 true，否则为 false。我们可以如下编写通用模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">is_int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们可以定义当参数为 int 时该模板的特殊化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">is_int</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>特化中的模板参数列表包含非特化参数。在上面的例子中，没有任何参数，所以是空的。然后，在模板名称之后，我们提供了实例化的全部参数集，在本例中只有 <code>int</code>。然后，我们提供实例化的其余定义。</p>
<p>现在，当我们使用模板时，如果模板参数与特化兼容，编译器就会使用特化，否则就会使用通用模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">is_int</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">is_int</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">0</span> <span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>模板特化使我们能够编写以模板参数为条件的代码。与递归实例化相结合，这使得模板实例化具有图灵完备性。模板不对可变变量进行编码，因此模板元编程实际上是函数式编程的一种形式。</p>
<h4 id="pairs">Pairs<a hidden class="anchor" aria-hidden="true" href="#pairs">#</a></h4>
<p>举个更复杂的例子，让我们定义可在编译时操作的 pairs 和 lists。这些结构中存储的元素将是任意类型。</p>
<p>在开始定义 pairs 之前，我们先构建一个报告机制，以便在编译时检查结果。我们将在编译器生成的错误信息中包含相关信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static_assert</span><span class="p">(</span><span class="n">I</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;report&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了简单起见，我们使用了一个 integer 模板参数，当然也可以使用类型对数字进行编码。在实例化 <code>report</code> 模板时，如果模板参数 I 为非负，<code>static_assert</code> 会引发错误。请看下面的内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">report</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译器会报错，指出是哪个实例导致 <code>static_assert</code> 失败。在 Clang 中，我们会得到类似下面的错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">pair.cpp:64:3: error: static_assert failed <span class="s2">&#34;report&#34;</span>
</span></span><span class="line"><span class="cl">  static_assert<span class="o">(</span>I &lt; 0, <span class="s2">&#34;report&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  ^             ~~~~~
</span></span><span class="line"><span class="cl">pair.cpp:67:16: note: in instantiation of template class <span class="s1">&#39;report&lt;int, 5&gt;&#39;</span>
</span></span><span class="line"><span class="cl">      requested here
</span></span><span class="line"><span class="cl">report&lt;int, 5&gt; foo<span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 GCC，错误如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">pair.cpp: In instantiation of &#39;struct report&lt;int, 5&gt;&#39;:
</span></span><span class="line"><span class="cl">pair.cpp:67:16:   required from here
</span></span><span class="line"><span class="cl">main.cpp:64:3: error: static assertion failed: report
</span></span><span class="line"><span class="cl">   static_assert(I &lt; 0, &#34;report&#34;);
</span></span><span class="line"><span class="cl">   ^
</span></span></code></pre></td></tr></table>
</div>
</div><p>两个编译器都报告了相关信息，即报告模板的参数是 int 和 5。</p>
<p>这样，我们就可以定义 <code>pair</code> 模板如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">First</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Second</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">pair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">car</span> <span class="o">=</span> <span class="n">First</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">cdr</span> <span class="o">=</span> <span class="n">Second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 template 中，我们定义了类型别名 <code>car</code> 和 <code>cdr</code>，用于指代配对的第一项和第二项。因此，<code>pair&lt;int, double&gt;::car</code> 是 <code>int</code> 的别名，而 <code>pair&lt;int, double&gt;::cdr</code> 是 <code>double</code> 的别名。</p>
<p>我们还可以定义类型别名，以便从数据对中提取第一项和第二项：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Pair</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">car_t</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Pair</span><span class="o">::</span><span class="n">car</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Pair</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">cdr_t</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">Pair</span><span class="o">::</span><span class="n">cdr</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>Pair::car</code> 和 <code>Pair::cdr</code> 之前需要使用 <code>typename</code> 关键字，因为我们使用的是嵌套类型，其外层类型依赖于模板参数。在这种情况下，C++ 无法确定我们命名的是一个类型而不是一个值，因此 <code>typename</code> 关键字明确表示这是一个类型。使用上述别名，<code>car_t&lt;pair&lt;int, double&gt;&gt;</code> 是 <code>int</code> 的别名，而 <code>cdr_t&lt;pair&lt;int, double&gt;&gt;</code> 是 <code>double</code> 的别名。</p>
<p>为了表示递归列表，我们需要一个空列表的表示方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们可以定义一个模板来判断一个列表是否为空，这个列表可以用空列表 <code>nil</code> 或以 <code>nil</code> 结尾的对序列来表示。我们定义了一个通用模板，然后针对以 nil 作为参数的情况定义了一个特殊化模板：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">List</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">is_empty</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">is_empty</span><span class="o">&lt;</span><span class="n">nil</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了在编译时使用 <code>value</code>，它必须是一个 <code>compile-time constant</code>，我们可以将其设置为 <code>static</code> 和 <code>const</code>，并使用编译时常量对其进行初始化。在 C++14 中，我们还可以定义全局变量模板（global variable templates）来编码 list 的长度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">List</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">bool</span> <span class="n">is_empty_v</span> <span class="o">=</span> <span class="n">is_empty</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>is_empty_v&lt;nil&gt;</code> 的值为 true，而 <code>is_empty&lt;pair&lt;int, nil&gt;&gt;</code> 的值为 false。这样，我们就可以在编译时确定列表是否为空：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">nil</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">nil</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">z</span> <span class="o">=</span> <span class="n">nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">report</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span> <span class="n">is_empty_v</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">report</span><span class="o">&lt;</span><span class="n">y</span><span class="p">,</span> <span class="n">is_empty_v</span><span class="o">&lt;</span><span class="n">y</span><span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">report</span><span class="o">&lt;</span><span class="n">z</span><span class="p">,</span> <span class="n">is_empty_v</span><span class="o">&lt;</span><span class="n">z</span><span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们为列表引入了类型别名，作为编译时不可变的变量。然后，我们用类型和是否为空实例化报告。这样，GCC 会给出以下错误信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zsh" data-lang="zsh"><span class="line"><span class="cl">pair.cpp: In instantiation of <span class="s1">&#39;struct report&lt;pair&lt;char, pair&lt;int,
</span></span></span><span class="line"><span class="cl"><span class="s1">  pair&lt;double, nil&gt; &gt; &gt;, 0&gt;&#39;</span>:
</span></span><span class="line"><span class="cl">pair.cpp:82:28:   required from here
</span></span><span class="line"><span class="cl">pair.cpp:73:3: error: static assertion failed: report
</span></span><span class="line"><span class="cl">   static_assert<span class="o">(</span>I &lt; 0, <span class="s2">&#34;report&#34;</span><span class="o">)</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   ^~~~~~~~~~~~~
</span></span><span class="line"><span class="cl">pair.cpp: In instantiation of <span class="s1">&#39;struct report&lt;pair&lt;float, pair&lt;bool,
</span></span></span><span class="line"><span class="cl"><span class="s1">  nil&gt; &gt;, 0&gt;&#39;</span>:
</span></span><span class="line"><span class="cl">pair.cpp:83:28:   required from here
</span></span><span class="line"><span class="cl">pair.cpp:73:3: error: static assertion failed: report
</span></span><span class="line"><span class="cl">pair.cpp: In instantiation of <span class="s1">&#39;struct report&lt;nil, 1&gt;&#39;</span>:
</span></span><span class="line"><span class="cl">pair.cpp:84:28:   required from here
</span></span><span class="line"><span class="cl">pair.cpp:73:3: error: static assertion failed: report
</span></span></code></pre></td></tr></table>
</div>
</div><p>检查报告的整数参数，我们会发现列表 <code>pair&lt;char、pair&lt;int、pair&lt;double、nil&gt;&gt;</code> 和 <code>pair&lt;float、pair&lt;bool、nil&gt;&gt;</code> 不是空的，但列表 <code>nil</code> 是空的。</p>
<p>我们可以使用递归计算列表的长度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">List</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">length</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">cdr_t</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;&gt;::</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">length</span><span class="o">&lt;</span><span class="n">nil</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">List</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">length_v</span> <span class="o">=</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们使用的是 <code>length</code> 结构递归实例化的值。由于 <code>value</code> 是通过由编译时常量之间的运算组成的表达式初始化的，因此它也是一个编译时常量。与 <code>is_empty_v</code> 一样，我们定义了一个变量模板 <code>length_v</code> 来对结果进行编码。我们可以计算并报告 <code>x</code> 类型别名的长度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">report</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span> <span class="n">length_v</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>报告的第一个参数是任意的，因为我们只关心第二个参数，所以我们只传递 x 本身。我们得到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zsh" data-lang="zsh"><span class="line"><span class="cl">pair.cpp: In instantiation of <span class="s1">&#39;struct report&lt;pair&lt;char, pair&lt;int,
</span></span></span><span class="line"><span class="cl"><span class="s1">  pair&lt;double, nil&gt; &gt; &gt;, 3&gt;&#39;</span>:
</span></span><span class="line"><span class="cl">pair.cpp:85:26:   required from here
</span></span><span class="line"><span class="cl">pair.cpp:73:3: error: static assertion failed: report
</span></span></code></pre></td></tr></table>
</div>
</div><p>相关信息是长度为 3。</p>
<p>我们还可以定义更复杂的列表操作。例如，我们可以将列表倒转如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">List</span><span class="p">,</span> <span class="k">class</span> <span class="nc">SoFar</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">reverse_helper</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">typename</span> <span class="n">reverse_helper</span><span class="o">&lt;</span><span class="n">cdr_t</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">pair</span><span class="o">&lt;</span><span class="n">car_t</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SoFar</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">SoFar</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">reverse_helper</span><span class="o">&lt;</span><span class="n">nil</span><span class="p">,</span> <span class="n">SoFar</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">SoFar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">List</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">reverse_t</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">reverse_helper</span><span class="o">&lt;</span><span class="n">List</span><span class="p">,</span> <span class="n">nil</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这里，我们使用一个辅助模板来执行反转，其中第一个模板参数是剩余列表，第二个模板参数是到目前为止的反转列表。在每一步中，我们以 <code>pair&lt;car_t&lt;List&gt;, SoFar&gt;</code> 的形式计算新的部分结果，将剩余列表中的第一个项目添加到前一个部分结果的前面。然后 <code>cdr_t&lt;List&gt;</code> 是除去第一个项目的剩余列表。</p>
<p>递归的基本情况是剩余列表为 <code>nil</code>，在这种情况下，最终结果与部分结果相同。我们使用部分类模板特化来实现这一点，它允许我们只特化类模板的部分参数。在 <code>reverse_helper</code> 中，我们对第一个参数进行了特殊化，这样，任何第一个参数为 <code>nil</code> 的 <code>reverse_helper</code> 实例都将使用特殊化。特化保留了一个模板参数，该参数包含在参数列表中。完整的参数列表会出现在模板名称之后，包括特化和未特化的参数。</p>
<h2 id="resources">RESOURCES<a hidden class="anchor" aria-hidden="true" href="#resources">#</a></h2>
<ul>
<li><a href="https://eecs390.github.io/notes/metaprogramming.html">https://eecs390.github.io/notes/metaprogramming.html</a></li>
<li><a href="http://philo.top/2021/03/14/metaprogramming/">http://philo.top/2021/03/14/metaprogramming/</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://WFUing.github.io/tags/metaprogramming/">metaprogramming</a></li>
      <li><a href="https://WFUing.github.io/tags/language/">language</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://WFUing.github.io/post/tech/architecture/serverless/serverless-concept-models/">
    <span class="title">« 上一页</span>
    <br>
    <span>Serverless Concept Models</span>
  </a>
  <a class="next" href="https://WFUing.github.io/post/tech/architecture/iot/state-machine/">
    <span class="title">下一页 »</span>
    <br>
    <span>State Machine</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share meta-programming on twitter"
        href="https://twitter.com/intent/tweet/?text=meta-programming&amp;url=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2fmetaprogramming%2f&amp;hashtags=metaprogramming%2clanguage">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share meta-programming on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2fmetaprogramming%2f&amp;title=meta-programming&amp;summary=meta-programming&amp;source=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2fmetaprogramming%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share meta-programming on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2fmetaprogramming%2f&title=meta-programming">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share meta-programming on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2fmetaprogramming%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share meta-programming on whatsapp"
        href="https://api.whatsapp.com/send?text=meta-programming%20-%20https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2fmetaprogramming%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share meta-programming on telegram"
        href="https://telegram.me/share/url?text=meta-programming&amp;url=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2fmetaprogramming%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share meta-programming on ycombinator"
        href="https://news.ycombinator.com/submitlink?t=meta-programming&u=https%3a%2f%2fWFUing.github.io%2fpost%2ftech%2flanguage%2fmetaprogramming%2f">
        <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
            xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
            <path
                d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
        </svg>
    </a>
</div>

  </footer>
<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>
    <div id="tcomment"></div>
    <script src="https://cdn.staticfile.org/twikoo/1.4.11/twikoo.all.min.js"></script>
    <script>
        twikoo.init({
            envId: "https://twikoo-api-three-gamma.vercel.app/",  
            el: "#tcomment",
            lang: 'zh-CN',
            region: 'ap-guangzhou',  
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        });
    </script>
</div>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://WFUing.github.io/">Waiting For You</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
